{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(\n    address router\n  ) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(\n    Client.Any2EVMMessage memory message\n  ) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view virtual returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != getRouter()) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IGetCCIPAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGetCCIPAdmin {\n  /// @notice Returns the admin of the token.\n  /// @dev This method is named to never conflict with existing methods.\n  function getCCIPAdmin() external view returns (address);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwner {\n  /// @notice Returns the owner of the contract.\n  /// @dev This method is named to match with the OpenZeppelin Ownable contract.\n  function owner() external view returns (address);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Pool} from \"../libraries/Pool.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @notice Shared public interface for multiple V1 pool types.\n/// Each pool type handles a different child token model (lock/unlock, mint/burn.)\ninterface IPoolV1 is IERC165 {\n  /// @notice Lock tokens into the pool or burn the tokens.\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\n  function lockOrBurn(\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut);\n\n  /// @notice Releases or mints tokens to the receiver address.\n  /// @param releaseOrMintIn All data required to release or mint tokens.\n  /// @return releaseOrMintOut The amount of tokens released or minted on the local chain, denominated\n  /// in the local token's decimals.\n  /// @dev The offramp asserts that the balanceOf of the receiver has been incremented by exactly the number\n  /// of tokens that is returned in ReleaseOrMintOutV1.destinationAmount. If the amounts do not match, the tx reverts.\n  function releaseOrMint(\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\n  ) external returns (Pool.ReleaseOrMintOutV1 memory);\n\n  /// @notice Checks whether a remote chain is supported in the token pool.\n  /// @param remoteChainSelector The selector of the remote chain.\n  /// @return true if the given chain is a permissioned remote chain.\n  function isSupportedChain(\n    uint64 remoteChainSelector\n  ) external view returns (bool);\n\n  /// @notice Returns if the token pool supports the given token.\n  /// @param token The address of the token.\n  /// @return true if the token is supported by the pool.\n  function isSupportedToken(\n    address token\n  ) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRMN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice This interface contains the only RMN-related functions that might be used on-chain by other CCIP contracts.\ninterface IRMN {\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\n  struct TaggedRoot {\n    address commitStore;\n    bytes32 root;\n  }\n\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\n  function isBlessed(\n    TaggedRoot calldata taggedRoot\n  ) external view returns (bool);\n\n  /// @notice Iff there is an active global or legacy curse, this function returns true.\n  function isCursed() external view returns (bool);\n\n  /// @notice Iff there is an active global curse, or an active curse for `subject`, this function returns true.\n  /// @param subject To check whether a particular chain is cursed, set to bytes16(uint128(chainSelector)).\n  function isCursed(\n    bytes16 subject\n  ) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouter {\n  error OnlyOffRamp();\n\n  /// @notice Route the message to its intended receiver contract.\n  /// @param message Client.Any2EVMMessage struct.\n  /// @param gasForCallExactCheck of params for exec\n  /// @param gasLimit set of params for exec\n  /// @param receiver set of params for exec\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\n  /// the contract is called. If not, only tokens are transferred.\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\n  function routeMessage(\n    Client.Any2EVMMessage calldata message,\n    uint16 gasForCallExactCheck,\n    uint256 gasLimit,\n    address receiver\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\n\n  /// @notice Returns the configured onramp for a specific destination chain.\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\n  /// @return onRampAddress The address of the onRamp.\n  function getOnRamp(\n    uint64 destChainSelector\n  ) external view returns (address onRampAddress);\n\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\n  /// @param sourceChainSelector The source chain selector to check.\n  /// @param offRamp The address of the offRamp to check.\n  function isOffRamp(uint64 sourceChainSelector, address offRamp) external view returns (bool isOffRamp);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param destChainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(\n    uint64 destChainSelector\n  ) external view returns (bool supported);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/ITokenAdminRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ITokenAdminRegistry {\n  /// @notice Returns the pool for the given token.\n  function getPool(\n    address token\n  ) external view returns (address);\n\n  /// @notice Proposes an administrator for the given token as pending administrator.\n  /// @param localToken The token to register the administrator for.\n  /// @param administrator The administrator to register.\n  function proposeAdministrator(address localToken, address administrator) external;\n\n  /// @notice Accepts the administrator role for a token.\n  /// @param localToken The token to accept the administrator role for.\n  /// @dev This function can only be called by the pending administrator.\n  function acceptAdminRole(\n    address localToken\n  ) external;\n\n  /// @notice Sets the pool for a token. Setting the pool to address(0) effectively delists the token\n  /// from CCIP. Setting the pool to any other address enables the token on CCIP.\n  /// @param localToken The token to set the pool for.\n  /// @param pool The pool to set for the token.\n  function setPool(address localToken, address pool) external;\n\n  /// @notice Transfers the administrator role for a token to a new address with a 2-step process.\n  /// @param localToken The token to transfer the administrator role for.\n  /// @param newAdmin The address to transfer the administrator role to. Can be address(0) to cancel\n  /// a pending transfer.\n  /// @dev The new admin must call `acceptAdminRole` to accept the role.\n  function transferAdminRole(address localToken, address newAdmin) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(\n    EVMExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV2\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V2_TAG = 0x181dcf10;\n\n  /// @param gasLimit: gas limit for the callback on the destination chain.\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to other messages from the same sender.\n  /// This value's default varies by chain. On some chains, a particular value is enforced, meaning if the expected value\n  /// is not set, the message request will revert.\n  struct EVMExtraArgsV2 {\n    uint256 gasLimit;\n    bool allowOutOfOrderExecution;\n  }\n\n  function _argsToBytes(\n    EVMExtraArgsV2 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V2_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Internal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {MerkleMultiProof} from \"../libraries/MerkleMultiProof.sol\";\nimport {Client} from \"./Client.sol\";\n\n// Library for CCIP internal definitions common to multiple contracts.\nlibrary Internal {\n  error InvalidEVMAddress(bytes encodedAddress);\n\n  /// @dev The minimum amount of gas to perform the call with exact gas.\n  /// We include this in the offramp so that we can redeploy to adjust it\n  /// should a hardfork change the gas costs of relevant opcodes in callWithExactGas.\n  uint16 internal constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n  // @dev We limit return data to a selector plus 4 words. This is to avoid\n  // malicious contracts from returning large amounts of data and causing\n  // repeated out-of-gas scenarios.\n  uint16 internal constant MAX_RET_BYTES = 4 + 4 * 32;\n  /// @dev The expected number of bytes returned by the balanceOf function.\n  uint256 internal constant MAX_BALANCE_OF_RET_BYTES = 32;\n\n  /// @notice A collection of token price and gas price updates.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct PriceUpdates {\n    TokenPriceUpdate[] tokenPriceUpdates;\n    GasPriceUpdate[] gasPriceUpdates;\n  }\n\n  /// @notice Token price in USD.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct TokenPriceUpdate {\n    address sourceToken; // Source token\n    uint224 usdPerToken; // 1e18 USD per 1e18 of the smallest token denomination.\n  }\n\n  /// @notice Gas price for a given chain in USD, its value may contain tightly packed fields.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct GasPriceUpdate {\n    uint64 destChainSelector; // Destination chain selector\n    uint224 usdPerUnitGas; // 1e18 USD per smallest unit (e.g. wei) of destination chain gas\n  }\n\n  /// @notice A timestamped uint224 value that can contain several tightly packed fields.\n  struct TimestampedPackedUint224 {\n    uint224 value; // ───────╮ Value in uint224, packed.\n    uint32 timestamp; // ────╯ Timestamp of the most recent price update.\n  }\n\n  /// @dev Gas price is stored in 112-bit unsigned int. uint224 can pack 2 prices.\n  /// When packing L1 and L2 gas prices, L1 gas price is left-shifted to the higher-order bits.\n  /// Using uint8 type, which cannot be higher than other bit shift operands, to avoid shift operand type warning.\n  uint8 public constant GAS_PRICE_BITS = 112;\n\n  struct PoolUpdate {\n    address token; // The IERC20 token address\n    address pool; // The token pool address\n  }\n\n  struct SourceTokenData {\n    // The source pool address, abi encoded. This value is trusted as it was obtained through the onRamp. It can be\n    // relied upon by the destination pool to validate the source pool.\n    bytes sourcePoolAddress;\n    // The address of the destination token, abi encoded in the case of EVM chains\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes extraData;\n    uint32 destGasAmount; // The amount of gas available for the releaseOrMint and balanceOf calls on the offRamp\n  }\n\n  /// @notice Report that is submitted by the execution DON at the execution phase. (including chain selector data)\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct ExecutionReportSingleChain {\n    uint64 sourceChainSelector; // Source chain selector for which the report is submitted\n    Any2EVMRampMessage[] messages;\n    // Contains a bytes array for each message, each inner bytes array contains bytes per transferred token\n    bytes[][] offchainTokenData;\n    bytes32[] proofs;\n    uint256 proofFlagBits;\n  }\n\n  /// @notice Report that is submitted by the execution DON at the execution phase.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct ExecutionReport {\n    EVM2EVMMessage[] messages;\n    // Contains a bytes array for each message, each inner bytes array contains bytes per transferred token\n    bytes[][] offchainTokenData;\n    bytes32[] proofs;\n    uint256 proofFlagBits;\n  }\n\n  /// @notice The cross chain message that gets committed to EVM chains.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVM2EVMMessage {\n    uint64 sourceChainSelector; // ────────╮ the chain selector of the source chain, note: not chainId\n    address sender; // ────────────────────╯ sender address on the source chain\n    address receiver; // ──────────────────╮ receiver address on the destination chain\n    uint64 sequenceNumber; // ─────────────╯ sequence number, not unique across lanes\n    uint256 gasLimit; //                     user supplied maximum gas amount available for dest chain execution\n    bool strict; // ───────────────────────╮ DEPRECATED\n    uint64 nonce; //                       │ nonce for this lane for this sender, not unique across senders/lanes\n    address feeToken; // ──────────────────╯ fee token\n    uint256 feeTokenAmount; //               fee token amount\n    bytes data; //                           arbitrary data payload supplied by the message sender\n    Client.EVMTokenAmount[] tokenAmounts; // array of tokens and amounts to transfer\n    bytes[] sourceTokenData; //              array of token data, one per token\n    bytes32 messageId; //                    a hash of the message data\n  }\n\n  /// @dev EVM2EVMMessage struct has 13 fields, including 3 variable arrays.\n  /// Each variable array takes 1 more slot to store its length.\n  /// When abi encoded, excluding array contents,\n  /// EVM2EVMMessage takes up a fixed number of 16 lots, 32 bytes each.\n  /// For structs that contain arrays, 1 more slot is added to the front, reaching a total of 17.\n  uint256 public constant MESSAGE_FIXED_BYTES = 32 * 17;\n\n  /// @dev Each token transfer adds 1 EVMTokenAmount and 3 bytes at 3 slots each and one slot for the destGasAmount.\n  /// When abi encoded, each EVMTokenAmount takes 2 slots, each bytes takes 1 slot for length, one slot of data and one\n  /// slot for the offset. This results in effectively 3*3 slots per SourceTokenData.\n  /// 0x20\n  /// destGasAmount\n  /// sourcePoolAddress_offset\n  /// destTokenAddress_offset\n  /// extraData_offset\n  /// sourcePoolAddress_length\n  /// sourcePoolAddress_content // assume 1 slot\n  /// destTokenAddress_length\n  /// destTokenAddress_content // assume 1 slot\n  /// extraData_length // contents billed separately\n  uint256 public constant MESSAGE_FIXED_BYTES_PER_TOKEN = 32 * ((1 + 3 * 3) + 2);\n\n  /// @dev Any2EVMRampMessage struct has 10 fields, including 3 variable unnested arrays (data, receiver and tokenAmounts).\n  /// Each variable array takes 1 more slot to store its length.\n  /// When abi encoded, excluding array contents,\n  /// Any2EVMMessage takes up a fixed number of 13 slots, 32 bytes each.\n  /// For structs that contain arrays, 1 more slot is added to the front, reaching a total of 14.\n  /// The fixed bytes does not cover struct data (this is represented by ANY_2_EVM_MESSAGE_FIXED_BYTES_PER_TOKEN)\n  uint256 public constant ANY_2_EVM_MESSAGE_FIXED_BYTES = 32 * 14;\n\n  /// @dev Each token transfer adds 1 RampTokenAmount\n  /// RampTokenAmount has 5 fields, 2 of which are bytes type, 1 Address, 1 uint256 and 1 uint32.\n  /// Each bytes type takes 1 slot for length, 1 slot for data and 1 slot for the offset.\n  /// address\n  /// uint256 amount takes 1 slot.\n  /// uint32 destGasAmount takes 1 slot.\n  uint256 public constant ANY_2_EVM_MESSAGE_FIXED_BYTES_PER_TOKEN = 32 * ((2 * 3) + 3);\n\n  bytes32 internal constant EVM_2_EVM_MESSAGE_HASH = keccak256(\"EVM2EVMMessageHashV2\");\n\n  /// @dev Used to hash messages for single-lane ramps.\n  /// OnRamp hash(EVM2EVMMessage) = OffRamp hash(EVM2EVMMessage)\n  /// The EVM2EVMMessage's messageId is expected to be the output of this hash function\n  /// @param original Message to hash\n  /// @param metadataHash Immutable metadata hash representing a lane with a fixed OnRamp\n  /// @return hashedMessage hashed message as a keccak256\n  function _hash(EVM2EVMMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\n    return keccak256(\n      abi.encode(\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\n        metadataHash,\n        keccak256(\n          abi.encode(\n            original.sender,\n            original.receiver,\n            original.sequenceNumber,\n            original.gasLimit,\n            original.strict,\n            original.nonce,\n            original.feeToken,\n            original.feeTokenAmount\n          )\n        ),\n        keccak256(original.data),\n        keccak256(abi.encode(original.tokenAmounts)),\n        keccak256(abi.encode(original.sourceTokenData))\n      )\n    );\n  }\n\n  bytes32 internal constant ANY_2_EVM_MESSAGE_HASH = keccak256(\"Any2EVMMessageHashV1\");\n  bytes32 internal constant EVM_2_ANY_MESSAGE_HASH = keccak256(\"EVM2AnyMessageHashV1\");\n\n  /// @dev Used to hash messages for multi-lane family-agnostic OffRamps.\n  /// OnRamp hash(EVM2AnyMessage) != Any2EVMRampMessage.messageId\n  /// OnRamp hash(EVM2AnyMessage) != OffRamp hash(Any2EVMRampMessage)\n  /// @param original OffRamp message to hash\n  /// @param metadataHash Hash preimage to ensure global uniqueness\n  /// @return hashedMessage hashed message as a keccak256\n  function _hash(Any2EVMRampMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\n    return keccak256(\n      abi.encode(\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\n        metadataHash,\n        keccak256(\n          abi.encode(\n            original.header.messageId,\n            original.receiver,\n            original.header.sequenceNumber,\n            original.gasLimit,\n            original.header.nonce\n          )\n        ),\n        keccak256(original.sender),\n        keccak256(original.data),\n        keccak256(abi.encode(original.tokenAmounts))\n      )\n    );\n  }\n\n  function _hash(EVM2AnyRampMessage memory original, bytes32 metadataHash) internal pure returns (bytes32) {\n    // Fixed-size message fields are included in nested hash to reduce stack pressure.\n    // This hashing scheme is also used by RMN. If changing it, please notify the RMN maintainers.\n    return keccak256(\n      abi.encode(\n        MerkleMultiProof.LEAF_DOMAIN_SEPARATOR,\n        metadataHash,\n        keccak256(\n          abi.encode(\n            original.sender,\n            original.header.sequenceNumber,\n            original.header.nonce,\n            original.feeToken,\n            original.feeTokenAmount\n          )\n        ),\n        keccak256(original.receiver),\n        keccak256(original.data),\n        keccak256(abi.encode(original.tokenAmounts)),\n        keccak256(original.extraArgs)\n      )\n    );\n  }\n\n  /// @dev We disallow the first 1024 addresses to avoid calling into a range known for hosting precompiles. Calling\n  /// into precompiles probably won't cause any issues, but to be safe we can disallow this range. It is extremely\n  /// unlikely that anyone would ever be able to generate an address in this range. There is no official range of\n  /// precompiles, but EIP-7587 proposes to reserve the range 0x100 to 0x1ff. Our range is more conservative, even\n  /// though it might not be exhaustive for all chains, which is OK. We also disallow the zero address, which is a\n  /// common practice.\n  uint256 public constant PRECOMPILE_SPACE = 1024;\n\n  /// @notice This methods provides validation for parsing abi encoded addresses by ensuring the\n  /// address is within the EVM address space. If it isn't it will revert with an InvalidEVMAddress error, which\n  /// we can catch and handle more gracefully than a revert from abi.decode.\n  /// @return The address if it is valid, the function will revert otherwise.\n  function _validateEVMAddress(\n    bytes memory encodedAddress\n  ) internal pure returns (address) {\n    if (encodedAddress.length != 32) revert InvalidEVMAddress(encodedAddress);\n    uint256 encodedAddressUint = abi.decode(encodedAddress, (uint256));\n    if (encodedAddressUint > type(uint160).max || encodedAddressUint < PRECOMPILE_SPACE) {\n      revert InvalidEVMAddress(encodedAddress);\n    }\n    return address(uint160(encodedAddressUint));\n  }\n\n  /// @notice Enum listing the possible message execution states within\n  /// the offRamp contract.\n  /// UNTOUCHED never executed\n  /// IN_PROGRESS currently being executed, used a replay protection\n  /// SUCCESS successfully executed. End state\n  /// FAILURE unsuccessfully executed, manual execution is now enabled.\n  /// @dev RMN depends on this enum, if changing, please notify the RMN maintainers.\n  enum MessageExecutionState {\n    UNTOUCHED,\n    IN_PROGRESS,\n    SUCCESS,\n    FAILURE\n  }\n\n  /// @notice CCIP OCR plugin type, used to separate execution & commit transmissions and configs\n  enum OCRPluginType {\n    Commit,\n    Execution\n  }\n\n  /// @notice Family-agnostic header for OnRamp & OffRamp messages.\n  /// The messageId is not expected to match hash(message), since it may originate from another ramp family\n  struct RampMessageHeader {\n    bytes32 messageId; // Unique identifier for the message, generated with the source chain's encoding scheme (i.e. not necessarily abi.encoded)\n    uint64 sourceChainSelector; // ──╮ the chain selector of the source chain, note: not chainId\n    uint64 destChainSelector; //     | the chain selector of the destination chain, note: not chainId\n    uint64 sequenceNumber; //        │ sequence number, not unique across lanes\n    uint64 nonce; // ────────────────╯ nonce for this lane for this sender, not unique across senders/lanes\n  }\n\n  struct EVM2AnyTokenTransfer {\n    // The source pool EVM address. This value is trusted as it was obtained through the onRamp. It can be\n    // relied upon by the destination pool to validate the source pool.\n    address sourcePoolAddress;\n    // The EVM address of the destination token\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes extraData;\n    uint256 amount; // Amount of tokens.\n    // Destination chain specific execution data encoded in bytes\n    // for an EVM destination, it consists of the amount of gas available for the releaseOrMint\n    // and transfer calls made by the offRamp\n    bytes destExecData;\n  }\n\n  struct Any2EVMTokenTransfer {\n    // The source pool EVM address encoded to bytes. This value is trusted as it is obtained through the onRamp. It can be\n    // relied upon by the destination pool to validate the source pool.\n    bytes sourcePoolAddress;\n    address destTokenAddress; // ───╮ Address of destination token\n    uint32 destGasAmount; //────────╯ The amount of gas available for the releaseOrMint and transfer calls on the offRamp.\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes extraData;\n    uint256 amount; // Amount of tokens.\n  }\n\n  /// @notice Family-agnostic message routed to an OffRamp\n  /// Note: hash(Any2EVMRampMessage) != hash(EVM2AnyRampMessage), hash(Any2EVMRampMessage) != messageId\n  /// due to encoding & parameter differences\n  struct Any2EVMRampMessage {\n    RampMessageHeader header; // Message header\n    bytes sender; // sender address on the source chain\n    bytes data; // arbitrary data payload supplied by the message sender\n    address receiver; // receiver address on the destination chain\n    uint256 gasLimit; // user supplied maximum gas amount available for dest chain execution\n    Any2EVMTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer\n  }\n\n  /// @notice Family-agnostic message emitted from the OnRamp\n  /// Note: hash(Any2EVMRampMessage) != hash(EVM2AnyRampMessage) due to encoding & parameter differences\n  /// messageId = hash(EVM2AnyRampMessage) using the source EVM chain's encoding format\n  struct EVM2AnyRampMessage {\n    RampMessageHeader header; // Message header\n    address sender; // sender address on the source chain\n    bytes data; // arbitrary data payload supplied by the message sender\n    bytes receiver; // receiver address on the destination chain\n    bytes extraArgs; // destination-chain specific extra args, such as the gasLimit for EVM chains\n    address feeToken; // fee token\n    uint256 feeTokenAmount; // fee token amount\n    uint256 feeValueJuels; // fee amount in Juels\n    EVM2AnyTokenTransfer[] tokenAmounts; // array of tokens and amounts to transfer\n  }\n\n  // bytes4(keccak256(\"CCIP ChainFamilySelector EVM\"))\n  bytes4 public constant CHAIN_FAMILY_SELECTOR_EVM = 0x2812d52c;\n\n  /// @dev Struct to hold a merkle root and an interval for a source chain so that an array of these can be passed in the CommitReport.\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  /// @dev ineffiecient struct packing intentionally chosen to maintain order of specificity. Not a storage struct so impact is minimal.\n  // solhint-disable-next-line gas-struct-packing\n  struct MerkleRoot {\n    uint64 sourceChainSelector; //     Remote source chain selector that the Merkle Root is scoped to\n    bytes onRampAddress; //            Generic onramp address, to support arbitrary sources; for EVM, use abi.encode\n    uint64 minSeqNr; // ─────────────╮ Minimum sequence number, inclusive\n    uint64 maxSeqNr; // ─────────────╯ Maximum sequence number, inclusive\n    bytes32 merkleRoot; //             Merkle root covering the interval & source chain messages\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/MerkleMultiProof.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\nlibrary MerkleMultiProof {\n  /// @notice Leaf domain separator, should be used as the first 32 bytes of a leaf's preimage.\n  bytes32 internal constant LEAF_DOMAIN_SEPARATOR = 0x0000000000000000000000000000000000000000000000000000000000000000;\n  /// @notice Internal domain separator, should be used as the first 32 bytes of an internal node's preiimage.\n  bytes32 internal constant INTERNAL_DOMAIN_SEPARATOR =\n    0x0000000000000000000000000000000000000000000000000000000000000001;\n\n  uint256 internal constant MAX_NUM_HASHES = 256;\n\n  error InvalidProof();\n  error LeavesCannotBeEmpty();\n\n  /// @notice Computes the root based on provided pre-hashed leaf nodes in\n  /// leaves, internal nodes in proofs, and using proofFlagBits' i-th bit to\n  /// determine if an element of proofs or one of the previously computed leafs\n  /// or internal nodes will be used for the i-th hash.\n  /// @param leaves Should be pre-hashed and the first 32 bytes of a leaf's\n  /// preimage should match LEAF_DOMAIN_SEPARATOR.\n  /// @param proofs The hashes to be used instead of a leaf hash when the proofFlagBits\n  ///  indicates a proof should be used.\n  /// @param proofFlagBits A single uint256 of which each bit indicates whether a leaf or\n  ///  a proof needs to be used in a hash operation.\n  /// @dev the maximum number of hash operations it set to 256. Any input that would require\n  ///  more than 256 hashes to get to a root will revert.\n  /// @dev For given input `leaves` = [a,b,c] `proofs` = [D] and `proofFlagBits` = 5\n  ///     totalHashes = 3 + 1 - 1 = 3\n  ///  ** round 1 **\n  ///    proofFlagBits = (5 >> 0) & 1 = true\n  ///    hashes[0] = hashPair(a, b)\n  ///    (leafPos, hashPos, proofPos) = (2, 0, 0);\n  ///\n  ///  ** round 2 **\n  ///    proofFlagBits = (5 >> 1) & 1 = false\n  ///    hashes[1] = hashPair(D, c)\n  ///    (leafPos, hashPos, proofPos) = (3, 0, 1);\n  ///\n  ///  ** round 3 **\n  ///    proofFlagBits = (5 >> 2) & 1 = true\n  ///    hashes[2] = hashPair(hashes[0], hashes[1])\n  ///    (leafPos, hashPos, proofPos) = (3, 2, 1);\n  ///\n  ///    i = 3 and no longer < totalHashes. The algorithm is done\n  ///    return hashes[totalHashes - 1] = hashes[2]; the last hash we computed.\n  // We mark this function as internal to force it to be inlined in contracts\n  // that use it, but semantically it is public.\n  // solhint-disable-next-line chainlink-solidity/prefix-internal-functions-with-underscore\n  function merkleRoot(\n    bytes32[] memory leaves,\n    bytes32[] memory proofs,\n    uint256 proofFlagBits\n  ) internal pure returns (bytes32) {\n    unchecked {\n      uint256 leavesLen = leaves.length;\n      uint256 proofsLen = proofs.length;\n      if (leavesLen == 0) revert LeavesCannotBeEmpty();\n      if (!(leavesLen <= MAX_NUM_HASHES + 1 && proofsLen <= MAX_NUM_HASHES + 1)) revert InvalidProof();\n      uint256 totalHashes = leavesLen + proofsLen - 1;\n      if (!(totalHashes <= MAX_NUM_HASHES)) revert InvalidProof();\n      if (totalHashes == 0) {\n        return leaves[0];\n      }\n      bytes32[] memory hashes = new bytes32[](totalHashes);\n      (uint256 leafPos, uint256 hashPos, uint256 proofPos) = (0, 0, 0);\n\n      for (uint256 i = 0; i < totalHashes; ++i) {\n        // Checks if the bit flag signals the use of a supplied proof or a leaf/previous hash.\n        bytes32 a;\n        if (proofFlagBits & (1 << i) == (1 << i)) {\n          // Use a leaf or a previously computed hash.\n          if (leafPos < leavesLen) {\n            a = leaves[leafPos++];\n          } else {\n            a = hashes[hashPos++];\n          }\n        } else {\n          // Use a supplied proof.\n          a = proofs[proofPos++];\n        }\n\n        // The second part of the hashed pair is never a proof as hashing two proofs would result in a\n        // hash that can already be computed offchain.\n        bytes32 b;\n        if (leafPos < leavesLen) {\n          b = leaves[leafPos++];\n        } else {\n          b = hashes[hashPos++];\n        }\n\n        if (!(hashPos <= i)) revert InvalidProof();\n\n        hashes[i] = _hashPair(a, b);\n      }\n      if (!(hashPos == totalHashes - 1 && leafPos == leavesLen && proofPos == proofsLen)) revert InvalidProof();\n      // Return the last hash.\n      return hashes[totalHashes - 1];\n    }\n  }\n\n  /// @notice Hashes two bytes32 objects in their given order, prepended by the\n  /// INTERNAL_DOMAIN_SEPARATOR.\n  function _hashInternalNode(bytes32 left, bytes32 right) private pure returns (bytes32 hash) {\n    return keccak256(abi.encode(INTERNAL_DOMAIN_SEPARATOR, left, right));\n  }\n\n  /// @notice Hashes two bytes32 objects. The order is taken into account,\n  /// using the lower value first.\n  function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n    return a < b ? _hashInternalNode(a, b) : _hashInternalNode(b, a);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice This library contains various token pool functions to aid constructing the return data.\nlibrary Pool {\n  // The tag used to signal support for the pool v1 standard\n  // bytes4(keccak256(\"CCIP_POOL_V1\"))\n  bytes4 public constant CCIP_POOL_V1 = 0xaff2afbf;\n\n  // The number of bytes in the return data for a pool v1 releaseOrMint call.\n  // This should match the size of the ReleaseOrMintOutV1 struct.\n  uint16 public constant CCIP_POOL_V1_RET_BYTES = 32;\n\n  // The default max number of bytes in the return data for a pool v1 lockOrBurn call.\n  // This data can be used to send information to the destination chain token pool. Can be overwritten\n  // in the TokenTransferFeeConfig.destBytesOverhead if more data is required.\n  uint32 public constant CCIP_LOCK_OR_BURN_V1_RET_BYTES = 32;\n\n  struct LockOrBurnInV1 {\n    bytes receiver; //  The recipient of the tokens on the destination chain, abi encoded\n    uint64 remoteChainSelector; // ─╮ The chain ID of the destination chain\n    address originalSender; // ─────╯ The original sender of the tx on the source chain\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals\n    address localToken; //  The address on this chain of the token to lock or burn\n  }\n\n  struct LockOrBurnOutV1 {\n    // The address of the destination token, abi encoded in the case of EVM chains\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes destPoolData;\n  }\n\n  struct ReleaseOrMintInV1 {\n    bytes originalSender; //          The original sender of the tx on the source chain\n    uint64 remoteChainSelector; // ─╮ The chain ID of the source chain\n    address receiver; // ───────────╯ The recipient of the tokens on the destination chain.\n    uint256 amount; //                The amount of tokens to release or mint, denominated in the source token's decimals\n    address localToken; //            The address on this chain of the token to release or mint\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\n    /// expected pool address for the given remoteChainSelector.\n    bytes sourcePoolAddress; //       The address of the source pool, abi encoded in the case of EVM chains\n    bytes sourcePoolData; //          The data received from the source pool to process the release or mint\n    /// @dev WARNING: offchainTokenData is untrusted data.\n    bytes offchainTokenData; //       The offchain data to process the release or mint\n  }\n\n  struct ReleaseOrMintOutV1 {\n    // The number of tokens released or minted on the destination chain, denominated in the local token's decimals.\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\n    // chain have the same number of decimals.\n    uint256 destinationAmount;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/// @notice Implements Token Bucket rate limiting.\n/// @dev uint128 is safe for rate limiter state.\n/// For USD value rate limiting, it can adequately store USD value in 18 decimals.\n/// For ERC20 token amount rate limiting, all tokens that will be listed will have at most\n/// a supply of uint128.max tokens, and it will therefore not overflow the bucket.\n/// In exceptional scenarios where tokens consumed may be larger than uint128,\n/// e.g. compromised issuer, an enabled RateLimiter will check and revert.\nlibrary RateLimiter {\n  error BucketOverfilled();\n  error OnlyCallableByAdminOrOwner();\n  error TokenMaxCapacityExceeded(uint256 capacity, uint256 requested, address tokenAddress);\n  error TokenRateLimitReached(uint256 minWaitInSeconds, uint256 available, address tokenAddress);\n  error AggregateValueMaxCapacityExceeded(uint256 capacity, uint256 requested);\n  error AggregateValueRateLimitReached(uint256 minWaitInSeconds, uint256 available);\n  error InvalidRateLimitRate(Config rateLimiterConfig);\n  error DisabledNonZeroRateLimit(Config config);\n  error RateLimitMustBeDisabled();\n\n  event TokensConsumed(uint256 tokens);\n  event ConfigChanged(Config config);\n\n  struct TokenBucket {\n    uint128 tokens; // ──────╮ Current number of tokens that are in the bucket.\n    uint32 lastUpdated; //   │ Timestamp in seconds of the last token refill, good for 100+ years.\n    bool isEnabled; // ──────╯ Indication whether the rate limiting is enabled or not\n    uint128 capacity; // ────╮ Maximum number of tokens that can be in the bucket.\n    uint128 rate; // ────────╯ Number of tokens per second that the bucket is refilled.\n  }\n\n  struct Config {\n    bool isEnabled; // Indication whether the rate limiting should be enabled\n    uint128 capacity; // ────╮ Specifies the capacity of the rate limiter\n    uint128 rate; //  ───────╯ Specifies the rate of the rate limiter\n  }\n\n  /// @notice _consume removes the given tokens from the pool, lowering the\n  /// rate tokens allowed to be consumed for subsequent calls.\n  /// @param requestTokens The total tokens to be consumed from the bucket.\n  /// @param tokenAddress The token to consume capacity for, use 0x0 to indicate aggregate value capacity.\n  /// @dev Reverts when requestTokens exceeds bucket capacity or available tokens in the bucket\n  /// @dev emits removal of requestTokens if requestTokens is > 0\n  function _consume(TokenBucket storage s_bucket, uint256 requestTokens, address tokenAddress) internal {\n    // If there is no value to remove or rate limiting is turned off, skip this step to reduce gas usage\n    if (!s_bucket.isEnabled || requestTokens == 0) {\n      return;\n    }\n\n    uint256 tokens = s_bucket.tokens;\n    uint256 capacity = s_bucket.capacity;\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\n\n    if (timeDiff != 0) {\n      if (tokens > capacity) revert BucketOverfilled();\n\n      // Refill tokens when arriving at a new block time\n      tokens = _calculateRefill(capacity, tokens, timeDiff, s_bucket.rate);\n\n      s_bucket.lastUpdated = uint32(block.timestamp);\n    }\n\n    if (capacity < requestTokens) {\n      // Token address 0 indicates consuming aggregate value rate limit capacity.\n      if (tokenAddress == address(0)) revert AggregateValueMaxCapacityExceeded(capacity, requestTokens);\n      revert TokenMaxCapacityExceeded(capacity, requestTokens, tokenAddress);\n    }\n    if (tokens < requestTokens) {\n      uint256 rate = s_bucket.rate;\n      // Wait required until the bucket is refilled enough to accept this value, round up to next higher second\n      // Consume is not guaranteed to succeed after wait time passes if there is competing traffic.\n      // This acts as a lower bound of wait time.\n      uint256 minWaitInSeconds = ((requestTokens - tokens) + (rate - 1)) / rate;\n\n      if (tokenAddress == address(0)) revert AggregateValueRateLimitReached(minWaitInSeconds, tokens);\n      revert TokenRateLimitReached(minWaitInSeconds, tokens, tokenAddress);\n    }\n    tokens -= requestTokens;\n\n    // Downcast is safe here, as tokens is not larger than capacity\n    s_bucket.tokens = uint128(tokens);\n    emit TokensConsumed(requestTokens);\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function _currentTokenBucketState(\n    TokenBucket memory bucket\n  ) internal view returns (TokenBucket memory) {\n    // We update the bucket to reflect the status at the exact time of the\n    // call. This means we might need to refill a part of the bucket based\n    // on the time that has passed since the last update.\n    bucket.tokens =\n      uint128(_calculateRefill(bucket.capacity, bucket.tokens, block.timestamp - bucket.lastUpdated, bucket.rate));\n    bucket.lastUpdated = uint32(block.timestamp);\n    return bucket;\n  }\n\n  /// @notice Sets the rate limited config.\n  /// @param s_bucket The token bucket\n  /// @param config The new config\n  function _setTokenBucketConfig(TokenBucket storage s_bucket, Config memory config) internal {\n    // First update the bucket to make sure the proper rate is used for all the time\n    // up until the config change.\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\n    if (timeDiff != 0) {\n      s_bucket.tokens = uint128(_calculateRefill(s_bucket.capacity, s_bucket.tokens, timeDiff, s_bucket.rate));\n\n      s_bucket.lastUpdated = uint32(block.timestamp);\n    }\n\n    s_bucket.tokens = uint128(_min(config.capacity, s_bucket.tokens));\n    s_bucket.isEnabled = config.isEnabled;\n    s_bucket.capacity = config.capacity;\n    s_bucket.rate = config.rate;\n\n    emit ConfigChanged(config);\n  }\n\n  /// @notice Validates the token bucket config\n  function _validateTokenBucketConfig(Config memory config, bool mustBeDisabled) internal pure {\n    if (config.isEnabled) {\n      if (config.rate >= config.capacity || config.rate == 0) {\n        revert InvalidRateLimitRate(config);\n      }\n      if (mustBeDisabled) {\n        revert RateLimitMustBeDisabled();\n      }\n    } else {\n      if (config.rate != 0 || config.capacity != 0) {\n        revert DisabledNonZeroRateLimit(config);\n      }\n    }\n  }\n\n  /// @notice Calculate refilled tokens\n  /// @param capacity bucket capacity\n  /// @param tokens current bucket tokens\n  /// @param timeDiff block time difference since last refill\n  /// @param rate bucket refill rate\n  /// @return the value of tokens after refill\n  function _calculateRefill(\n    uint256 capacity,\n    uint256 tokens,\n    uint256 timeDiff,\n    uint256 rate\n  ) private pure returns (uint256) {\n    return _min(capacity, tokens + timeDiff * rate);\n  }\n\n  /// @notice Return the smallest of two integers\n  /// @param a first int\n  /// @param b second int\n  /// @return smallest\n  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/pools/BurnMintTokenPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {ITypeAndVersion} from \"../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IBurnMintERC20} from \"../../shared/token/ERC20/IBurnMintERC20.sol\";\n\nimport {BurnMintTokenPoolAbstract} from \"./BurnMintTokenPoolAbstract.sol\";\nimport {TokenPool} from \"./TokenPool.sol\";\n\n/// @notice This pool mints and burns a 3rd-party token.\n/// @dev Pool whitelisting mode is set in the constructor and cannot be modified later.\n/// It either accepts any address as originalSender, or only accepts whitelisted originalSender.\n/// The only way to change whitelisting mode is to deploy a new pool.\n/// If that is expected, please make sure the token's burner/minter roles are adjustable.\n/// @dev This contract is a variant of BurnMintTokenPool that uses `burn(amount)`.\ncontract BurnMintTokenPool is BurnMintTokenPoolAbstract, ITypeAndVersion {\n  string public constant override typeAndVersion = \"BurnMintTokenPool 1.5.1\";\n\n  constructor(\n    IBurnMintERC20 token,\n    uint8 localTokenDecimals,\n    address[] memory allowlist,\n    address rmnProxy,\n    address router\n  ) TokenPool(token, localTokenDecimals, allowlist, rmnProxy, router) {}\n\n  /// @inheritdoc BurnMintTokenPoolAbstract\n  function _burn(\n    uint256 amount\n  ) internal virtual override {\n    IBurnMintERC20(address(i_token)).burn(amount);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/pools/BurnMintTokenPoolAbstract.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {IBurnMintERC20} from \"../../shared/token/ERC20/IBurnMintERC20.sol\";\n\nimport {Pool} from \"../libraries/Pool.sol\";\nimport {TokenPool} from \"./TokenPool.sol\";\n\nabstract contract BurnMintTokenPoolAbstract is TokenPool {\n  /// @notice Contains the specific burn call for a pool.\n  /// @dev overriding this method allows us to create pools with different burn signatures\n  /// without duplicating the underlying logic.\n  function _burn(\n    uint256 amount\n  ) internal virtual;\n\n  /// @notice Burn the token in the pool\n  /// @dev The _validateLockOrBurn check is an essential security check\n  function lockOrBurn(\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\n  ) external virtual override returns (Pool.LockOrBurnOutV1 memory) {\n    _validateLockOrBurn(lockOrBurnIn);\n\n    _burn(lockOrBurnIn.amount);\n\n    emit Burned(msg.sender, lockOrBurnIn.amount);\n\n    return Pool.LockOrBurnOutV1({\n      destTokenAddress: getRemoteToken(lockOrBurnIn.remoteChainSelector),\n      destPoolData: _encodeLocalDecimals()\n    });\n  }\n\n  /// @notice Mint tokens from the pool to the recipient\n  /// @dev The _validateReleaseOrMint check is an essential security check\n  function releaseOrMint(\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\n  ) external virtual override returns (Pool.ReleaseOrMintOutV1 memory) {\n    _validateReleaseOrMint(releaseOrMintIn);\n\n    // Calculate the local amount\n    uint256 localAmount =\n      _calculateLocalAmount(releaseOrMintIn.amount, _parseRemoteDecimals(releaseOrMintIn.sourcePoolData));\n\n    // Mint to the receiver\n    IBurnMintERC20(address(i_token)).mint(releaseOrMintIn.receiver, localAmount);\n\n    emit Minted(msg.sender, releaseOrMintIn.receiver, localAmount);\n\n    return Pool.ReleaseOrMintOutV1({destinationAmount: localAmount});\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/pools/TokenPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {IPoolV1} from \"../interfaces/IPool.sol\";\nimport {IRMN} from \"../interfaces/IRMN.sol\";\nimport {IRouter} from \"../interfaces/IRouter.sol\";\n\nimport {Ownable2StepMsgSender} from \"../../shared/access/Ownable2StepMsgSender.sol\";\nimport {Pool} from \"../libraries/Pool.sol\";\nimport {RateLimiter} from \"../libraries/RateLimiter.sol\";\n\nimport {IERC20} from \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from\n  \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @dev This pool supports different decimals on different chains but using this feature could impact the total number\n/// of tokens in circulation. Since all of the tokens are locked/burned on the source, and a rounded amount is minted/released on the\n/// destination, the number of tokens minted/released could be less than the number of tokens burned/locked. This is because the source\n/// chain does not know about the destination token decimals. This is not a problem if the decimals are the same on both\n/// chains.\n///\n/// Example:\n/// Assume there is a token with 6 decimals on chain A and 3 decimals on chain B.\n/// - 1.234567 tokens are burned on chain A.\n/// - 1.234    tokens are minted on chain B.\n/// When sending the 1.234 tokens back to chain A, you will receive 1.234000 tokens on chain A, effectively losing\n/// 0.000567 tokens.\n/// In the case of a burnMint pool on chain A, these funds are burned in the pool on chain A.\n/// In the case of a lockRelease pool on chain A, these funds accumulate in the pool on chain A.\nabstract contract TokenPool is IPoolV1, Ownable2StepMsgSender {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using RateLimiter for RateLimiter.TokenBucket;\n\n  error CallerIsNotARampOnRouter(address caller);\n  error ZeroAddressNotAllowed();\n  error SenderNotAllowed(address sender);\n  error AllowListNotEnabled();\n  error NonExistentChain(uint64 remoteChainSelector);\n  error ChainNotAllowed(uint64 remoteChainSelector);\n  error CursedByRMN();\n  error ChainAlreadyExists(uint64 chainSelector);\n  error InvalidSourcePoolAddress(bytes sourcePoolAddress);\n  error InvalidToken(address token);\n  error Unauthorized(address caller);\n  error PoolAlreadyAdded(uint64 remoteChainSelector, bytes remotePoolAddress);\n  error InvalidRemotePoolForChain(uint64 remoteChainSelector, bytes remotePoolAddress);\n  error InvalidRemoteChainDecimals(bytes sourcePoolData);\n  error MismatchedArrayLengths();\n  error OverflowDetected(uint8 remoteDecimals, uint8 localDecimals, uint256 remoteAmount);\n  error InvalidDecimalArgs(uint8 expected, uint8 actual);\n\n  event Locked(address indexed sender, uint256 amount);\n  event Burned(address indexed sender, uint256 amount);\n  event Released(address indexed sender, address indexed recipient, uint256 amount);\n  event Minted(address indexed sender, address indexed recipient, uint256 amount);\n  event ChainAdded(\n    uint64 remoteChainSelector,\n    bytes remoteToken,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n  event ChainConfigured(\n    uint64 remoteChainSelector,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n  event ChainRemoved(uint64 remoteChainSelector);\n  event RemotePoolAdded(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\n  event RemotePoolRemoved(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\n  event AllowListAdd(address sender);\n  event AllowListRemove(address sender);\n  event RouterUpdated(address oldRouter, address newRouter);\n  event RateLimitAdminSet(address rateLimitAdmin);\n\n  struct ChainUpdate {\n    uint64 remoteChainSelector; // Remote chain selector\n    bytes[] remotePoolAddresses; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateLimiter.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    EnumerableSet.Bytes32Set remotePools; // Set of remote pool hashes, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that is managed by this pool. Pools could support multiple tokens at the same time if\n  /// required, but this implementation only supports one token.\n  IERC20 internal immutable i_token;\n  /// @dev The number of decimals of the token managed by this pool.\n  uint8 internal immutable i_tokenDecimals;\n  /// @dev The address of the RMN proxy\n  address internal immutable i_rmnProxy;\n  /// @dev The immutable flag that indicates if the pool is access-controlled.\n  bool internal immutable i_allowlistEnabled;\n  /// @dev A set of addresses allowed to trigger lockOrBurn as original senders.\n  /// Only takes effect if i_allowlistEnabled is true.\n  /// This can be used to ensure only token-issuer specified addresses can move tokens.\n  EnumerableSet.AddressSet internal s_allowlist;\n  /// @dev The address of the router\n  IRouter internal s_router;\n  /// @dev A set of allowed chain selectors. We want the allowlist to be enumerable to\n  /// be able to quickly determine (without parsing logs) who can access the pool.\n  /// @dev The chain selectors are in uint256 format because of the EnumerableSet implementation.\n  EnumerableSet.UintSet internal s_remoteChainSelectors;\n  mapping(uint64 remoteChainSelector => RemoteChainConfig) internal s_remoteChainConfigs;\n  /// @notice A mapping of hashed pool addresses to their unhashed form. This is used to be able to find the actually\n  /// configured pools and not just their hashed versions.\n  mapping(bytes32 poolAddressHash => bytes poolAddress) internal s_remotePoolAddresses;\n  /// @notice The address of the rate limiter admin.\n  /// @dev Can be address(0) if none is configured.\n  address internal s_rateLimitAdmin;\n\n  constructor(IERC20 token, uint8 localTokenDecimals, address[] memory allowlist, address rmnProxy, address router) {\n    if (address(token) == address(0) || router == address(0) || rmnProxy == address(0)) revert ZeroAddressNotAllowed();\n    i_token = token;\n    i_rmnProxy = rmnProxy;\n\n    try IERC20Metadata(address(token)).decimals() returns (uint8 actualTokenDecimals) {\n      if (localTokenDecimals != actualTokenDecimals) {\n        revert InvalidDecimalArgs(localTokenDecimals, actualTokenDecimals);\n      }\n    } catch {\n      // The decimals function doesn't exist, which is possible since it's optional in the ERC20 spec. We skip the check and\n      // assume the supplied token decimals are correct.\n    }\n    i_tokenDecimals = localTokenDecimals;\n\n    s_router = IRouter(router);\n\n    // Pool can be set as permissioned or permissionless at deployment time only to save hot-path gas.\n    i_allowlistEnabled = allowlist.length > 0;\n    if (i_allowlistEnabled) {\n      _applyAllowListUpdates(new address[](0), allowlist);\n    }\n  }\n\n  /// @inheritdoc IPoolV1\n  function isSupportedToken(\n    address token\n  ) public view virtual returns (bool) {\n    return token == address(i_token);\n  }\n\n  /// @notice Gets the IERC20 token that this pool can lock or burn.\n  /// @return token The IERC20 token representation.\n  function getToken() public view returns (IERC20 token) {\n    return i_token;\n  }\n\n  /// @notice Get RMN proxy address\n  /// @return rmnProxy Address of RMN proxy\n  function getRmnProxy() public view returns (address rmnProxy) {\n    return i_rmnProxy;\n  }\n\n  /// @notice Gets the pool's Router\n  /// @return router The pool's Router\n  function getRouter() public view returns (address router) {\n    return address(s_router);\n  }\n\n  /// @notice Sets the pool's Router\n  /// @param newRouter The new Router\n  function setRouter(\n    address newRouter\n  ) public onlyOwner {\n    if (newRouter == address(0)) revert ZeroAddressNotAllowed();\n    address oldRouter = address(s_router);\n    s_router = IRouter(newRouter);\n\n    emit RouterUpdated(oldRouter, newRouter);\n  }\n\n  /// @notice Signals which version of the pool interface is supported\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public pure virtual override returns (bool) {\n    return interfaceId == Pool.CCIP_POOL_V1 || interfaceId == type(IPoolV1).interfaceId\n      || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // │                         Validation                           │\n  // ================================================================\n\n  /// @notice Validates the lock or burn input for correctness on\n  /// - token to be locked or burned\n  /// - RMN curse status\n  /// - allowlist status\n  /// - if the sender is a valid onRamp\n  /// - rate limit status\n  /// @param lockOrBurnIn The input to validate.\n  /// @dev This function should always be called before executing a lock or burn. Not doing so would allow\n  /// for various exploits.\n  function _validateLockOrBurn(\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\n  ) internal {\n    if (!isSupportedToken(lockOrBurnIn.localToken)) revert InvalidToken(lockOrBurnIn.localToken);\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(lockOrBurnIn.remoteChainSelector)))) revert CursedByRMN();\n    _checkAllowList(lockOrBurnIn.originalSender);\n\n    _onlyOnRamp(lockOrBurnIn.remoteChainSelector);\n    _consumeOutboundRateLimit(lockOrBurnIn.remoteChainSelector, lockOrBurnIn.amount);\n  }\n\n  /// @notice Validates the release or mint input for correctness on\n  /// - token to be released or minted\n  /// - RMN curse status\n  /// - if the sender is a valid offRamp\n  /// - if the source pool is valid\n  /// - rate limit status\n  /// @param releaseOrMintIn The input to validate.\n  /// @dev This function should always be called before executing a release or mint. Not doing so would allow\n  /// for various exploits.\n  function _validateReleaseOrMint(\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\n  ) internal {\n    if (!isSupportedToken(releaseOrMintIn.localToken)) revert InvalidToken(releaseOrMintIn.localToken);\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(releaseOrMintIn.remoteChainSelector)))) revert CursedByRMN();\n    _onlyOffRamp(releaseOrMintIn.remoteChainSelector);\n\n    // Validates that the source pool address is configured on this pool.\n    if (!isRemotePool(releaseOrMintIn.remoteChainSelector, releaseOrMintIn.sourcePoolAddress)) {\n      revert InvalidSourcePoolAddress(releaseOrMintIn.sourcePoolAddress);\n    }\n\n    _consumeInboundRateLimit(releaseOrMintIn.remoteChainSelector, releaseOrMintIn.amount);\n  }\n\n  // ================================================================\n  // │                      Token decimals                          │\n  // ================================================================\n\n  /// @notice Gets the IERC20 token decimals on the local chain.\n  function getTokenDecimals() public view virtual returns (uint8 decimals) {\n    return i_tokenDecimals;\n  }\n\n  function _encodeLocalDecimals() internal view virtual returns (bytes memory) {\n    return abi.encode(i_tokenDecimals);\n  }\n\n  function _parseRemoteDecimals(\n    bytes memory sourcePoolData\n  ) internal view virtual returns (uint8) {\n    // Fallback to the local token decimals if the source pool data is empty. This allows for backwards compatibility.\n    if (sourcePoolData.length == 0) {\n      return i_tokenDecimals;\n    }\n    if (sourcePoolData.length != 32) {\n      revert InvalidRemoteChainDecimals(sourcePoolData);\n    }\n    uint256 remoteDecimals = abi.decode(sourcePoolData, (uint256));\n    if (remoteDecimals > type(uint8).max) {\n      revert InvalidRemoteChainDecimals(sourcePoolData);\n    }\n    return uint8(remoteDecimals);\n  }\n\n  /// @notice Calculates the local amount based on the remote amount and decimals.\n  /// @param remoteAmount The amount on the remote chain.\n  /// @param remoteDecimals The decimals of the token on the remote chain.\n  /// @return The local amount.\n  /// @dev This function protects against overflows. If there is a transaction that hits the overflow check, it is\n  /// probably incorrect as that means the amount cannot be represented on this chain. If the local decimals have been\n  /// wrongly configured, the token issuer could redeploy the pool with the correct decimals and manually re-execute the\n  /// CCIP tx to fix the issue.\n  function _calculateLocalAmount(uint256 remoteAmount, uint8 remoteDecimals) internal view virtual returns (uint256) {\n    if (remoteDecimals == i_tokenDecimals) {\n      return remoteAmount;\n    }\n    if (remoteDecimals > i_tokenDecimals) {\n      uint8 decimalsDiff = remoteDecimals - i_tokenDecimals;\n      if (decimalsDiff > 77) {\n        // This is a safety check to prevent overflow in the next calculation.\n        revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\n      }\n      // Solidity rounds down so there is no risk of minting more tokens than the remote chain sent.\n      return remoteAmount / (10 ** decimalsDiff);\n    }\n\n    // This is a safety check to prevent overflow in the next calculation.\n    // More than 77 would never fit in a uint256 and would cause an overflow. We also check if the resulting amount\n    // would overflow.\n    uint8 diffDecimals = i_tokenDecimals - remoteDecimals;\n    if (diffDecimals > 77 || remoteAmount > type(uint256).max / (10 ** diffDecimals)) {\n      revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\n    }\n\n    return remoteAmount * (10 ** diffDecimals);\n  }\n\n  // ================================================================\n  // │                     Chain permissions                        │\n  // ================================================================\n\n  /// @notice Gets the pool address on the remote chain.\n  /// @param remoteChainSelector Remote chain selector.\n  /// @dev To support non-evm chains, this value is encoded into bytes\n  function getRemotePools(\n    uint64 remoteChainSelector\n  ) public view returns (bytes[] memory) {\n    bytes32[] memory remotePoolHashes = s_remoteChainConfigs[remoteChainSelector].remotePools.values();\n\n    bytes[] memory remotePools = new bytes[](remotePoolHashes.length);\n    for (uint256 i = 0; i < remotePoolHashes.length; ++i) {\n      remotePools[i] = s_remotePoolAddresses[remotePoolHashes[i]];\n    }\n\n    return remotePools;\n  }\n\n  /// @notice Checks if the pool address is configured on the remote chain.\n  /// @param remoteChainSelector Remote chain selector.\n  /// @param remotePoolAddress The address of the remote pool.\n  function isRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) public view returns (bool) {\n    return s_remoteChainConfigs[remoteChainSelector].remotePools.contains(keccak256(remotePoolAddress));\n  }\n\n  /// @notice Gets the token address on the remote chain.\n  /// @param remoteChainSelector Remote chain selector.\n  /// @dev To support non-evm chains, this value is encoded into bytes\n  function getRemoteToken(\n    uint64 remoteChainSelector\n  ) public view returns (bytes memory) {\n    return s_remoteChainConfigs[remoteChainSelector].remoteTokenAddress;\n  }\n\n  /// @notice Adds a remote pool for a given chain selector. This could be due to a pool being upgraded on the remote\n  /// chain. We don't simply want to replace the old pool as there could still be valid inflight messages from the old\n  /// pool. This function allows for multiple pools to be added for a single chain selector.\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\n  /// @param remotePoolAddress The address of the new remote pool.\n  function addRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external onlyOwner {\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\n\n    _setRemotePool(remoteChainSelector, remotePoolAddress);\n  }\n\n  /// @notice Removes the remote pool address for a given chain selector.\n  /// @dev All inflight txs from the remote pool will be rejected after it is removed. To ensure no loss of funds, there\n  /// should be no inflight txs from the given pool.\n  function removeRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external onlyOwner {\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\n\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.remove(keccak256(remotePoolAddress))) {\n      revert InvalidRemotePoolForChain(remoteChainSelector, remotePoolAddress);\n    }\n\n    emit RemotePoolRemoved(remoteChainSelector, remotePoolAddress);\n  }\n\n  /// @inheritdoc IPoolV1\n  function isSupportedChain(\n    uint64 remoteChainSelector\n  ) public view returns (bool) {\n    return s_remoteChainSelectors.contains(remoteChainSelector);\n  }\n\n  /// @notice Get list of allowed chains\n  /// @return list of chains.\n  function getSupportedChains() public view returns (uint64[] memory) {\n    uint256[] memory uint256ChainSelectors = s_remoteChainSelectors.values();\n    uint64[] memory chainSelectors = new uint64[](uint256ChainSelectors.length);\n    for (uint256 i = 0; i < uint256ChainSelectors.length; ++i) {\n      chainSelectors[i] = uint64(uint256ChainSelectors[i]);\n    }\n\n    return chainSelectors;\n  }\n\n  /// @notice Sets the permissions for a list of chains selectors. Actual senders for these chains\n  /// need to be allowed on the Router to interact with this pool.\n  /// @param remoteChainSelectorsToRemove A list of chain selectors to remove.\n  /// @param chainsToAdd A list of chains and their new permission status & rate limits. Rate limits\n  /// are only used when the chain is being added through `allowed` being true.\n  /// @dev Only callable by the owner\n  function applyChainUpdates(\n    uint64[] calldata remoteChainSelectorsToRemove,\n    ChainUpdate[] calldata chainsToAdd\n  ) external virtual onlyOwner {\n    for (uint256 i = 0; i < remoteChainSelectorsToRemove.length; ++i) {\n      uint64 remoteChainSelectorToRemove = remoteChainSelectorsToRemove[i];\n      // If the chain doesn't exist, revert\n      if (!s_remoteChainSelectors.remove(remoteChainSelectorToRemove)) {\n        revert NonExistentChain(remoteChainSelectorToRemove);\n      }\n\n      // Remove all remote pool hashes for the chain\n      bytes32[] memory remotePools = s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.values();\n      for (uint256 j = 0; j < remotePools.length; ++j) {\n        s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.remove(remotePools[j]);\n      }\n\n      delete s_remoteChainConfigs[remoteChainSelectorToRemove];\n\n      emit ChainRemoved(remoteChainSelectorToRemove);\n    }\n\n    for (uint256 i = 0; i < chainsToAdd.length; ++i) {\n      ChainUpdate memory newChain = chainsToAdd[i];\n      RateLimiter._validateTokenBucketConfig(newChain.outboundRateLimiterConfig, false);\n      RateLimiter._validateTokenBucketConfig(newChain.inboundRateLimiterConfig, false);\n\n      if (newChain.remoteTokenAddress.length == 0) {\n        revert ZeroAddressNotAllowed();\n      }\n\n      // If the chain already exists, revert\n      if (!s_remoteChainSelectors.add(newChain.remoteChainSelector)) {\n        revert ChainAlreadyExists(newChain.remoteChainSelector);\n      }\n\n      RemoteChainConfig storage remoteChainConfig = s_remoteChainConfigs[newChain.remoteChainSelector];\n\n      remoteChainConfig.outboundRateLimiterConfig = RateLimiter.TokenBucket({\n        rate: newChain.outboundRateLimiterConfig.rate,\n        capacity: newChain.outboundRateLimiterConfig.capacity,\n        tokens: newChain.outboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: newChain.outboundRateLimiterConfig.isEnabled\n      });\n      remoteChainConfig.inboundRateLimiterConfig = RateLimiter.TokenBucket({\n        rate: newChain.inboundRateLimiterConfig.rate,\n        capacity: newChain.inboundRateLimiterConfig.capacity,\n        tokens: newChain.inboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: newChain.inboundRateLimiterConfig.isEnabled\n      });\n      remoteChainConfig.remoteTokenAddress = newChain.remoteTokenAddress;\n\n      for (uint256 j = 0; j < newChain.remotePoolAddresses.length; ++j) {\n        _setRemotePool(newChain.remoteChainSelector, newChain.remotePoolAddresses[j]);\n      }\n\n      emit ChainAdded(\n        newChain.remoteChainSelector,\n        newChain.remoteTokenAddress,\n        newChain.outboundRateLimiterConfig,\n        newChain.inboundRateLimiterConfig\n      );\n    }\n  }\n\n  /// @notice Adds a pool address to the allowed remote token pools for a particular chain.\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\n  /// @param remotePoolAddress The address of the new remote pool.\n  function _setRemotePool(uint64 remoteChainSelector, bytes memory remotePoolAddress) internal {\n    if (remotePoolAddress.length == 0) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    bytes32 poolHash = keccak256(remotePoolAddress);\n\n    // Check if the pool already exists.\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.add(poolHash)) {\n      revert PoolAlreadyAdded(remoteChainSelector, remotePoolAddress);\n    }\n\n    // Add the pool to the mapping to be able to un-hash it later.\n    s_remotePoolAddresses[poolHash] = remotePoolAddress;\n\n    emit RemotePoolAdded(remoteChainSelector, remotePoolAddress);\n  }\n\n  // ================================================================\n  // │                        Rate limiting                         │\n  // ================================================================\n\n  /// @dev The inbound rate limits should be slightly higher than the outbound rate limits. This is because many chains\n  /// finalize blocks in batches. CCIP also commits messages in batches: the commit plugin bundles multiple messages in\n  /// a single merkle root.\n  /// Imagine the following scenario.\n  /// - Chain A has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\n  /// - Chain B has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\n  ///\n  /// At time 0:\n  /// - Chain A sends 100 tokens to Chain B.\n  /// At time 5:\n  /// - Chain A sends 5 tokens to Chain B.\n  /// At time 6:\n  /// The epoch that contains blocks [0-5] is finalized.\n  /// Both transactions will be included in the same merkle root and become executable at the same time. This means\n  /// the token pool on chain B requires a capacity of 105 to successfully execute both messages at the same time.\n  /// The exact additional capacity required depends on the refill rate and the size of the source chain epochs and the\n  /// CCIP round time. For simplicity, a 5-10% buffer should be sufficient in most cases.\n\n  /// @notice Sets the rate limiter admin address.\n  /// @dev Only callable by the owner.\n  /// @param rateLimitAdmin The new rate limiter admin address.\n  function setRateLimitAdmin(\n    address rateLimitAdmin\n  ) external onlyOwner {\n    s_rateLimitAdmin = rateLimitAdmin;\n    emit RateLimitAdminSet(rateLimitAdmin);\n  }\n\n  /// @notice Gets the rate limiter admin address.\n  function getRateLimitAdmin() external view returns (address) {\n    return s_rateLimitAdmin;\n  }\n\n  /// @notice Consumes outbound rate limiting capacity in this pool\n  function _consumeOutboundRateLimit(uint64 remoteChainSelector, uint256 amount) internal {\n    s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._consume(amount, address(i_token));\n  }\n\n  /// @notice Consumes inbound rate limiting capacity in this pool\n  function _consumeInboundRateLimit(uint64 remoteChainSelector, uint256 amount) internal {\n    s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._consume(amount, address(i_token));\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function getCurrentOutboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._currentTokenBucketState();\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function getCurrentInboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._currentTokenBucketState();\n  }\n\n  /// @notice Sets multiple chain rate limiter configs.\n  /// @param remoteChainSelectors The remote chain selector for which the rate limits apply.\n  /// @param outboundConfigs The new outbound rate limiter config, meaning the onRamp rate limits for the given chain.\n  /// @param inboundConfigs The new inbound rate limiter config, meaning the offRamp rate limits for the given chain.\n  function setChainRateLimiterConfigs(\n    uint64[] calldata remoteChainSelectors,\n    RateLimiter.Config[] calldata outboundConfigs,\n    RateLimiter.Config[] calldata inboundConfigs\n  ) external {\n    if (msg.sender != s_rateLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n    if (remoteChainSelectors.length != outboundConfigs.length || remoteChainSelectors.length != inboundConfigs.length) {\n      revert MismatchedArrayLengths();\n    }\n\n    for (uint256 i = 0; i < remoteChainSelectors.length; ++i) {\n      _setRateLimitConfig(remoteChainSelectors[i], outboundConfigs[i], inboundConfigs[i]);\n    }\n  }\n\n  /// @notice Sets the chain rate limiter config.\n  /// @param remoteChainSelector The remote chain selector for which the rate limits apply.\n  /// @param outboundConfig The new outbound rate limiter config, meaning the onRamp rate limits for the given chain.\n  /// @param inboundConfig The new inbound rate limiter config, meaning the offRamp rate limits for the given chain.\n  function setChainRateLimiterConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) external {\n    if (msg.sender != s_rateLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n\n    _setRateLimitConfig(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  function _setRateLimitConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) internal {\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\n    RateLimiter._validateTokenBucketConfig(outboundConfig, false);\n    s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._setTokenBucketConfig(outboundConfig);\n    RateLimiter._validateTokenBucketConfig(inboundConfig, false);\n    s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._setTokenBucketConfig(inboundConfig);\n    emit ChainConfigured(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  // ================================================================\n  // │                           Access                             │\n  // ================================================================\n\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\n  /// is a permissioned onRamp for the given chain on the Router.\n  function _onlyOnRamp(\n    uint64 remoteChainSelector\n  ) internal view {\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\n    if (!(msg.sender == s_router.getOnRamp(remoteChainSelector))) revert CallerIsNotARampOnRouter(msg.sender);\n  }\n\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\n  /// is a permissioned offRamp for the given chain on the Router.\n  function _onlyOffRamp(\n    uint64 remoteChainSelector\n  ) internal view {\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\n    if (!s_router.isOffRamp(remoteChainSelector, msg.sender)) revert CallerIsNotARampOnRouter(msg.sender);\n  }\n\n  // ================================================================\n  // │                          Allowlist                           │\n  // ================================================================\n\n  function _checkAllowList(\n    address sender\n  ) internal view {\n    if (i_allowlistEnabled) {\n      if (!s_allowlist.contains(sender)) {\n        revert SenderNotAllowed(sender);\n      }\n    }\n  }\n\n  /// @notice Gets whether the allowlist functionality is enabled.\n  /// @return true is enabled, false if not.\n  function getAllowListEnabled() external view returns (bool) {\n    return i_allowlistEnabled;\n  }\n\n  /// @notice Gets the allowed addresses.\n  /// @return The allowed addresses.\n  function getAllowList() external view returns (address[] memory) {\n    return s_allowlist.values();\n  }\n\n  /// @notice Apply updates to the allow list.\n  /// @param removes The addresses to be removed.\n  /// @param adds The addresses to be added.\n  function applyAllowListUpdates(address[] calldata removes, address[] calldata adds) external onlyOwner {\n    _applyAllowListUpdates(removes, adds);\n  }\n\n  /// @notice Internal version of applyAllowListUpdates to allow for reuse in the constructor.\n  function _applyAllowListUpdates(address[] memory removes, address[] memory adds) internal {\n    if (!i_allowlistEnabled) revert AllowListNotEnabled();\n\n    for (uint256 i = 0; i < removes.length; ++i) {\n      address toRemove = removes[i];\n      if (s_allowlist.remove(toRemove)) {\n        emit AllowListRemove(toRemove);\n      }\n    }\n    for (uint256 i = 0; i < adds.length; ++i) {\n      address toAdd = adds[i];\n      if (toAdd == address(0)) {\n        continue;\n      }\n      if (s_allowlist.add(toAdd)) {\n        emit AllowListAdd(toAdd);\n      }\n    }\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/test/mocks/MockRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IAny2EVMMessageReceiver} from \"../../interfaces/IAny2EVMMessageReceiver.sol\";\nimport {IRouter} from \"../../interfaces/IRouter.sol\";\nimport {IRouterClient} from \"../../interfaces/IRouterClient.sol\";\n\nimport {CallWithExactGas} from \"../../../shared/call/CallWithExactGas.sol\";\nimport {Client} from \"../../libraries/Client.sol\";\nimport {Internal} from \"../../libraries/Internal.sol\";\n\nimport {IERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {ERC165Checker} from\n  \"../../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/ERC165Checker.sol\";\n\ncontract MockCCIPRouter is IRouter, IRouterClient {\n  using SafeERC20 for IERC20;\n  using ERC165Checker for address;\n\n  error InvalidAddress(bytes encodedAddress);\n  error InvalidExtraArgsTag();\n  error ReceiverError(bytes err);\n\n  event MessageExecuted(bytes32 messageId, uint64 sourceChainSelector, address offRamp, bytes32 calldataHash);\n  event MsgExecuted(bool success, bytes retData, uint256 gasUsed);\n\n  uint16 public constant GAS_FOR_CALL_EXACT_CHECK = 5_000;\n  uint32 public constant DEFAULT_GAS_LIMIT = 200_000;\n\n  uint256 internal s_mockFeeTokenAmount; //use setFee() to change to non-zero to test fees\n\n  function routeMessage(\n    Client.Any2EVMMessage calldata message,\n    uint16 gasForCallExactCheck,\n    uint256 gasLimit,\n    address receiver\n  ) external returns (bool success, bytes memory retData, uint256 gasUsed) {\n    return _routeMessage(message, gasForCallExactCheck, gasLimit, receiver);\n  }\n\n  function _routeMessage(\n    Client.Any2EVMMessage memory message,\n    uint16 gasForCallExactCheck,\n    uint256 gasLimit,\n    address receiver\n  ) internal returns (bool success, bytes memory retData, uint256 gasUsed) {\n    // There are three cases in which we skip calling the receiver:\n    // 1. If the message data is empty AND the gas limit is 0.\n    //          This indicates a message that only transfers tokens. It is valid to only send tokens to a contract\n    //          that supports the IAny2EVMMessageReceiver interface, but without this first check we would call the\n    //          receiver without any gas, which would revert the transaction.\n    // 2. If the receiver is not a contract.\n    // 3. If the receiver is a contract but it does not support the IAny2EVMMessageReceiver interface.\n    //\n    // The ordering of these checks is important, as the first check is the cheapest to execute.\n    if (\n      (message.data.length == 0 && gasLimit == 0) || receiver.code.length == 0\n        || !receiver.supportsInterface(type(IAny2EVMMessageReceiver).interfaceId)\n    ) {\n      return (true, \"\", 0);\n    }\n\n    bytes memory data = abi.encodeWithSelector(IAny2EVMMessageReceiver.ccipReceive.selector, message);\n\n    (success, retData, gasUsed) = CallWithExactGas._callWithExactGasSafeReturnData(\n      data, receiver, gasLimit, gasForCallExactCheck, Internal.MAX_RET_BYTES\n    );\n\n    // Event to assist testing, does not exist on real deployments\n    emit MsgExecuted(success, retData, gasUsed);\n\n    // Real router event\n    emit MessageExecuted(message.messageId, message.sourceChainSelector, msg.sender, keccak256(data));\n    return (success, retData, gasUsed);\n  }\n\n  /// @notice Sends the tx locally to the receiver instead of on the destination chain.\n  /// @dev Ignores destinationChainSelector\n  /// @dev Returns a mock message ID, which is not calculated from the message contents in the\n  /// same way as the real message ID.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32) {\n    if (message.receiver.length != 32) revert InvalidAddress(message.receiver);\n    uint256 decodedReceiver = abi.decode(message.receiver, (uint256));\n    // We want to disallow sending to address(0) and to precompiles, which exist on address(1) through address(9).\n    if (decodedReceiver > type(uint160).max || decodedReceiver < 10) revert InvalidAddress(message.receiver);\n\n    uint256 feeTokenAmount = getFee(destinationChainSelector, message);\n    if (message.feeToken == address(0)) {\n      if (msg.value < feeTokenAmount) revert InsufficientFeeTokenAmount();\n    } else {\n      if (msg.value > 0) revert InvalidMsgValue();\n      IERC20(message.feeToken).safeTransferFrom(msg.sender, address(this), feeTokenAmount);\n    }\n\n    address receiver = address(uint160(decodedReceiver));\n    uint256 gasLimit = _fromBytes(message.extraArgs).gasLimit;\n    bytes32 mockMsgId = keccak256(abi.encode(message));\n\n    Client.Any2EVMMessage memory executableMsg = Client.Any2EVMMessage({\n      messageId: mockMsgId,\n      sourceChainSelector: 16015286601757825753, // Sepolia\n      sender: abi.encode(msg.sender),\n      data: message.data,\n      destTokenAmounts: message.tokenAmounts\n    });\n\n    for (uint256 i = 0; i < message.tokenAmounts.length; ++i) {\n      IERC20(message.tokenAmounts[i].token).safeTransferFrom(msg.sender, receiver, message.tokenAmounts[i].amount);\n    }\n\n    (bool success, bytes memory retData,) = _routeMessage(executableMsg, GAS_FOR_CALL_EXACT_CHECK, gasLimit, receiver);\n\n    if (!success) revert ReceiverError(retData);\n\n    return mockMsgId;\n  }\n\n  function _fromBytes(\n    bytes calldata extraArgs\n  ) internal pure returns (Client.EVMExtraArgsV2 memory) {\n    if (extraArgs.length == 0) {\n      return Client.EVMExtraArgsV2({gasLimit: DEFAULT_GAS_LIMIT, allowOutOfOrderExecution: false});\n    }\n\n    bytes4 extraArgsTag = bytes4(extraArgs);\n    if (extraArgsTag == Client.EVM_EXTRA_ARGS_V2_TAG) {\n      return abi.decode(extraArgs[4:], (Client.EVMExtraArgsV2));\n    } else if (extraArgsTag == Client.EVM_EXTRA_ARGS_V1_TAG) {\n      return Client.EVMExtraArgsV2({gasLimit: abi.decode(extraArgs[4:], (uint256)), allowOutOfOrderExecution: false});\n    }\n\n    revert InvalidExtraArgsTag();\n  }\n\n  /// @notice Always returns true to make sure this check can be performed on any chain.\n  function isChainSupported(\n    uint64\n  ) external pure returns (bool supported) {\n    return true;\n  }\n\n  /// @notice Returns an empty array.\n  function getSupportedTokens(\n    uint64\n  ) external pure returns (address[] memory tokens) {\n    return new address[](0);\n  }\n\n  /// @notice Returns 0 as the fee is not supported in this mock contract.\n  function getFee(uint64, Client.EVM2AnyMessage memory) public view returns (uint256) {\n    return s_mockFeeTokenAmount;\n  }\n\n  /// @notice Sets the fees returned by getFee but is only checked when using native fee tokens\n  function setFee(\n    uint256 feeAmount\n  ) external {\n    s_mockFeeTokenAmount = feeAmount;\n  }\n\n  /// @notice Always returns address(1234567890)\n  function getOnRamp(\n    uint64 /* destChainSelector */\n  ) external pure returns (address onRampAddress) {\n    return address(1234567890);\n  }\n\n  /// @notice Always returns true\n  function isOffRamp(uint64, /* sourceChainSelector */ address /* offRamp */ ) external pure returns (bool) {\n    return true;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/RegistryModuleOwnerCustom.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {ITypeAndVersion} from \"../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IGetCCIPAdmin} from \"../interfaces/IGetCCIPAdmin.sol\";\nimport {IOwner} from \"../interfaces/IOwner.sol\";\nimport {ITokenAdminRegistry} from \"../interfaces/ITokenAdminRegistry.sol\";\n\nimport {AccessControl} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/access/AccessControl.sol\";\n\ncontract RegistryModuleOwnerCustom is ITypeAndVersion {\n  error CanOnlySelfRegister(address admin, address token);\n  error RequiredRoleNotFound(address msgSender, bytes32 role, address token);\n  error AddressZero();\n\n  event AdministratorRegistered(address indexed token, address indexed administrator);\n\n  string public constant override typeAndVersion = \"RegistryModuleOwnerCustom 1.6.0\";\n\n  // The TokenAdminRegistry contract\n  ITokenAdminRegistry internal immutable i_tokenAdminRegistry;\n\n  constructor(\n    address tokenAdminRegistry\n  ) {\n    if (tokenAdminRegistry == address(0)) {\n      revert AddressZero();\n    }\n    i_tokenAdminRegistry = ITokenAdminRegistry(tokenAdminRegistry);\n  }\n\n  /// @notice Registers the admin of the token using the `getCCIPAdmin` method.\n  /// @param token The token to register the admin for.\n  /// @dev The caller must be the admin returned by the `getCCIPAdmin` method.\n  function registerAdminViaGetCCIPAdmin(\n    address token\n  ) external {\n    _registerAdmin(token, IGetCCIPAdmin(token).getCCIPAdmin());\n  }\n\n  /// @notice Registers the admin of the token using the `owner` method.\n  /// @param token The token to register the admin for.\n  /// @dev The caller must be the admin returned by the `owner` method.\n  function registerAdminViaOwner(\n    address token\n  ) external {\n    _registerAdmin(token, IOwner(token).owner());\n  }\n\n  /// @notice Registers the admin of the token using OZ's AccessControl DEFAULT_ADMIN_ROLE.\n  /// @param token The token to register the admin for.\n  /// @dev The caller must have the DEFAULT_ADMIN_ROLE as defined by the contract itself.\n  function registerAccessControlDefaultAdmin(\n    address token\n  ) external {\n    bytes32 defaultAdminRole = AccessControl(token).DEFAULT_ADMIN_ROLE();\n    if (!AccessControl(token).hasRole(defaultAdminRole, msg.sender)) {\n      revert RequiredRoleNotFound(msg.sender, defaultAdminRole, token);\n    }\n\n    _registerAdmin(token, msg.sender);\n  }\n\n  /// @notice Registers the admin of the token to msg.sender given that the\n  /// admin is equal to msg.sender.\n  /// @param token The token to register the admin for.\n  /// @param admin The caller must be the admin.\n  function _registerAdmin(address token, address admin) internal {\n    if (admin != msg.sender) {\n      revert CanOnlySelfRegister(admin, token);\n    }\n\n    i_tokenAdminRegistry.proposeAdministrator(token, admin);\n\n    emit AdministratorRegistered(token, admin);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/TokenAdminRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {ITypeAndVersion} from \"../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IPoolV1} from \"../interfaces/IPool.sol\";\nimport {ITokenAdminRegistry} from \"../interfaces/ITokenAdminRegistry.sol\";\n\nimport {OwnerIsCreator} from \"../../shared/access/OwnerIsCreator.sol\";\n\nimport {EnumerableSet} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @notice This contract stores the token pool configuration for all CCIP enabled tokens. It works\n/// on a self-serve basis, where tokens can be registered without intervention from the CCIP owner.\n/// @dev This contract is not considered upgradable, as it is a customer facing contract that will store\n/// significant amounts of data.\ncontract TokenAdminRegistry is ITokenAdminRegistry, ITypeAndVersion, OwnerIsCreator {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  error OnlyRegistryModuleOrOwner(address sender);\n  error OnlyAdministrator(address sender, address token);\n  error OnlyPendingAdministrator(address sender, address token);\n  error AlreadyRegistered(address token);\n  error ZeroAddress();\n  error InvalidTokenPoolToken(address token);\n\n  event PoolSet(address indexed token, address indexed previousPool, address indexed newPool);\n  event AdministratorTransferRequested(address indexed token, address indexed currentAdmin, address indexed newAdmin);\n  event AdministratorTransferred(address indexed token, address indexed newAdmin);\n  event RegistryModuleAdded(address module);\n  event RegistryModuleRemoved(address indexed module);\n\n  // The struct is packed in a way that optimizes the attributes that are accessed together.\n  // solhint-disable-next-line gas-struct-packing\n  struct TokenConfig {\n    address administrator; // the current administrator of the token\n    address pendingAdministrator; // the address that is pending to become the new administrator\n    address tokenPool; // the token pool for this token. Can be address(0) if not deployed or not configured.\n  }\n\n  string public constant override typeAndVersion = \"TokenAdminRegistry 1.5.0\";\n\n  // Mapping of token address to token configuration\n  mapping(address token => TokenConfig) internal s_tokenConfig;\n\n  // All tokens that have been configured\n  EnumerableSet.AddressSet internal s_tokens;\n\n  // Registry modules are allowed to register administrators for tokens\n  EnumerableSet.AddressSet internal s_registryModules;\n\n  /// @notice Returns all pools for the given tokens.\n  /// @dev Will return address(0) for tokens that do not have a pool.\n  function getPools(\n    address[] calldata tokens\n  ) external view returns (address[] memory) {\n    address[] memory pools = new address[](tokens.length);\n    for (uint256 i = 0; i < tokens.length; ++i) {\n      pools[i] = s_tokenConfig[tokens[i]].tokenPool;\n    }\n    return pools;\n  }\n\n  /// @inheritdoc ITokenAdminRegistry\n  function getPool(\n    address token\n  ) external view returns (address) {\n    return s_tokenConfig[token].tokenPool;\n  }\n\n  /// @notice Returns the configuration for a token.\n  /// @param token The token to get the configuration for.\n  /// @return config The configuration for the token.\n  function getTokenConfig(\n    address token\n  ) external view returns (TokenConfig memory) {\n    return s_tokenConfig[token];\n  }\n\n  /// @notice Returns a list of tokens that are configured in the token admin registry.\n  /// @param startIndex Starting index in list, can be 0 if you want to start from the beginning.\n  /// @param maxCount Maximum number of tokens to retrieve. Since the list can be large,\n  /// it is recommended to use a paging mechanism to retrieve all tokens. If querying for very\n  /// large lists, RPCs can time out. If you want all tokens, use type(uint64).max.\n  /// @return tokens List of configured tokens.\n  /// @dev The function is paginated to avoid RPC timeouts.\n  /// @dev The ordering is guaranteed to remain the same as it is not possible to remove tokens\n  /// from s_tokens.\n  function getAllConfiguredTokens(uint64 startIndex, uint64 maxCount) external view returns (address[] memory tokens) {\n    uint256 numberOfTokens = s_tokens.length();\n    if (startIndex >= numberOfTokens) {\n      return tokens;\n    }\n    uint256 count = maxCount;\n    if (count + startIndex > numberOfTokens) {\n      count = numberOfTokens - startIndex;\n    }\n    tokens = new address[](count);\n    for (uint256 i = 0; i < count; ++i) {\n      tokens[i] = s_tokens.at(startIndex + i);\n    }\n\n    return tokens;\n  }\n\n  // ================================================================\n  // │                  Administrator functions                     │\n  // ================================================================\n\n  /// @notice Sets the pool for a token. Setting the pool to address(0) effectively delists the token\n  /// from CCIP. Setting the pool to any other address enables the token on CCIP.\n  /// @param localToken The token to set the pool for.\n  /// @param pool The pool to set for the token.\n  function setPool(address localToken, address pool) external onlyTokenAdmin(localToken) {\n    // The pool has to support the token, but we want to allow removing the pool, so we only check\n    // if the pool supports the token if it is not address(0).\n    if (pool != address(0) && !IPoolV1(pool).isSupportedToken(localToken)) {\n      revert InvalidTokenPoolToken(localToken);\n    }\n\n    TokenConfig storage config = s_tokenConfig[localToken];\n\n    address previousPool = config.tokenPool;\n    config.tokenPool = pool;\n\n    if (previousPool != pool) {\n      emit PoolSet(localToken, previousPool, pool);\n    }\n  }\n\n  /// @notice Transfers the administrator role for a token to a new address with a 2-step process.\n  /// @param localToken The token to transfer the administrator role for.\n  /// @param newAdmin The address to transfer the administrator role to. Can be address(0) to cancel\n  /// a pending transfer.\n  /// @dev The new admin must call `acceptAdminRole` to accept the role.\n  function transferAdminRole(address localToken, address newAdmin) external onlyTokenAdmin(localToken) {\n    TokenConfig storage config = s_tokenConfig[localToken];\n    config.pendingAdministrator = newAdmin;\n\n    emit AdministratorTransferRequested(localToken, msg.sender, newAdmin);\n  }\n\n  /// @notice Accepts the administrator role for a token.\n  /// @param localToken The token to accept the administrator role for.\n  /// @dev This function can only be called by the pending administrator.\n  function acceptAdminRole(\n    address localToken\n  ) external {\n    TokenConfig storage config = s_tokenConfig[localToken];\n    if (config.pendingAdministrator != msg.sender) {\n      revert OnlyPendingAdministrator(msg.sender, localToken);\n    }\n\n    config.administrator = msg.sender;\n    config.pendingAdministrator = address(0);\n\n    emit AdministratorTransferred(localToken, msg.sender);\n  }\n\n  // ================================================================\n  // │                    Administrator config                      │\n  // ================================================================\n\n  /// @notice Public getter to check for permissions of an administrator\n  function isAdministrator(address localToken, address administrator) external view returns (bool) {\n    return s_tokenConfig[localToken].administrator == administrator;\n  }\n\n  /// @inheritdoc ITokenAdminRegistry\n  /// @dev Can only be called by a registry module.\n  function proposeAdministrator(address localToken, address administrator) external {\n    if (!isRegistryModule(msg.sender) && msg.sender != owner()) {\n      revert OnlyRegistryModuleOrOwner(msg.sender);\n    }\n    if (administrator == address(0)) {\n      revert ZeroAddress();\n    }\n    TokenConfig storage config = s_tokenConfig[localToken];\n\n    if (config.administrator != address(0)) {\n      revert AlreadyRegistered(localToken);\n    }\n\n    config.pendingAdministrator = administrator;\n\n    // We don't care if it's already in the set, as it's a no-op.\n    s_tokens.add(localToken);\n\n    emit AdministratorTransferRequested(localToken, address(0), administrator);\n  }\n\n  // ================================================================\n  // │                      Registry Modules                        │\n  // ================================================================\n\n  /// @notice Checks if an address is a registry module.\n  /// @param module The address to check.\n  /// @return True if the address is a registry module, false otherwise.\n  function isRegistryModule(\n    address module\n  ) public view returns (bool) {\n    return s_registryModules.contains(module);\n  }\n\n  /// @notice Adds a new registry module to the list of allowed modules.\n  /// @param module The module to add.\n  function addRegistryModule(\n    address module\n  ) external onlyOwner {\n    if (s_registryModules.add(module)) {\n      emit RegistryModuleAdded(module);\n    }\n  }\n\n  /// @notice Removes a registry module from the list of allowed modules.\n  /// @param module The module to remove.\n  function removeRegistryModule(\n    address module\n  ) external onlyOwner {\n    if (s_registryModules.remove(module)) {\n      emit RegistryModuleRemoved(module);\n    }\n  }\n\n  // ================================================================\n  // │                           Access                             │\n  // ================================================================\n\n  /// @notice Checks if an address is the administrator of the given token.\n  modifier onlyTokenAdmin(\n    address token\n  ) {\n    if (s_tokenConfig[token].administrator != msg.sender) {\n      revert OnlyAdministrator(msg.sender, token);\n    }\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\ncontract Ownable2Step is IOwnable {\n  /// @notice The pending owner is the address to which ownership may be transferred.\n  address private s_pendingOwner;\n  /// @notice The owner is the current owner of the contract.\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\n  /// instead of the much less used s_pendingOwner.\n  address private s_owner;\n\n  error OwnerCannotBeZero();\n  error MustBeProposedOwner();\n  error CannotTransferToSelf();\n  error OnlyCallableByOwner();\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    if (newOwner == address(0)) {\n      revert OwnerCannotBeZero();\n    }\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\n  /// @param to The address to which ownership will be transferred.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  /// @param to The address to which ownership will be transferred.\n  function _transferOwnership(address to) private {\n    if (to == msg.sender) {\n      revert CannotTransferToSelf();\n    }\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    if (msg.sender != s_pendingOwner) {\n      revert MustBeProposedOwner();\n    }\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    if (msg.sender != s_owner) {\n      revert OnlyCallableByOwner();\n    }\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/Ownable2StepMsgSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Ownable2Step} from \"./Ownable2Step.sol\";\n\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\ncontract Ownable2StepMsgSender is Ownable2Step {\n  constructor() Ownable2Step(msg.sender, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwner} from \"./ConfirmedOwner.sol\";\n\n/// @title The OwnerIsCreator contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract OwnerIsCreator is ConfirmedOwner {\n  constructor() ConfirmedOwner(msg.sender) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/call/CallWithExactGas.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice This library contains various callWithExactGas functions. All of them are\n/// safe from gas bomb attacks.\n/// @dev There is code duplication in this library. This is done to not leave the assembly\n/// the blocks.\nlibrary CallWithExactGas {\n  error NoContract();\n  error NoGasForCallExactCheck();\n  error NotEnoughGasForCall();\n\n  bytes4 internal constant NO_CONTRACT_SIG = 0x0c3b563c;\n  bytes4 internal constant NO_GAS_FOR_CALL_EXACT_CHECK_SIG = 0xafa32a2c;\n  bytes4 internal constant NOT_ENOUGH_GAS_FOR_CALL_SIG = 0x37c3be29;\n\n  /// @notice calls target address with exactly gasAmount gas and payload as calldata.\n  /// Accounts for gasForCallExactCheck gas that will be used by this function. Will revert\n  /// if the target is not a contact. Will revert when there is not enough gas to call the\n  /// target with gasAmount gas.\n  /// @dev Ignores the return data, which makes it immune to gas bomb attacks.\n  /// @return success whether the call succeeded\n  function _callWithExactGas(\n    bytes memory payload,\n    address target,\n    uint256 gasLimit,\n    uint16 gasForCallExactCheck\n  ) internal returns (bool success) {\n    assembly {\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      // Note we do this check prior to measuring gas so gasForCallExactCheck (our \"cushion\")\n      // doesn't need to account for it.\n      if iszero(extcodesize(target)) {\n        mstore(0x0, NO_CONTRACT_SIG)\n        revert(0x0, 0x4)\n      }\n\n      let g := gas()\n      // Compute g -= gasForCallExactCheck and check for underflow\n      // The gas actually passed to the callee is _min(gasAmount, 63//64*gas available).\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\n      // as we do not want to provide them with less, however that check itself costs\n      // gas. gasForCallExactCheck ensures we have at least enough gas to be able\n      // to revert if gasAmount >  63//64*gas available.\n      if lt(g, gasForCallExactCheck) {\n        mstore(0x0, NO_GAS_FOR_CALL_EXACT_CHECK_SIG)\n        revert(0x0, 0x4)\n      }\n      g := sub(g, gasForCallExactCheck)\n      // if g - g//64 <= gasAmount, revert. We subtract g//64 because of EIP-150\n      if iszero(gt(sub(g, div(g, 64)), gasLimit)) {\n        mstore(0x0, NOT_ENOUGH_GAS_FOR_CALL_SIG)\n        revert(0x0, 0x4)\n      }\n\n      // call and return whether we succeeded. ignore return data\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\n      success := call(gasLimit, target, 0, add(payload, 0x20), mload(payload), 0x0, 0x0)\n    }\n    return success;\n  }\n\n  /// @notice calls target address with exactly gasAmount gas and payload as calldata.\n  /// Account for gasForCallExactCheck gas that will be used by this function. Will revert\n  /// if the target is not a contact. Will revert when there is not enough gas to call the\n  /// target with gasAmount gas.\n  /// @dev Caps the return data length, which makes it immune to gas bomb attacks.\n  /// @dev Return data cap logic borrowed from\n  /// https://github.com/nomad-xyz/ExcessivelySafeCall/blob/main/src/ExcessivelySafeCall.sol.\n  /// @return success whether the call succeeded\n  /// @return retData the return data from the call, capped at maxReturnBytes bytes\n  /// @return gasUsed the gas used by the external call. Does not include the overhead of this function.\n  function _callWithExactGasSafeReturnData(\n    bytes memory payload,\n    address target,\n    uint256 gasLimit,\n    uint16 gasForCallExactCheck,\n    uint16 maxReturnBytes\n  ) internal returns (bool success, bytes memory retData, uint256 gasUsed) {\n    // allocate retData memory ahead of time\n    retData = new bytes(maxReturnBytes);\n\n    assembly {\n      // solidity calls check that a contract actually exists at the destination, so we do the same\n      // Note we do this check prior to measuring gas so gasForCallExactCheck (our \"cushion\")\n      // doesn't need to account for it.\n      if iszero(extcodesize(target)) {\n        mstore(0x0, NO_CONTRACT_SIG)\n        revert(0x0, 0x4)\n      }\n\n      let g := gas()\n      // Compute g -= gasForCallExactCheck and check for underflow\n      // The gas actually passed to the callee is _min(gasAmount, 63//64*gas available).\n      // We want to ensure that we revert if gasAmount >  63//64*gas available\n      // as we do not want to provide them with less, however that check itself costs\n      // gas. gasForCallExactCheck ensures we have at least enough gas to be able\n      // to revert if gasAmount >  63//64*gas available.\n      if lt(g, gasForCallExactCheck) {\n        mstore(0x0, NO_GAS_FOR_CALL_EXACT_CHECK_SIG)\n        revert(0x0, 0x4)\n      }\n      g := sub(g, gasForCallExactCheck)\n      // if g - g//64 <= gasAmount, revert. We subtract g//64 because of EIP-150\n      if iszero(gt(sub(g, div(g, 64)), gasLimit)) {\n        mstore(0x0, NOT_ENOUGH_GAS_FOR_CALL_SIG)\n        revert(0x0, 0x4)\n      }\n\n      // We save the gas before the call so we can calculate how much gas the call used\n      let gasBeforeCall := gas()\n      // call and return whether we succeeded. ignore return data\n      // call(gas,addr,value,argsOffset,argsLength,retOffset,retLength)\n      success := call(gasLimit, target, 0, add(payload, 0x20), mload(payload), 0x0, 0x0)\n      gasUsed := sub(gasBeforeCall, gas())\n\n      // limit our copy to maxReturnBytes bytes\n      let toCopy := returndatasize()\n      if gt(toCopy, maxReturnBytes) {\n        toCopy := maxReturnBytes\n      }\n      // Store the length of the copied bytes\n      mstore(retData, toCopy)\n      // copy the bytes from retData[0:_toCopy]\n      returndatacopy(add(retData, 0x20), 0x0, toCopy)\n    }\n    return (success, retData, gasUsed);\n  }\n\n  /// @notice Calls target address with exactly gasAmount gas and payload as calldata\n  /// or reverts if at least gasLimit gas is not available.\n  /// @dev Does not check if target is a contract. If it is not a contract, the low-level\n  /// call will still be made and it will succeed.\n  /// @dev Ignores the return data, which makes it immune to gas bomb attacks.\n  /// @return success whether the call succeeded\n  /// @return sufficientGas Whether there was enough gas to make the call\n  function _callWithExactGasEvenIfTargetIsNoContract(\n    bytes memory payload,\n    address target,\n    uint256 gasLimit,\n    uint16 gasForCallExactCheck\n  ) internal returns (bool success, bool sufficientGas) {\n    assembly {\n      let g := gas()\n      // Compute g -= CALL_WITH_EXACT_GAS_CUSHION and check for underflow. We\n      // need the cushion since the logic following the above call to gas also\n      // costs gas which we cannot account for exactly. So cushion is a\n      // conservative upper bound for the cost of this logic.\n      if iszero(lt(g, gasForCallExactCheck)) {\n        g := sub(g, gasForCallExactCheck)\n        // If g - g//64 <= gasAmount, we don't have enough gas. We subtract g//64 because of EIP-150.\n        if gt(sub(g, div(g, 64)), gasLimit) {\n          // Call and ignore success/return data. Note that we did not check\n          // whether a contract actually exists at the target address.\n          success := call(gasLimit, target, 0, add(payload, 0x20), mload(payload), 0x0, 0x0)\n          sufficientGas := true\n        }\n      }\n    }\n    return (success, sufficientGas);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.6;\n\ninterface IERC677Receiver {\n  function onTokenTransfer(address sender, uint256 amount, bytes calldata data) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/ITypeAndVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITypeAndVersion {\n  function typeAndVersion() external pure returns (string memory);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/token/ERC20/IBurnMintERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\n\ninterface IBurnMintERC20 is IERC20 {\n  /// @notice Mints new tokens for a given address.\n  /// @param account The address to mint the new tokens to.\n  /// @param amount The number of tokens to be minted.\n  /// @dev this function increases the total supply.\n  function mint(address account, uint256 amount) external;\n\n  /// @notice Burns tokens from the sender.\n  /// @param amount The number of tokens to be burned.\n  /// @dev this function decreases the total supply.\n  function burn(uint256 amount) external;\n\n  /// @notice Burns tokens from a given address..\n  /// @param account The address to burn tokens from.\n  /// @param amount The number of tokens to be burned.\n  /// @dev this function decreases the total supply.\n  function burn(address account, uint256 amount) external;\n\n  /// @notice Burns tokens from a given address..\n  /// @param account The address to burn tokens from.\n  /// @param amount The number of tokens to be burned.\n  /// @dev this function decreases the total supply.\n  function burnFrom(address account, uint256 amount) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/BurnMintERC677.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IBurnMintERC20} from \"../ERC20/IBurnMintERC20.sol\";\nimport {IERC677} from \"./IERC677.sol\";\n\nimport {ERC677} from \"./ERC677.sol\";\nimport {OwnerIsCreator} from \"../../access/OwnerIsCreator.sol\";\n\nimport {ERC20Burnable} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\nimport {EnumerableSet} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableSet.sol\";\nimport {IERC165} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol\";\nimport {IERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\n\n/// @notice A basic ERC677 compatible token contract with burn and minting roles.\n/// @dev The total supply can be limited during deployment.\ncontract BurnMintERC677 is IBurnMintERC20, ERC677, IERC165, ERC20Burnable, OwnerIsCreator {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  error SenderNotMinter(address sender);\n  error SenderNotBurner(address sender);\n  error MaxSupplyExceeded(uint256 supplyAfterMint);\n\n  event MintAccessGranted(address indexed minter);\n  event BurnAccessGranted(address indexed burner);\n  event MintAccessRevoked(address indexed minter);\n  event BurnAccessRevoked(address indexed burner);\n\n  // @dev the allowed minter addresses\n  EnumerableSet.AddressSet internal s_minters;\n  // @dev the allowed burner addresses\n  EnumerableSet.AddressSet internal s_burners;\n\n  /// @dev The number of decimals for the token\n  uint8 internal immutable i_decimals;\n\n  /// @dev The maximum supply of the token, 0 if unlimited\n  uint256 internal immutable i_maxSupply;\n\n  constructor(string memory name, string memory symbol, uint8 decimals_, uint256 maxSupply_) ERC677(name, symbol) {\n    i_decimals = decimals_;\n    i_maxSupply = maxSupply_;\n  }\n\n  function supportsInterface(bytes4 interfaceId) public pure virtual override returns (bool) {\n    return\n      interfaceId == type(IERC20).interfaceId ||\n      interfaceId == type(IERC677).interfaceId ||\n      interfaceId == type(IBurnMintERC20).interfaceId ||\n      interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // |                            ERC20                             |\n  // ================================================================\n\n  /// @dev Returns the number of decimals used in its user representation.\n  function decimals() public view virtual override returns (uint8) {\n    return i_decimals;\n  }\n\n  /// @dev Returns the max supply of the token, 0 if unlimited.\n  function maxSupply() public view virtual returns (uint256) {\n    return i_maxSupply;\n  }\n\n  /// @dev Uses OZ ERC20 _transfer to disallow sending to address(0).\n  /// @dev Disallows sending to address(this)\n  function _transfer(address from, address to, uint256 amount) internal virtual override validAddress(to) {\n    super._transfer(from, to, amount);\n  }\n\n  /// @dev Uses OZ ERC20 _approve to disallow approving for address(0).\n  /// @dev Disallows approving for address(this)\n  function _approve(address owner, address spender, uint256 amount) internal virtual override validAddress(spender) {\n    super._approve(owner, spender, amount);\n  }\n\n  /// @dev Exists to be backwards compatible with the older naming convention.\n  function decreaseApproval(address spender, uint256 subtractedValue) external returns (bool success) {\n    return decreaseAllowance(spender, subtractedValue);\n  }\n\n  /// @dev Exists to be backwards compatible with the older naming convention.\n  function increaseApproval(address spender, uint256 addedValue) external {\n    increaseAllowance(spender, addedValue);\n  }\n\n  /// @notice Check if recipient is valid (not this contract address).\n  /// @param recipient the account we transfer/approve to.\n  /// @dev Reverts with an empty revert to be compatible with the existing link token when\n  /// the recipient is this contract address.\n  modifier validAddress(address recipient) virtual {\n    // solhint-disable-next-line reason-string, gas-custom-errors\n    if (recipient == address(this)) revert();\n    _;\n  }\n\n  // ================================================================\n  // |                      Burning & minting                       |\n  // ================================================================\n\n  /// @inheritdoc ERC20Burnable\n  /// @dev Uses OZ ERC20 _burn to disallow burning from address(0).\n  /// @dev Decreases the total supply.\n  function burn(uint256 amount) public override(IBurnMintERC20, ERC20Burnable) onlyBurner {\n    super.burn(amount);\n  }\n\n  /// @inheritdoc IBurnMintERC20\n  /// @dev Alias for BurnFrom for compatibility with the older naming convention.\n  /// @dev Uses burnFrom for all validation & logic.\n  function burn(address account, uint256 amount) public virtual override {\n    burnFrom(account, amount);\n  }\n\n  /// @inheritdoc ERC20Burnable\n  /// @dev Uses OZ ERC20 _burn to disallow burning from address(0).\n  /// @dev Decreases the total supply.\n  function burnFrom(address account, uint256 amount) public override(IBurnMintERC20, ERC20Burnable) onlyBurner {\n    super.burnFrom(account, amount);\n  }\n\n  /// @inheritdoc IBurnMintERC20\n  /// @dev Uses OZ ERC20 _mint to disallow minting to address(0).\n  /// @dev Disallows minting to address(this)\n  /// @dev Increases the total supply.\n  function mint(address account, uint256 amount) external override onlyMinter validAddress(account) {\n    if (i_maxSupply != 0 && totalSupply() + amount > i_maxSupply) revert MaxSupplyExceeded(totalSupply() + amount);\n\n    _mint(account, amount);\n  }\n\n  // ================================================================\n  // |                            Roles                             |\n  // ================================================================\n\n  /// @notice grants both mint and burn roles to `burnAndMinter`.\n  /// @dev calls public functions so this function does not require\n  /// access controls. This is handled in the inner functions.\n  function grantMintAndBurnRoles(address burnAndMinter) external {\n    grantMintRole(burnAndMinter);\n    grantBurnRole(burnAndMinter);\n  }\n\n  /// @notice Grants mint role to the given address.\n  /// @dev only the owner can call this function.\n  function grantMintRole(address minter) public onlyOwner {\n    if (s_minters.add(minter)) {\n      emit MintAccessGranted(minter);\n    }\n  }\n\n  /// @notice Grants burn role to the given address.\n  /// @dev only the owner can call this function.\n  function grantBurnRole(address burner) public onlyOwner {\n    if (s_burners.add(burner)) {\n      emit BurnAccessGranted(burner);\n    }\n  }\n\n  /// @notice Revokes mint role for the given address.\n  /// @dev only the owner can call this function.\n  function revokeMintRole(address minter) public onlyOwner {\n    if (s_minters.remove(minter)) {\n      emit MintAccessRevoked(minter);\n    }\n  }\n\n  /// @notice Revokes burn role from the given address.\n  /// @dev only the owner can call this function\n  function revokeBurnRole(address burner) public onlyOwner {\n    if (s_burners.remove(burner)) {\n      emit BurnAccessRevoked(burner);\n    }\n  }\n\n  /// @notice Returns all permissioned minters\n  function getMinters() public view returns (address[] memory) {\n    return s_minters.values();\n  }\n\n  /// @notice Returns all permissioned burners\n  function getBurners() public view returns (address[] memory) {\n    return s_burners.values();\n  }\n\n  // ================================================================\n  // |                            Access                            |\n  // ================================================================\n\n  /// @notice Checks whether a given address is a minter for this token.\n  /// @return true if the address is allowed to mint.\n  function isMinter(address minter) public view returns (bool) {\n    return s_minters.contains(minter);\n  }\n\n  /// @notice Checks whether a given address is a burner for this token.\n  /// @return true if the address is allowed to burn.\n  function isBurner(address burner) public view returns (bool) {\n    return s_burners.contains(burner);\n  }\n\n  /// @notice Checks whether the msg.sender is a permissioned minter for this token\n  /// @dev Reverts with a SenderNotMinter if the check fails\n  modifier onlyMinter() {\n    if (!isMinter(msg.sender)) revert SenderNotMinter(msg.sender);\n    _;\n  }\n\n  /// @notice Checks whether the msg.sender is a permissioned burner for this token\n  /// @dev Reverts with a SenderNotBurner if the check fails\n  modifier onlyBurner() {\n    if (!isBurner(msg.sender)) revert SenderNotBurner(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/ERC677.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.0;\n\nimport {IERC677} from \"./IERC677.sol\";\nimport {IERC677Receiver} from \"../../interfaces/IERC677Receiver.sol\";\n\nimport {ERC20} from \"../../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/ERC20.sol\";\n\ncontract ERC677 is IERC677, ERC20 {\n  constructor(string memory name, string memory symbol) ERC20(name, symbol) {}\n\n  /// @inheritdoc IERC677\n  function transferAndCall(address to, uint256 amount, bytes memory data) public returns (bool success) {\n    super.transfer(to, amount);\n    emit Transfer(msg.sender, to, amount, data);\n    if (to.code.length > 0) {\n      IERC677Receiver(to).onTokenTransfer(msg.sender, amount, data);\n    }\n    return true;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/IERC677.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677 {\n  event Transfer(address indexed from, address indexed to, uint256 value, bytes data);\n\n  /// @notice Transfer tokens from `msg.sender` to another address and then call `onTransferReceived` on receiver\n  /// @param to The address which you want to transfer to\n  /// @param amount The amount of tokens to be transferred\n  /// @param data bytes Additional data with no specified format, sent in call to `to`\n  /// @return true unless throwing\n  function transferAndCall(address to, uint256 amount, bytes memory data) external returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) private _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n   *\n   * The default value of {decimals} is 18. To select a different value for\n   * {decimals} you should overload it.\n   *\n   * All two of these values are immutable: they can only be set once during\n   * construction.\n   */\n  constructor(string memory name_, string memory symbol_) {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n   * name.\n   */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n   * For example, if `decimals` equals `2`, a balance of `505` tokens should\n   * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n   *\n   * Tokens usually opt for a value of 18, imitating the relationship between\n   * Ether and Wei. This is the value {ERC20} uses, unless this function is\n   * overridden;\n   *\n   * NOTE: This information is only used for _display_ purposes: it in\n   * no way affects any of the arithmetic of the contract, including\n   * {IERC20-balanceOf} and {IERC20-transfer}.\n   */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n   */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n   */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n   *\n   * Requirements:\n   *\n   * - `to` cannot be the zero address.\n   * - the caller must have a balance of at least `amount`.\n   */\n  function transfer(address to, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n   */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n   *\n   * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n   * `transferFrom`. This is semantically equivalent to an infinite approval.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n   *\n   * Emits an {Approval} event indicating the updated allowance. This is not\n   * required by the EIP. See the note at the beginning of {ERC20}.\n   *\n   * NOTE: Does not update the allowance if the current allowance\n   * is the maximum `uint256`.\n   *\n   * Requirements:\n   *\n   * - `from` and `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   * - the caller must have allowance for ``from``'s tokens of at least\n   * `amount`.\n   */\n  function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n   *\n   * This is an alternative to {approve} that can be used as a mitigation for\n   * problems described in {IERC20-approve}.\n   *\n   * Emits an {Approval} event indicating the updated allowance.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `spender` must have allowance for the caller of at least\n   * `subtractedValue`.\n   */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    uint256 currentAllowance = allowance(owner, spender);\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - subtractedValue);\n    }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `from` to `to`.\n   *\n   * This internal function is equivalent to {transfer}, and can be used to\n   * e.g. implement automatic token fees, slashing mechanisms, etc.\n   *\n   * Emits a {Transfer} event.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `from` must have a balance of at least `amount`.\n   */\n  function _transfer(address from, address to, uint256 amount) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n    unchecked {\n      _balances[from] = fromBalance - amount;\n      // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n      // decrementing then incrementing.\n      _balances[to] += amount;\n    }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n   * the total supply.\n   *\n   * Emits a {Transfer} event with `from` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n    unchecked {\n      // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n      _balances[account] += amount;\n    }\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n   * total supply.\n   *\n   * Emits a {Transfer} event with `to` set to the zero address.\n   *\n   * Requirements:\n   *\n   * - `account` cannot be the zero address.\n   * - `account` must have at least `amount` tokens.\n   */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n    unchecked {\n      _balances[account] = accountBalance - amount;\n      // Overflow not possible: amount <= accountBalance <= totalSupply.\n      _totalSupply -= amount;\n    }\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n   *\n   * This internal function is equivalent to `approve`, and can be used to\n   * e.g. set automatic allowances for certain subsystems, etc.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `owner` cannot be the zero address.\n   * - `spender` cannot be the zero address.\n   */\n  function _approve(address owner, address spender, uint256 amount) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n   *\n   * Does not update the allowance amount in case of infinite allowance.\n   * Revert if not enough allowance is available.\n   *\n   * Might emit an {Approval} event.\n   */\n  function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n      unchecked {\n        _approve(owner, spender, currentAllowance - amount);\n      }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * will be transferred to `to`.\n   * - when `from` is zero, `amount` tokens will be minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n   * minting and burning.\n   *\n   * Calling conditions:\n   *\n   * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n   * has been transferred to `to`.\n   * - when `from` is zero, `amount` tokens have been minted for `to`.\n   * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n   * - `from` and `to` are never both zero.\n   *\n   * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n   */\n  function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n   * given ``owner``'s signed approval.\n   *\n   * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n   * ordering also apply here.\n   *\n   * Emits an {Approval} event.\n   *\n   * Requirements:\n   *\n   * - `spender` cannot be the zero address.\n   * - `deadline` must be a timestamp in the future.\n   * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n   * over the EIP712-formatted function arguments.\n   * - the signature must use ``owner``'s current nonce (see {nonces}).\n   *\n   * For more information on the signature format, see the\n   * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n   * section].\n   */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n   * included whenever a signature is generated for {permit}.\n   *\n   * Every successful call to {permit} increases ``owner``'s nonce by one. This\n   * prevents a signature from being used multiple times.\n   */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n   */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC20.sol\";\nimport \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n  /**\n   * @dev Destroys `amount` tokens from the caller.\n   *\n   * See {ERC20-_burn}.\n   */\n  function burn(uint256 amount) public virtual {\n    _burn(_msgSender(), amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, deducting from the caller's\n   * allowance.\n   *\n   * See {ERC20-_burn} and {ERC20-allowance}.\n   *\n   * Requirements:\n   *\n   * - the caller must have allowance for ``accounts``'s tokens of at least\n   * `amount`.\n   */\n  function burnFrom(address account, uint256 amount) public virtual {\n    _spendAllowance(account, _msgSender(), amount);\n    _burn(account, amount);\n  }\n}"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(IERC20 token, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n   * {IERC20-approve}, and its usage is discouraged.\n   *\n   * Whenever possible, use {safeIncreaseAllowance} and\n   * {safeDecreaseAllowance} instead.\n   */\n  function safeApprove(IERC20 token, address spender, uint256 value) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n    unchecked {\n      uint256 oldAllowance = token.allowance(address(this), spender);\n      require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n      uint256 newAllowance = oldAllowance - value;\n      _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n   * on the return value: the return value is optional (but if data is returned, it must not be false).\n   * @param token The token targeted by the call.\n   * @param data The call data (encoded using abi.encode or one of its variants).\n   */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n   *\n   * [IMPORTANT]\n   * ====\n   * It is unsafe to assume that an address for which this function returns\n   * false is an externally-owned account (EOA) and not a contract.\n   *\n   * Among others, `isContract` will return false for the following\n   * types of addresses:\n   *\n   *  - an externally-owned account\n   *  - a contract in construction\n   *  - an address where a contract will be created\n   *  - an address where a contract lived, but was destroyed\n   * ====\n   *\n   * [IMPORTANT]\n   * ====\n   * You shouldn't rely on `isContract` to protect against flash loan attacks!\n   *\n   * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n   * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n   * constructor.\n   * ====\n   */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n   * `recipient`, forwarding all available gas and reverting on errors.\n   *\n   * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n   * of certain opcodes, possibly making contracts go over the 2300 gas limit\n   * imposed by `transfer`, making them unable to receive funds via\n   * `transfer`. {sendValue} removes this limitation.\n   *\n   * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n   *\n   * IMPORTANT: because control is transferred to `recipient`, care must be\n   * taken to not create reentrancy vulnerabilities. Consider using\n   * {ReentrancyGuard} or the\n   * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n   */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n   * plain `call` is an unsafe replacement for a function call: use this\n   * function instead.\n   *\n   * If `target` reverts with a revert reason, it is bubbled up by this\n   * function (like regular Solidity function calls).\n   *\n   * Returns the raw returned data. To convert to the expected return value,\n   * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n   *\n   * Requirements:\n   *\n   * - `target` must be a contract.\n   * - calling `target` with `data` must not revert.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n   * `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCall(address target, bytes memory data, string memory errorMessage) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but also transferring `value` wei to `target`.\n   *\n   * Requirements:\n   *\n   * - the calling contract must have an ETH balance of at least `value`.\n   * - the called Solidity function must be `payable`.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n   * with `errorMessage` as a fallback revert reason when `target` reverts.\n   *\n   * _Available since v3.1._\n   */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a static call.\n   *\n   * _Available since v3.3._\n   */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n   * but performing a delegate call.\n   *\n   * _Available since v3.4._\n   */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n   * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n   *\n   * _Available since v4.8._\n   */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n   * revert reason or using the provided one.\n   *\n   * _Available since v4.3._\n   */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n   */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    bytes32[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n   *\n   * Returns true if the value was added to the set, that is if it was not\n   * already present.\n   */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n   *\n   * Returns true if the value was removed from the set, that is if it was\n   * present.\n   */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n   */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n   */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n   *\n   * Note that there are no guarantees on the ordering of values inside the\n   * array, and it may change when more values are added or removed.\n   *\n   * Requirements:\n   *\n   * - `index` must be strictly less than {length}.\n   */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n   *\n   * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n   * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n   * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n   * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n   */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function getSupportedInterfaces(\n        address account,\n        bytes4[] memory interfaceIds\n    ) internal view returns (bool[] memory) {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@chainlink/local/src/ccip/BurnMintERC677Helper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {BurnMintERC677} from \"@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/BurnMintERC677.sol\";\n\n/// @title BurnMintERC677Helper\n/// @notice This contract extends the functionality of the BurnMintERC677 token contract to include a `drip` function that mints one full token to a specified address.\n/// @dev Inherits from the BurnMintERC677 contract and sets the token name, symbol, decimals, and initial supply in the constructor.\ncontract BurnMintERC677Helper is BurnMintERC677 {\n    /**\n     * @notice Constructor to initialize the BurnMintERC677Helper contract with a name and symbol.\n     * @dev Calls the parent constructor of BurnMintERC677 with fixed decimals (18) and initial supply (0).\n     * @param name - The name of the token.\n     * @param symbol - The symbol of the token.\n     */\n    constructor(\n        string memory name,\n        string memory symbol\n    ) BurnMintERC677(name, symbol, 18, 0) {}\n\n    /**\n     * @notice Mints one full token (1e18) to the specified address.\n     * @dev Calls the internal `_mint` function from the BurnMintERC677 contract.\n     * @param to - The address to receive the minted token.\n     */\n    function drip(address to) external {\n        _mint(to, 1e18);\n    }\n}\n"
    },
    "@chainlink/local/src/ccip/CCIPLocalSimulator.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.19;\n\nimport {WETH9} from \"../shared/WETH9.sol\";\nimport {LinkToken} from \"../shared/LinkToken.sol\";\nimport {BurnMintERC677Helper} from \"./BurnMintERC677Helper.sol\";\nimport {MockCCIPRouter} from \"@chainlink/contracts-ccip/src/v0.8/ccip/test/mocks/MockRouter.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {IERC20} from\n    \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport {SafeERC20} from\n    \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IOwner} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IOwner.sol\";\nimport {IGetCCIPAdmin} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IGetCCIPAdmin.sol\";\nimport {AccessControl} from\n    \"@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/access/AccessControl.sol\";\n\n/// @title CCIPLocalSimulator\n/// @notice This contract simulates local CCIP (Cross-Chain Interoperability Protocol) operations for testing and development purposes.\n/// @dev This contract includes methods to manage supported tokens and configurations for local simulations.\ncontract CCIPLocalSimulator {\n    using SafeERC20 for IERC20;\n\n    /// @notice The unique CCIP Chain Selector constant\n    uint64 constant CHAIN_SELECTOR = 16015286601757825753;\n\n    /// @notice The wrapped native token instance\n    WETH9 internal immutable i_wrappedNative;\n\n    /// @notice The LINK token instance\n    LinkToken internal immutable i_linkToken;\n\n    /// @notice The BurnMintERC677Helper instance for CCIP-BnM token\n    BurnMintERC677Helper internal immutable i_ccipBnM;\n\n    /// @notice The BurnMintERC677Helper instance for CCIP-LnM token\n    BurnMintERC677Helper internal immutable i_ccipLnM;\n\n    /// @notice The mock CCIP router instance\n    MockCCIPRouter internal immutable i_mockRouter;\n\n    /// @notice The list of supported token addresses\n    address[] internal s_supportedTokens;\n\n    error CCIPLocalSimulator__MsgSenderIsNotTokenOwner();\n    error CCIPLocalSimulator__RequiredRoleNotFound(address account, bytes32 role, address token);\n\n    /**\n     * @notice Constructor to initialize the contract and pre-deployed token instances\n     */\n    constructor() {\n        i_wrappedNative = new WETH9();\n        i_linkToken = new LinkToken();\n        i_ccipBnM = new BurnMintERC677Helper(\"CCIP-BnM\", \"CCIP-BnM\");\n        i_ccipLnM = new BurnMintERC677Helper(\"CCIP-LnM\", \"CCIP-LnM\");\n        i_mockRouter = new MockCCIPRouter();\n\n        s_supportedTokens.push(address(i_ccipBnM));\n        s_supportedTokens.push(address(i_ccipLnM));\n    }\n\n    /**\n     * @notice Allows user to support any new token, besides CCIP BnM and CCIP LnM, for cross-chain transfers.\n     *         Reverts if token does not implement owner() function.\n     *         Reverts if the caller is not the token owner.\n     *\n     * @param tokenAddress - The address of the token to add to the list of supported tokens.\n     */\n    function supportNewTokenViaOwner(address tokenAddress) external {\n        if (msg.sender != IOwner(tokenAddress).owner()) {\n            revert CCIPLocalSimulator__MsgSenderIsNotTokenOwner();\n        }\n        s_supportedTokens.push(tokenAddress);\n    }\n\n    /**\n     * @notice Allows user to support any new token, besides CCIP BnM and CCIP LnM, for cross-chain transfers.\n     *         Reverts if token does not implement getCCIPAdmin() function.\n     *         Reverts if the caller is not the token CCIPAdmin.\n     *\n     * @param tokenAddress - The address of the token to add to the list of supported tokens.\n     */\n    function supportNewTokenViaGetCCIPAdmin(address tokenAddress) external {\n        if (msg.sender != IGetCCIPAdmin(tokenAddress).getCCIPAdmin()) {\n            revert CCIPLocalSimulator__MsgSenderIsNotTokenOwner();\n        }\n        s_supportedTokens.push(tokenAddress);\n    }\n\n    /**\n     * @notice Allows user to support any new token, besides CCIP BnM and CCIP LnM, for cross-chain transfers.\n     *         The caller must have the DEFAULT_ADMIN_ROLE as defined by the contract itself.\n     *         Reverts if the caller is not the admin of the token using OZ's AccessControl DEFAULT_ADMIN_ROLE.\n     *\n     * @param tokenAddress - The address of the token to add to the list of supported tokens.\n     */\n    function supportNewTokenViaAccessControlDefaultAdmin(address tokenAddress) external {\n        bytes32 defaultAdminRole = AccessControl(tokenAddress).DEFAULT_ADMIN_ROLE();\n        if (!AccessControl(tokenAddress).hasRole(defaultAdminRole, msg.sender)) {\n            revert CCIPLocalSimulator__RequiredRoleNotFound(msg.sender, defaultAdminRole, tokenAddress);\n        }\n        s_supportedTokens.push(tokenAddress);\n    }\n\n    /**\n     * @notice Checks whether the provided `chainSelector` is supported by the simulator.\n     *\n     * @param chainSelector - The unique CCIP Chain Selector.\n     *\n     * @return supported - Returns true if `chainSelector` is supported by the simulator.\n     */\n    function isChainSupported(uint64 chainSelector) public pure returns (bool supported) {\n        supported = chainSelector == CHAIN_SELECTOR;\n    }\n\n    /**\n     * @notice Gets a list of token addresses that are supported for cross-chain transfers by the simulator.\n     *\n     * @param chainSelector - The unique CCIP Chain Selector.\n     *\n     * @return tokens - Returns a list of token addresses that are supported for cross-chain transfers by the simulator.\n     */\n    function getSupportedTokens(uint64 chainSelector) external view returns (address[] memory tokens) {\n        if (!isChainSupported(chainSelector)) {\n            return new address[](0);\n        }\n\n        tokens = s_supportedTokens;\n    }\n\n    /**\n     * @notice Requests LINK tokens from the faucet. The provided amount of tokens are transferred to provided destination address.\n     *\n     * @param to - The address to which LINK tokens are to be sent.\n     * @param amount - The amount of LINK tokens to send.\n     *\n     * @return success - Returns `true` if the transfer of tokens was successful, otherwise `false`.\n     */\n    function requestLinkFromFaucet(address to, uint256 amount) external returns (bool success) {\n        success = i_linkToken.transfer(to, amount);\n    }\n\n    /**\n     * @notice Returns configuration details for pre-deployed contracts and services needed for local CCIP simulations.\n     *\n     * @return chainSelector_ - The unique CCIP Chain Selector.\n     * @return sourceRouter_  - The source chain Router contract.\n     * @return destinationRouter_ - The destination chain Router contract.\n     * @return wrappedNative_ - The wrapped native token which can be used for CCIP fees.\n     * @return linkToken_ - The LINK token.\n     * @return ccipBnM_ - The ccipBnM token.\n     * @return ccipLnM_ - The ccipLnM token.\n     */\n    function configuration()\n        public\n        view\n        returns (\n            uint64 chainSelector_,\n            IRouterClient sourceRouter_,\n            IRouterClient destinationRouter_,\n            WETH9 wrappedNative_,\n            LinkToken linkToken_,\n            BurnMintERC677Helper ccipBnM_,\n            BurnMintERC677Helper ccipLnM_\n        )\n    {\n        return (\n            CHAIN_SELECTOR,\n            IRouterClient(address(i_mockRouter)),\n            IRouterClient(address(i_mockRouter)),\n            i_wrappedNative,\n            i_linkToken,\n            i_ccipBnM,\n            i_ccipLnM\n        );\n    }\n}\n"
    },
    "@chainlink/local/src/shared/LinkToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.19;\n\nimport {ERC677} from \"@chainlink/contracts-ccip/src/v0.8/shared/token/ERC677/ERC677.sol\";\n\n/// @title LinkToken\n/// @notice This contract implements the ChainLink Token (LINK) using the ERC677 standard.\n/// @dev Inherits from the ERC677 token contract and initializes with a fixed total supply and standard token details.\ncontract LinkToken is ERC677 {\n    /// @notice The total supply of LINK tokens.\n    uint private constant TOTAL_SUPPLY = 10 ** 27;\n\n    /// @notice The name of the LINK token.\n    string private constant NAME = \"ChainLink Token\";\n\n    /// @notice The symbol of the LINK token.\n    string private constant SYMBOL = \"LINK\";\n\n    /**\n     * @notice Constructor to initialize the LinkToken contract with a fixed total supply, name, and symbol.\n     * @dev Calls the ERC677 constructor with the name and symbol, and then mints the total supply to the contract deployer.\n     */\n    constructor() ERC677(NAME, SYMBOL) {\n        _onCreate();\n    }\n\n    /**\n     * @notice Hook that is called when this contract is created.\n     * @dev Useful to override constructor behaviour in child contracts (e.g., LINK bridge tokens).\n     *      The default implementation mints 10**27 tokens to the contract deployer.\n     */\n    function _onCreate() internal virtual {\n        _mint(msg.sender, TOTAL_SUPPLY);\n    }\n}\n"
    },
    "@chainlink/local/src/shared/WETH9.sol": {
      "content": "// Submitted for verification at Etherscan.io on 2017-12-12\n\n// Copyright (C) 2015, 2016, 2017 Dapphub\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\npragma solidity ^0.8.19;\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint256 wad);\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\n    event Deposit(address indexed dst, uint256 wad);\n    event Withdrawal(address indexed src, uint256 wad);\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    receive() external payable {\n        _deposit();\n    }\n\n    function _deposit() internal {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function deposit() external payable {\n        _deposit();\n    }\n\n    function withdraw(uint256 wad) external {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint256 wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint256 wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint128).max\n        ) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n"
    },
    "contracts/bridge/CCIPAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IGovernance} from \"../equity/IGovernance.sol\";\nimport {ITokenPool} from \"./ITokenPool.sol\";\nimport {TokenAdminRegistry} from \"@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/TokenAdminRegistry.sol\";\nimport {RateLimiter} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol\";\nimport {BridgeAccounting} from \"../equity/BridgeAccounting.sol\";\nimport {IBasicFrankencoin} from \"../stablecoin/IBasicFrankencoin.sol\";\nimport {RegistryModuleOwnerCustom} from \"@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/RegistryModuleOwnerCustom.sol\";\n\n/**\n * The admin for briding Frankencoins using CCIP.\n * Each chain needs an instance of this administrator.\n */\ncontract CCIPAdmin {\n    uint64 public constant DAY = 24 * 60 * 60;\n\n    IGovernance public immutable GOVERNANCE;\n    ITokenPool public tokenPool;\n    TokenAdminRegistry public immutable TOKEN_ADMIN_REGISTRY;\n    address public immutable ZCHF;\n\n    struct RemotePoolUpdate {\n        bool add; // true if adding, false if removing\n        uint64 chain;\n        bytes poolAddress;\n    }\n\n    mapping(bytes32 hash => uint64 deadline) public proposals;\n\n    error TooEarly(uint64 deadline);\n    error UnknownProposal(bytes32 hash);\n    error ProposalAlreadyMade(bytes32 hash);\n    error AlreadySet();\n\n    event ProposalMade(bytes32 hash, uint64 deadline);\n    event ProposalDenied(bytes32 hash);\n    event ProposalEnacted(bytes32 hash);\n\n    event RemotePoolUpdateProposed(bytes32 hash, address indexed proposer, RemotePoolUpdate update);\n    event RemoveChainProposed(bytes32 hash, address indexed proposer, uint64 chain);\n    event AddChainProposed(bytes32 hash, address indexed proposer, ITokenPool.ChainUpdate update);\n    event AdminTransferProposed(bytes32 hash, address indexed proposer, address newAdmin);\n\n    event RemotePoolAdded(uint64 indexed chain, bytes indexed poolAddress);\n    event RemotePoolRemoved(uint64 indexed chain, bytes indexed poolAddress);\n    event ChainRemoved(uint64 id);\n    event ChainAdded(ITokenPool.ChainUpdate config);\n    event AdminTransfered(address newAdmin);\n    event RateLimit(uint64 remoteChain, RateLimiter.Config inboundConfigs, RateLimiter.Config outboundConfig);\n\n    modifier onlyQualified(address[] calldata helpers) {\n        GOVERNANCE.checkQualified(msg.sender, helpers);\n        _;\n    }\n\n    constructor(TokenAdminRegistry tokenAdminRegistry, IBasicFrankencoin zchf) {\n        GOVERNANCE = zchf.reserve();\n        TOKEN_ADMIN_REGISTRY = tokenAdminRegistry;\n        ZCHF = address(zchf);\n    }\n\n    /**\n    * @notice Registers the token in the CCIP system\n    * @dev Can only be called while the token admin is not set\n    */\n    function registerToken(RegistryModuleOwnerCustom registerModule) external {\n        if(TOKEN_ADMIN_REGISTRY.getTokenConfig(ZCHF).administrator != address(0)) {\n            revert AlreadySet();\n        }\n        registerModule.registerAdminViaGetCCIPAdmin(ZCHF);\n    }\n\n    /**\n     * @notice Sets the token pool to administer and sets in in the TokenAdminRegistry\n     * @dev The token pool can only be set once\n     * @param _tokenPool The token pool to set\n     */\n    function setTokenPool(ITokenPool _tokenPool) external {\n        if (address(tokenPool) != address(0)) revert AlreadySet();\n        tokenPool = _tokenPool;\n        TOKEN_ADMIN_REGISTRY.setPool(ZCHF, address(_tokenPool));\n    }\n\n    /**\n     * @notice Accepts the admin role transfer on the TokenAdminRegistry\n     */\n    function acceptAdmin() public {\n        TOKEN_ADMIN_REGISTRY.acceptAdminRole(ZCHF);\n    }\n\n    /**\n     * @notice Accepts ownership transfer on the TokenPool\n     */\n    function acceptOwnership() public {\n        tokenPool.acceptOwnership();\n    }\n\n    /**\n     * @notice Proposed a remote pool update\n     * @dev The contract only stores the hash. So the data has to be passed in during apply again\n     * @param update  The update proposal\n     */\n    function proposeRemotePoolUpdate(RemotePoolUpdate memory update, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"remotePoolUpdate\", update));\n        propose(hash, 7, helpers);\n        emit RemotePoolUpdateProposed(hash, msg.sender, update);\n    }\n\n    /**\n     * @notice Applies the update on the TokenPool\n     * @param update RemotePoolUpdate information\n     */\n    function applyRemotePoolUpdate(RemotePoolUpdate memory update) external {\n        enact(keccak256(abi.encode(\"remotePoolUpdate\", update)));\n        if (update.add) {\n            tokenPool.addRemotePool(update.chain, update.poolAddress);\n            emit RemotePoolAdded(update.chain, update.poolAddress);\n        } else {\n            tokenPool.removeRemotePool(update.chain, update.poolAddress);\n            emit RemotePoolRemoved(update.chain, update.poolAddress);\n        }\n    }\n\n    /**\n     * @notice Sets the rate limits for the given chain. Any qualified voter can apply rate limits with immediate effect.\n     * Rate limits can only do limited harm, so it is acceptable to be very permissive. At the same time, rate limits are typically\n     * applied during emergencies, e.g. when a chain has been hacked. Therefore, it is desirable to ensure that\n     * they can be applied quickly. Nonetheless, the proposal fee is still charged to discourage shenenigans.\n     * @param chain The chain to set the rate limits for\n     * @param inbound The inbound rate limits\n     * @param outbound The outbound rate limits\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function applyRateLimit(uint64 chain, RateLimiter.Config calldata inbound, RateLimiter.Config calldata outbound, address[] calldata helpers) external onlyQualified(helpers) {\n        tokenPool.setChainRateLimiterConfig(chain, inbound, outbound);\n        emit RateLimit(chain, inbound, outbound);\n    }\n\n    /**\n     * @notice Propose to add or remove remote chains\n     * @dev The contract only stores the hash. So the data has to be passed in during apply again\n     * @param chainId The chain to remove\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function proposeRemoveChain(uint64 chainId, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"removeChain\", chainId));\n        propose(hash, 7, helpers);\n        emit RemoveChainProposed(hash, msg.sender, chainId);\n    }\n\n    /**\n     * @notice Applies the remove chain proposal\n     * @param chainId The chain to remove\n     */\n    function applyRemoveChain(uint64 chainId) external {\n        enact(keccak256(abi.encode(\"removeChain\", chainId)));\n        uint64[] memory chainsToRemove = new uint64[](1);\n        chainsToRemove[0] = chainId;\n        ITokenPool.ChainUpdate[] memory chainsToAdd = new ITokenPool.ChainUpdate[](0);\n        tokenPool.applyChainUpdates(chainsToRemove, chainsToAdd);\n        emit ChainRemoved(chainId);\n    }\n\n    /**\n     * @notice Propose to add or remove remote chains\n     * @dev The contract only stores the hash. So the data has to be passed in during apply again\n     * @param config The chain configuration\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function proposeAddChain(ITokenPool.ChainUpdate calldata config, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"addChain\", config));\n        propose(hash, 7, helpers);\n        emit AddChainProposed(hash, msg.sender, config);\n    }\n\n    /**\n     * @notice Applies the remote chain updates\n     * @dev Bulk function that allows multiple updates at once\n     * @param config RemoteChainUpdate information\n     */\n    function applyAddChain(ITokenPool.ChainUpdate memory config) external {\n        enact(keccak256(abi.encode(\"addChain\", config)));\n        uint64[] memory chainsToRemove = new uint64[](0);\n        ITokenPool.ChainUpdate[] memory chainsToAdd = new ITokenPool.ChainUpdate[](1);\n        chainsToAdd[0] = config;\n        tokenPool.applyChainUpdates(chainsToRemove, chainsToAdd);\n        emit ChainAdded(config);\n    }\n\n    /**\n     * @notice Proposed a new admin for the TokenPool and Admin on the Token registry\n     * @dev Useful to transfer to a new CCIPAdmin contract\n     * @param newAdmin  The address of the new admin\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function proposeAdminTransfer(address newAdmin, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"adminTransfer\", newAdmin));\n        propose(hash, 21, helpers);\n        emit AdminTransferProposed(hash, msg.sender, newAdmin);\n    }\n\n    /**\n     * @notice Applies the admin transfer\n     * @dev Transfers admin on the TokenPool and ownership on the ZCHF token on the TokenAdminRegistry\n     * @param newAdmin The address of the new admin\n     */\n    function applyAdminTransfer(address newAdmin) external {\n        enact(keccak256(abi.encode(\"adminTransfer\", newAdmin)));\n        TOKEN_ADMIN_REGISTRY.transferAdminRole(ZCHF, newAdmin);\n        tokenPool.transferOwnership(newAdmin);\n        emit AdminTransfered(newAdmin);\n    }\n\n    /**\n     * @notice Denies and removes a pending proposal\n     * @dev Only qualified voters can deny proposals\n     * @param hash The hash of the proposal to deny\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function deny(bytes32 hash, address[] calldata helpers) external onlyQualified(helpers) {\n        if (proposals[hash] == 0) revert UnknownProposal(hash);\n        delete proposals[hash];\n        emit ProposalDenied(hash);\n    }\n\n    /**\n     * @notice Enacts a pending proposal\n     * @param hash The hash of the proposal to enact\n     */\n    function enact(bytes32 hash) internal {\n        uint64 deadline = proposals[hash];\n        if (deadline == 0) revert UnknownProposal(hash);\n        if (deadline > block.timestamp) revert TooEarly(deadline);\n        delete proposals[hash];\n        emit ProposalEnacted(hash);\n    }\n\n    /**\n     * @notice Creates a new proposal with a delay period\n     * @dev Only qualified voters can create proposals\n     * @param hash The hash of the proposal data\n     * @param delayInDays Number of days to delay the proposal execution\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function propose(bytes32 hash, uint64 delayInDays, address[] calldata helpers) internal onlyQualified(helpers) {\n        if (proposals[hash] > 0) revert ProposalAlreadyMade(hash);\n        proposals[hash] = uint64(block.timestamp) + delayInDays * DAY;\n        emit ProposalMade(hash, proposals[hash]);\n    }\n}\n"
    },
    "contracts/bridge/CCIPSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {IERC20} from \"../erc20/IERC20.sol\";\n\nabstract contract CCIPSender {\n    IRouterClient public immutable ROUTER;\n    address public immutable LINK;\n\n    error InsufficientFeeTokens(address token, uint256 fee);\n    error InsufficientFeeTokenAllowance(address token, uint256 fee);\n\n    constructor(IRouterClient _router, address _link) {\n        ROUTER = _router;\n        LINK = _link;\n    }\n\n    function _toReceiver(address target) internal pure returns (bytes memory) {\n        return abi.encode(target);\n    }\n\n    function _constructMessage(bytes memory _receiver, bytes memory _payload, Client.EVMTokenAmount[] memory _tokenAmounts, bytes memory _extraArgs) internal view returns (Client.EVM2AnyMessage memory) {\n        return Client.EVM2AnyMessage(_receiver, _payload, _tokenAmounts, _guessFeeToken(), _extraArgs);\n    }\n\n    function _constructMessage(bytes memory _receiver, bytes memory _payload, Client.EVMTokenAmount[] memory _tokenAmounts, bool nativeToken,  bytes memory _extraArgs) internal view returns (Client.EVM2AnyMessage memory) {\n        return Client.EVM2AnyMessage(_receiver, _payload, _tokenAmounts, nativeToken ? address(0) : LINK, _extraArgs);\n    }\n\n    function _calculateFee(uint64 chain, Client.EVM2AnyMessage memory message) internal view returns (uint256) {\n        return ROUTER.getFee(chain, message);\n    }\n\n    /**\n     * @dev External call to msg.sender if fees are paid in native token\n     */\n    function _send(uint64 chain, Client.EVM2AnyMessage memory _message) internal returns (bytes32, uint256) {\n        uint256 fee = _calculateFee(chain, _message);\n        bytes32 messageId;\n        if (_message.feeToken != address(0)) {\n            // We trust the feeToken to be not malicious.\n            // ROUTER.getFee() verifies that the feeToken is supported by CCIP and thus vetted.\n            if (IERC20(_message.feeToken).balanceOf(msg.sender) < fee) revert InsufficientFeeTokens(_message.feeToken, fee);\n            if (IERC20(_message.feeToken).allowance(msg.sender, address(this)) < fee) revert InsufficientFeeTokenAllowance(_message.feeToken, fee);\n            IERC20(_message.feeToken).transferFrom(msg.sender, address(this), fee);\n            IERC20(_message.feeToken).approve(address(ROUTER), fee);\n            messageId = ROUTER.ccipSend(chain, _message);\n        } else {\n            if (msg.value < fee) revert InsufficientFeeTokens(_message.feeToken, fee);\n            messageId = ROUTER.ccipSend{value: fee}(chain, _message);\n            payable(msg.sender).call{value: msg.value - fee}(\"\"); // return overpaid fee to sender\n        }\n        return (messageId, fee);\n    }\n\n    function _guessFeeToken() internal view returns (address) {\n        return (msg.value > 0) ? address(0) : LINK;\n    }\n}\n"
    },
    "contracts/bridge/Dependencies.sol": {
      "content": "import {BurnMintTokenPool} from \"@chainlink/contracts-ccip/src/v0.8/ccip/pools/BurnMintTokenPool.sol\";\nimport {TokenAdminRegistry} from \"@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/TokenAdminRegistry.sol\";"
    },
    "contracts/bridge/ITokenPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {RateLimiter} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol\";\n\ninterface ITokenPool {\n    \n    struct ChainUpdate {\n        uint64 remoteChainSelector; // Remote chain selector\n        bytes[] remotePoolAddresses; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n        bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n        RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n        RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    }\n\n    function addRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external;\n    function removeRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external;\n\n    function setChainRateLimiterConfig(\n        uint64 remoteChainSelectors,\n        RateLimiter.Config calldata outboundConfigs,\n        RateLimiter.Config calldata inboundConfigs\n    ) external;\n    \n    function applyChainUpdates(\n        uint64[] calldata remoteChainSelectorsToRemove,\n        ChainUpdate[] calldata chainsToAdd\n    ) external;\n\n    function acceptOwnership() external;\n    function transferOwnership(address to) external;\n}\n"
    },
    "contracts/equity/BridgeAccounting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {ITokenAdminRegistry} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/ITokenAdminRegistry.sol\";\nimport {TokenPool} from \"@chainlink/contracts-ccip/src/v0.8/ccip/pools/TokenPool.sol\";\nimport {IBasicFrankencoin} from \"../stablecoin/IBasicFrankencoin.sol\";\n\ncontract BridgeAccounting is CCIPReceiver {\n    IBasicFrankencoin public immutable ZCHF;\n    ITokenAdminRegistry public immutable TOKEN_ADMIN_REGISTRY;\n\n    event ReceivedProfits(uint256 amount);\n    event ReceivedLosses(uint256 losses);\n    event SenderAdded(uint64 indexed chain, bytes indexed sender);\n\n    error InvalidSender(uint64 chain, bytes sender);\n\n    constructor(IBasicFrankencoin zchf, ITokenAdminRegistry _registry, address router) CCIPReceiver(router) {\n        ZCHF = zchf;\n        TOKEN_ADMIN_REGISTRY = _registry;\n    }\n\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n        _validateSender(any2EvmMessage);\n\n        (uint256 profits, uint256 losses) = abi.decode(any2EvmMessage.data, (uint256, uint256));\n        if (profits > 0) {\n            _handleProfits();\n        }\n\n        if (losses > 0) {\n            _handleLosses(losses);\n        }\n    }\n\n    function _validateSender(Client.Any2EVMMessage memory any2EvmMessage) internal view {\n        TokenPool pool = TokenPool(TOKEN_ADMIN_REGISTRY.getPool(address(ZCHF)));\n        bytes memory expectedSender = pool.getRemoteToken(any2EvmMessage.sourceChainSelector);\n        if (keccak256(any2EvmMessage.sender) != keccak256(expectedSender)) {\n            revert InvalidSender(any2EvmMessage.sourceChainSelector, any2EvmMessage.sender);\n        }\n    }\n\n    function _handleProfits() internal {\n        // Use total balance to remove dust\n        uint256 balance = ZCHF.balanceOf(address(this));\n        ZCHF.collectProfits(address(this), balance);\n        emit ReceivedProfits(balance);\n    }\n\n    function _handleLosses(uint256 amount) internal {\n        ZCHF.coverLoss(address(this), amount); // to trigger the Loss event\n        // the BridgedFrankencoin already minted new tokens and made the minter whole.\n        // the tokens minted by the main Frankencoin are therefore a duplicate and need to be burned\n        // otherwise a loss would have double the impact\n        ZCHF.burn(amount); \n        emit ReceivedLosses(amount);\n    }\n}\n"
    },
    "contracts/equity/BridgedGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {SyncVote, SyncMessage} from \"./IGovernance.sol\";\nimport {Governance} from \"./Governance.sol\";\n\ncontract BridgedGovernance is CCIPReceiver, Governance {\n    uint64 public immutable MAINNET_CHAIN_SELECTOR;\n    address public immutable MAINNET_GOVERNANCE_ADDRESS;\n\n    mapping(address => uint256) private _votes;\n    uint256 private _totalVotes;\n\n    event MessageReceived(bytes32 messageId, uint64 sourceChain, uint256 totalVotes, SyncVote[] syncedVotes);\n\n    error InvalidSourceChain();\n    error InvalidSender();\n\n    constructor(address _router, uint64 _mainnetChainSelector, address _mainnetGovernanceAddress) CCIPReceiver(_router) {\n        MAINNET_CHAIN_SELECTOR = _mainnetChainSelector;\n        MAINNET_GOVERNANCE_ADDRESS = _mainnetGovernanceAddress;\n    }\n\n    /**\n     * @notice Get the number of votes held by a holder.\n     * @param holder The address to check.\n     */\n    function votes(address holder) public view override returns (uint256) {\n        return _votes[holder];\n    }\n\n    /**\n     * @notice Get the total number of votes.\n     */\n    function totalVotes() public view override returns (uint256) {\n        return _totalVotes;\n    }\n\n    /**\n     * @notice Required for frankencoin contract\n     */\n    function totalSupply() public view returns (uint256) {\n        return totalVotes();\n    }\n\n    /**\n     * @notice Process a received message.\n     * @param any2EvmMessage The message to process.\n     */\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n        if (any2EvmMessage.sourceChainSelector != MAINNET_CHAIN_SELECTOR) revert InvalidSourceChain();\n        if (abi.decode(any2EvmMessage.sender, (address)) != MAINNET_GOVERNANCE_ADDRESS) revert InvalidSender();\n\n        SyncMessage memory syncMessage = abi.decode(any2EvmMessage.data, (SyncMessage)); // abi-decoding of the sent text\n\n        _processSyncMessage(syncMessage);\n\n        emit MessageReceived({messageId: any2EvmMessage.messageId, sourceChain: any2EvmMessage.sourceChainSelector, totalVotes: syncMessage.totalVotes, syncedVotes: syncMessage.votes});\n    }\n\n    /**\n     * @notice Updates internal state with received message\n     * @param syncMessage The message to process.\n     */\n    function _processSyncMessage(SyncMessage memory syncMessage) internal {\n        _totalVotes = syncMessage.totalVotes;\n\n        // omitted unchecked optimization for readability\n        for (uint64 i = 0; i < syncMessage.votes.length; i++) {\n            SyncVote memory syncVote = syncMessage.votes[i];\n            _votes[syncVote.voter] = syncVote.votes;\n            delegate(syncVote.voter, syncVote.delegatee);\n        }\n    }\n}\n"
    },
    "contracts/equity/Equity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Governance.sol\";\nimport \"../stablecoin/Frankencoin.sol\";\nimport \"../utils/MathUtil.sol\";\nimport \"../erc20/IERC677Receiver.sol\";\n\n/**\n * @title Equity\n * @notice If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\n * weighted reserve pool shares gains veto power and can veto new proposals.\n */\ncontract Equity is Governance, ERC20PermitLight, MathUtil {\n    /**\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\n     *\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\n     *\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\n     * |          1000 |          3000 |             3 |         1000 |\n     * |       1000000 |       3000000 |           300 |        10000 |\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\n     *\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\n     */\n    uint32 public constant VALUATION_FACTOR = 3;\n\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\n\n    /**\n     * @notice The number of digits to store the average holding time of share tokens.\n     */\n    uint8 private constant TIME_RESOLUTION_BITS = 20;\n\n    /**\n     * @notice The minimum holding duration. You are not allowed to redeem your pool shares if you held them\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\n     * holding duration of your shares is only 55 days < 90 days.\n     */\n    uint256 public constant MIN_HOLDING_DURATION = 90 days << TIME_RESOLUTION_BITS; // Set to 5 for local testing\n\n    Frankencoin public immutable zchf;\n\n    /**\n     * @dev To track the total number of votes we need to know the number of votes at the anchor time and when the\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\n     * the total vote count 192 Bits. Given the sub-second resolution of 20 Bits, the implicit assumption is\n     * that the timestamp can always be stored in 44 Bits (i.e. it does not exceed half a million years). Further,\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed\n     *   192 - 60 - 44 - 20 = 68 Bits\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact,\n     * a limit of about 2**36 shares (that's about 2**96 Bits when taking into account the decimals) is imposed\n     * when minting. This means that the maximum supply is billions shares, which is could only be reached in\n     * a scenario with hyper inflation, in which case the stablecoin is worthless anyway.\n     */\n    uint192 private totalVotesAtAnchor; // Total number of votes at the anchor time, see comment on the um\n    uint64 private totalVotesAnchorTime; // 44 Bit for the time stamp, 20 Bit sub-second time resolution\n\n    /**\n     * @notice A time stamp in the past such that: votes = balance * (time passed since anchor was set)\n     */\n    mapping(address owner => uint64 timestamp) private voteAnchor; // 44 bits for time stamp, 20 subsecond resolution\n\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\n\n    constructor(Frankencoin zchf_) ERC20(18) {\n        zchf = zchf_;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Frankencoin Pool Share\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"FPS\";\n    }\n\n    /**\n     * @notice Returns the price of one FPS in ZCHF with 18 decimals precision.\n     */\n    function price() public view returns (uint256) {\n        uint256 equity = zchf.equity();\n        if (equity == 0 || totalSupply() == 0) {\n            return ONE_DEC18; // initial price is 1000 ZCHF for the first 1000 FPS\n        } else {\n            return (VALUATION_FACTOR * zchf.equity() * ONE_DEC18) / totalSupply();\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n        if (amount > 0) {\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\n            // their votes so everything falls nicely into place. Recipient votes should stay the same, but grow\n            // faster in the future, requiring an adjustment of the anchor.\n            uint256 roundingLoss = _adjustRecipientVoteAnchor(to, amount);\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\n            _adjustTotalVotes(from, amount, roundingLoss);\n        }\n    }\n\n    /**\n     * @notice Returns whether the given address is allowed to redeem FPS, which is the\n     * case after their average holding duration is larger than the required minimum.\n     */\n    function canRedeem(address owner) public view returns (bool) {\n        return _anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\n    }\n\n    /**\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\n     * @param from      sender\n     * @param amount    amount to be sent\n     */\n    function _adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n        uint64 time = _anchorTime();\n        uint256 lostVotes = from == address(0x0) ? 0 : (time - voteAnchor[from]) * amount;\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n        totalVotesAnchorTime = time;\n    }\n\n    /**\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\n     * votes does not change despite the higher balance.\n     * @param to        receiver address\n     * @param amount    amount to be received\n     * @return the number of votes lost due to rounding errors\n     */\n    function _adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256) {\n        if (to != address(0x0)) {\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 seconds\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\n            // new example anchor is only 21 / 11 = 1 second in the past\n            voteAnchor[to] = uint64(_anchorTime() - recipientVotes / newbalance);\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\n        } else {\n            // optimization for burn, vote anchor of null address does not matter\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Time stamp with some additional bits for higher resolution.\n     */\n    function _anchorTime() internal view returns (uint64) {\n        return uint64(block.timestamp << TIME_RESOLUTION_BITS);\n    }\n\n    /**\n     * @notice The relative voting power of the address.\n     * @return A percentage with 1e18 being 100%\n     */\n    function relativeVotes(address holder) external view returns (uint256) {\n        return (ONE_DEC18 * votes(holder)) / totalVotes();\n    }\n\n    /**\n     * @notice The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) public override view returns (uint256) {\n        return balanceOf(holder) * (_anchorTime() - voteAnchor[holder]);\n    }\n\n    /**\n     * @notice How long the holder already held onto their average FPS in seconds.\n     */\n    function holdingDuration(address holder) public view returns (uint256) {\n        return (_anchorTime() - voteAnchor[holder]) >> TIME_RESOLUTION_BITS;\n    }\n\n    /**\n     * @notice Total number of votes in the system.\n     */\n    function totalVotes() public override view returns (uint256) {\n        return totalVotesAtAnchor + totalSupply() * (_anchorTime() - totalVotesAnchorTime);\n    }\n\n    /**\n     * @notice Since quorum is rather low, it is important to have a way to prevent malicious minority holders\n     * from blocking the whole system. This method provides a way for the good guys to team up and destroy\n     * the bad guy's votes (at the cost of also reducing their own votes). This mechanism potentially\n     * gives full control over the system to whoever has 51% of the votes.\n     *\n     * Since this is a rather aggressive measure, delegation is not supported. Every holder must call this\n     * method on their own.\n     * @param targets   The target addresses to remove votes from\n     * @param votesToDestroy    The maximum number of votes the caller is willing to sacrifice\n     */\n    function kamikaze(address[] calldata targets, uint256 votesToDestroy) external {\n        uint256 budget = _reduceVotes(msg.sender, votesToDestroy);\n        uint256 destroyedVotes = 0;\n        for (uint256 i = 0; i < targets.length && destroyedVotes < budget; i++) {\n            destroyedVotes += _reduceVotes(targets[i], budget - destroyedVotes);\n        }\n        require(destroyedVotes > 0); // sanity check\n        totalVotesAtAnchor = uint192(totalVotes() - destroyedVotes - budget);\n        totalVotesAnchorTime = _anchorTime();\n    }\n\n    function _reduceVotes(address target, uint256 amount) internal returns (uint256) {\n        uint256 votesBefore = votes(target);\n        if (amount >= votesBefore) {\n            voteAnchor[target] = _anchorTime();\n            return votesBefore;\n        } else {\n            voteAnchor[target] = uint64(_anchorTime() - (votesBefore - amount) / balanceOf(target));\n            return votesBefore - votes(target);\n        }\n    }\n\n    /**\n     * @notice Call this method to obtain newly minted pool shares in exchange for Frankencoins.\n     * No allowance required (i.e. it is hardcoded in the Frankencoin token contract).\n     * Make sure to invest at least 10e-12 * market cap to avoid rounding losses.\n     *\n     * @dev If equity is close to zero or negative, you need to send enough ZCHF to bring equity back to 1000 ZCHF.\n     *\n     * @param amount            Frankencoins to invest\n     * @param expectedShares    Minimum amount of expected shares for frontrunning protection\n     */\n    function invest(uint256 amount, uint256 expectedShares) external returns (uint256) {\n        zchf.transferFrom(msg.sender, address(this), amount);\n        uint256 equity = zchf.equity();\n        require(equity >= MINIMUM_EQUITY, \"insuf equity\"); // ensures that the initial deposit is at least 1000 ZCHF\n\n        uint256 shares = _calculateShares(equity <= amount ? 0 : equity - amount, amount);\n        require(shares >= expectedShares);\n        _mint(msg.sender, shares);\n        emit Trade(msg.sender, int(shares), amount, price());\n\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\n        // the 36 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\n        require(totalSupply() <= type(uint96).max, \"total supply exceeded\");\n        return shares;\n    }\n\n    /**\n     * @notice Calculate shares received when investing Frankencoins\n     * @param investment    ZCHF to be invested\n     * @return shares to be received in return\n     */\n    function calculateShares(uint256 investment) external view returns (uint256) {\n        return _calculateShares(zchf.equity(), investment);\n    }\n\n    function _calculateShares(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 investmentExFees = (investment * 997) / 1000; // remove 0.3% fee\n        // Assign 1000 FPS for the initial deposit, calculate the amount otherwise\n        uint256 newTotalShares = capitalBefore < MINIMUM_EQUITY || totalShares == 0\n            ? totalShares + 1000 * ONE_DEC18\n            : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investmentExFees, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    /**\n     * @notice Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\n     * @return The amount of ZCHF transferred to the target\n     */\n    function redeem(address target, uint256 shares) external returns (uint256) {\n        return _redeemFrom(msg.sender, target, shares);\n    }\n\n    /**\n     * @notice Like redeem(...), but with an extra parameter to protect against frontrunning.\n     * @param expectedProceeds  The minimum acceptable redemption proceeds.\n     */\n    function redeemExpected(address target, uint256 shares, uint256 expectedProceeds) external returns (uint256) {\n        uint256 proceeds = _redeemFrom(msg.sender, target, shares);\n        require(proceeds >= expectedProceeds);\n        return proceeds;\n    }\n\n    /**\n     * @notice Redeem FPS based on an allowance from the owner to the caller.\n     * See also redeemExpected(...).\n     */\n    function redeemFrom(\n        address owner,\n        address target,\n        uint256 shares,\n        uint256 expectedProceeds\n    ) external returns (uint256) {\n        _useAllowance(owner, msg.sender, shares);\n        uint256 proceeds = _redeemFrom(owner, target, shares);\n        require(proceeds >= expectedProceeds);\n        return proceeds;\n    }\n\n    function _redeemFrom(address owner, address target, uint256 shares) internal returns (uint256) {\n        require(canRedeem(owner));\n        uint256 proceeds = calculateProceeds(shares);\n        _burn(owner, shares);\n        zchf.transfer(target, proceeds);\n        emit Trade(owner, -int(shares), proceeds, price());\n        return proceeds;\n    }\n\n    /**\n     * @notice Calculate ZCHF received when depositing shares\n     * @param shares number of shares we want to exchange for ZCHF,\n     *               in dec18 format\n     * @return amount of ZCHF received for the shares\n     */\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n        uint256 capital = zchf.equity();\n        uint256 reductionAfterFees = (shares * 997) / 1000;\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(totalShares - reductionAfterFees, totalShares)));\n        return capital - newCapital;\n    }\n\n    /**\n     * @notice If there is less than 1000 ZCHF in equity left (maybe even negative), the system is at risk\n     * and we should allow qualified FPS holders to restructure the system.\n     *\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\n     * Frankencoin system except for a group of small FPS holders who still believes in it and is willing to provide\n     * 2'000'000 ZCHF to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\n     * would be wrong to force them to share the other million with the passive FPS holders. Instead, they will get\n     * the possibility to bootstrap the system again owning 100% of all FPS shares.\n     *\n     * @param helpers          A list of addresses that delegate to the caller in incremental order\n     * @param addressesToWipe  A list of addresses whose FPS will be burned to zero\n     */\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) external {\n        require(zchf.equity() < MINIMUM_EQUITY);\n        checkQualified(msg.sender, helpers);\n        for (uint256 i = 0; i < addressesToWipe.length; i++) {\n            address current = addressesToWipe[i];\n            _burn(current, balanceOf(current));\n        }\n    }\n}\n"
    },
    "contracts/equity/FPSWrapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"../erc20/ERC20.sol\";\nimport \"../erc20/ERC20PermitLight.sol\";\nimport \"./Equity.sol\";\n\ncontract FPSWrapper is ERC20 {\n\n    Equity private immutable fps;\n\n    constructor(Equity fps_) ERC20(18){\n        fps = fps_;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Wrapped Frankencoin Pool Share\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"WFPS\";\n    }\n\n    // requires allowance\n    function wrap(uint256 amount) public {\n        depositFor(msg.sender, amount);\n    }\n\n    /**\n     * Same function as in openzeppelin ERC20Wrapper\n     * @dev Allow a user to deposit underlying tokens and mint the corresponding number of wrapped tokens.\n     */\n    function depositFor(address account, uint256 amount) public virtual returns (bool) {\n        fps.transferFrom(msg.sender, address(this), amount);\n        super._mint(account, amount);\n        return true;\n    }\n\n    function unwrap(uint256 amount) public {\n        withdrawTo(msg.sender, amount);\n    }\n\n    /**\n     * Same function as in openzeppelin ERC20Wrapper\n     * @dev Allow a user to burn a number of wrapped tokens and withdraw the corresponding number of underlying tokens.\n     */\n    function withdrawTo(address account, uint256 amount) public virtual returns (bool) {\n        super._burn(msg.sender, amount);\n        fps.transfer(account, amount);\n        return true;\n    }\n\n    /**\n     * @dev Returns the address of the underlying ERC-20 token that is being wrapped.\n     */\n    function underlying() public view returns (IERC20) {\n        return fps;\n    }\n\n    /**\n     * Sell immediately, bypassing the 90 day holding requirement if the\n     * average wrapped token has been around for long enough and no one\n     * cancelled the votes of this contract. Can help with market making\n     * between chains when this token is bridged.\n     * \n     * Anyone can prevent this method from being executable via the\n     * halveHoldingDuration function. Also, it won't be executable in an\n     * expanding market where the number of wrapped FPS doubles every\n     * 90 days such that the average holding period of this contract stays\n     * below that duration.\n     */\n    function unwrapAndSell(uint256 amount) public {\n        super._burn(msg.sender, amount);\n        fps.redeem(msg.sender, amount);\n    }\n\n    /**\n     * Reduces the recorded holding duration of the wrapped FPS. This has two effects:\n     * - Averts the risk of this contract accumulating too many votes over time (i.e. 98%)\n     * - Can prevent \"unwrapAndSell\" from succeeding (which can be desired to prevent short\n     *   term arbitrage at the cost of all other FPS holders)\n     * \n     * Anyone with 2% of the votes can call this.\n     */\n    function halveHoldingDuration(address[] calldata helpers) public {\n        fps.checkQualified(msg.sender, helpers);\n        // causes our votes to be cut in half\n        fps.transfer(address(this), totalSupply());\n    }\n\n}"
    },
    "contracts/equity/Governance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernance.sol\";\n\nabstract contract Governance is IGovernance {\n\n    /**\n     * @notice The quorum in basis points. 100 is 1%.\n     */\n    uint32 private constant QUORUM = 200;\n\n    /**\n     * @notice Keeping track on who delegated votes to whom.\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\n     */\n    mapping(address owner => address delegate) public delegates;\n\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\n\n    /**\n     * @notice The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) virtual public view returns (uint256);\n\n    /**\n     * @notice Total number of votes in the system.\n     */\n    function totalVotes() virtual public view returns (uint256);\n\n    /**\n     * @notice The number of votes the sender commands when taking the support of the helpers into account.\n     * @param sender    The address whose total voting power is of interest\n     * @param helpers   An incrementally sorted list of helpers without duplicates and without the sender.\n     *                  The call fails if the list contains an address that does not delegate to sender.\n     *                  For indirect delegates, i.e. a -> b -> c, both a and b must be included for both to count.\n     * @return          The total number of votes of sender at the current point in time.\n     */\n    function votesDelegated(address sender, address[] calldata helpers) public view returns (uint256) {\n        uint256 _votes = votes(sender);\n        require(_checkDuplicatesAndSorted(helpers));\n        for (uint i = 0; i < helpers.length; i++) {\n            address current = helpers[i];\n            require(current != sender);\n            require(_canVoteFor(sender, current));\n            _votes += votes(current);\n        }\n        return _votes;\n    }\n\n    function _checkDuplicatesAndSorted(address[] calldata helpers) internal pure returns (bool ok) {\n        if (helpers.length <= 1) {\n            return true;\n        } else {\n            address prevAddress = helpers[0];\n            for (uint i = 1; i < helpers.length; i++) {\n                if (helpers[i] <= prevAddress) {\n                    return false;\n                }\n                prevAddress = helpers[i];\n            }\n            return true;\n        }\n    }\n\n    /**\n     * @notice Checks whether the sender address is qualified given a list of helpers that delegated their votes\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\n     * helpes are necessary and to identify them by scanning the blockchain for Delegation events.\n     */\n    function checkQualified(address sender, address[] calldata helpers) public view override {\n        uint256 _votes = votesDelegated(sender, helpers);\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\n    }\n\n    error NotQualified();\n\n    /**\n     * @notice Increases the voting power of the delegate by your number of votes without taking away any voting power\n     * from the sender.\n     */\n    function delegateVoteTo(address delegate_) external {\n        delegate(msg.sender, delegate_);\n    }\n\n    function delegate(address owner, address delegate_) internal {\n        delegates[owner] = delegate_;\n        emit Delegation(owner, delegate_);\n    }\n\n    function _canVoteFor(address delegate_, address owner) internal view returns (bool) {\n        if (owner == delegate_) {\n            return true;\n        } else if (owner == address(0x0)) {\n            return false;\n        } else {\n            return _canVoteFor(delegate_, delegates[owner]);\n        }\n    }\n\n}"
    },
    "contracts/equity/GovernanceSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {SyncVote, SyncMessage} from \"./IGovernance.sol\";\nimport {Governance} from \"./Governance.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {IERC20} from \"../erc20/IERC20.sol\";\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\n\ncontract GovernanceSender is CCIPSender {\n    Governance public immutable GOVERNANCE;\n\n    event VotesSynced(\n        uint64 indexed chain, // The chain selector of the destination chain.\n        bytes receiver,\n        address[] syncedVoters\n    );\n\n    constructor(Governance _governance, IRouterClient _router, address _linkToken) CCIPSender(_router, _linkToken) {\n        GOVERNANCE = _governance;\n    }\n\n    function syncVotes(uint64 chain, address _receiver, address[] calldata _voters) external payable {\n        syncVotes(chain, _toReceiver(_receiver), _voters, \"\");\n    }\n\n    function syncVotes(uint64 chain, address _receiver, address[] calldata _voters, Client.EVMExtraArgsV2 calldata _extraArgs) public payable {\n        syncVotes(chain, _toReceiver(_receiver), _voters, Client._argsToBytes(_extraArgs));\n    }\n\n    /**\n     * @notice Sync governance votes to destination paying with native token\n     * @dev extraArgs for CCIP can be provided such as gasLimit or out-of-order execution\n     *\n     * @param _receiver                 Address of the recipient on the destination chain\n     * @param chain Chain selector of the destination chain\n     * @param _voters                   Collection of addresses which votes and delegation should be synced\n     *\n     */\n    function syncVotes(uint64 chain, bytes memory _receiver, address[] calldata _voters, bytes memory _extraArgs) public payable {\n        SyncMessage memory syncMessage = _buildSyncMessage(_voters);\n        Client.EVM2AnyMessage memory message = _constructMessage(_receiver, abi.encode(syncMessage), new Client.EVMTokenAmount[](0), _extraArgs);\n        _send(chain, message);\n        emit VotesSynced(chain, _receiver, _voters);\n    }\n\n    function getSyncFee(uint64 chain, address _receiver, address[] calldata _voters, bool useNativeToken) external view returns (uint256) {\n        return getSyncFee(chain, _toReceiver(_receiver), _voters, useNativeToken, \"\");\n    }\n\n    function getSyncFee(uint64 chain, address _receiver, address[] calldata _voters, bool useNativeToken, Client.EVMExtraArgsV2 calldata extraArgs) external view returns (uint256) {\n        return getSyncFee(chain, _toReceiver(_receiver), _voters, useNativeToken, Client._argsToBytes(extraArgs));\n    }\n\n    /**\n     * @notice Get the fee required to send a CCIP message.\n     * @param chain The selector of the destination chain.\n     * @param _voters                   Collection of addresses which votes and delegation should be synced\n     *\n     * @return uint256 The fee required to send the CCIP message.\n     */\n    function getSyncFee(uint64 chain, bytes memory _receiver, address[] calldata _voters, bool nativeToken, bytes memory extraArgs) public view returns (uint256) {\n        SyncMessage memory syncMessage = _buildSyncMessage(_voters);\n        Client.EVM2AnyMessage memory message = _constructMessage(_receiver, abi.encode(syncMessage), new Client.EVMTokenAmount[](0), nativeToken, extraArgs);\n        return _calculateFee(chain, message);\n    }\n\n    /**\n     * @notice Builds the CCIP payload to be sent\n     * @dev Gets the necessary information for voters from governance\n     * @param _voters           Voters to be synced\n     *\n     * @return SyncMessage The payload to be sent\n     */\n    function _buildSyncMessage(address[] calldata _voters) private view returns (SyncMessage memory) {\n        SyncVote[] memory _syncVotes = new SyncVote[](_voters.length);\n\n        // omitted unchecked optimization for readability\n        for (uint256 i = 0; i < _voters.length; i++) {\n            _syncVotes[i] = SyncVote({voter: _voters[i], votes: GOVERNANCE.votes(_voters[i]), delegatee: GOVERNANCE.delegates(_voters[i])});\n        }\n\n        return SyncMessage({votes: _syncVotes, totalVotes: GOVERNANCE.totalVotes()});\n    }\n}\n"
    },
    "contracts/equity/IGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGovernance {\n   function checkQualified(address sender, address[] calldata helpers) external view;\n}\n\nstruct SyncVote {\n    address voter;\n    uint256 votes;\n    address delegatee;\n}\n\nstruct SyncMessage {\n    SyncVote[] votes;\n    uint256 totalVotes;\n}\n"
    },
    "contracts/erc20/CrossChainERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\n\nabstract contract CrossChainERC20 is ERC20, CCIPSender {\n    event Transfer(address indexed from, uint64 toChain, bytes indexed to, uint256 value);\n\n    constructor(address router, address linkToken) CCIPSender(IRouterClient(router), linkToken) {}\n\n    function transfer(uint64 targetChain, address target, uint256 amount) external payable {\n        transfer(targetChain, _toReceiver(target), amount, \"\");\n    }\n\n    function transfer(uint64 targetChain, address target, uint256 amount, Client.EVMExtraArgsV2 calldata extraArgs) external payable {\n        transfer(targetChain, _toReceiver(target), amount, Client._argsToBytes(extraArgs));\n    }\n\n    function transfer(uint64 targetChain, bytes memory target, uint256 amount, bytes memory extraArgs) public payable {\n        _transfer(msg.sender, address(this), amount);\n        _approve(address(this), address(ROUTER), amount);\n        _send(targetChain, constructTransferMessage(target, amount, extraArgs));\n        emit Transfer(msg.sender, targetChain, target, amount);\n    }\n\n    /// @notice Construct a CCIP message.\n    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for tokens transfer.\n    /// @param receiver The address of the receiver.\n    /// @param amount The amount of the token to be transferred.\n    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.\n    function constructTransferMessage(bytes memory receiver, uint256 amount, bytes memory extraArgs) private view returns (Client.EVM2AnyMessage memory) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        tokenAmounts[0] = Client.EVMTokenAmount(address(this), amount);\n        return _constructMessage(receiver, \"\", tokenAmounts, extraArgs);\n    }\n}\n"
    },
    "contracts/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied and adjusted from OpenZeppelin\n// Adjustments:\n// - modifications to support ERC-677\n// - removed require messages to save space\n// - removed unnecessary require statements\n// - removed GSN Context\n// - upgraded to 0.8 to drop SafeMath\n// - let name() and symbol() be implemented by subclass\n// - infinite allowance support, with 2^255 and above considered infinite\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC677Receiver.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n */\n\nabstract contract ERC20 is IERC20 {\n    mapping(address account => uint256 balance) private _balances;\n\n    mapping(address account => mapping(address spender => uint256 allowance)) private _allowances;\n\n    uint256 internal constant INFINITY = (1 << 255);\n\n    uint256 private _totalSupply;\n\n    uint8 public immutable override decimals;\n\n    // Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4139/files#diff-fa792f7d08644eebc519dac2c29b00a54afc4c6a76b9ef3bba56c8401fe674f6\n    // Indicates an error related to the current balance of a sender. Used in transfers.\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n    // Indicates a failure with the spender’s allowance. Used in transfers.\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    constructor(uint8 _decimals) {\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowance(owner, spender);\n    }\n\n    function _allowance(address owner, address spender) internal view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _useAllowance(sender, msg.sender, amount);\n        return true;\n    }\n\n    function _useAllowance(address owner, address spender, uint256 amount) internal {\n        uint256 currentAllowance = _allowance(owner, spender);\n        if (currentAllowance < INFINITY) {\n            // Only decrease the allowance if it was not set to 'infinite'\n            // Documented in github.com/aktionariat/contracts/blob/master/doc/infiniteallowance.md\n            if (currentAllowance < amount) revert ERC20InsufficientAllowance(owner, currentAllowance, amount);\n            _approve(owner, spender, currentAllowance - amount);\n        }\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(sender, recipient, amount);\n        if (_balances[sender] < amount) revert ERC20InsufficientBalance(sender, _balances[sender], amount);\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(address(0), recipient, amount);\n\n        _totalSupply += amount;\n        _balances[recipient] += amount;\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _totalSupply -= amount;\n        _balances[account] -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/erc20/ERC20PermitLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract ERC20PermitLight is ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address account => uint256 nonce) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        unchecked {\n            // unchecked to save a little gas with the nonce increment...\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n                                bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    //keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n                    bytes32(0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}\n"
    },
    "contracts/erc20/IERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: MIT\n *\n * Copyright (c) 2016-2019 zOS Global Limited\n *\n */\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value can change when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/erc20/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677Receiver {\n    \n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}"
    },
    "contracts/minting/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\n\ninterface IPosition {\n\n    function initialize(address parent, uint40 _expiration) external;\n\n    function hub() external view returns(address);\n\n    function original() external view returns (address);\n\n    function collateral() external view returns (IERC20);\n\n    function minimumCollateral() external view returns (uint256);\n\n    function challengePeriod() external view returns (uint40);\n\n    function expiration() external view returns (uint40);\n\n    function price() external view returns (uint256);\n\n    function deny(address[] calldata helpers, string calldata message) external;\n\n    function mint(address target, uint256 amount) external;\n\n    function repay(uint256 amount) external returns (uint256);\n\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) external;\n\n    function minted() external view returns (uint256);\n\n    function availableForMinting() external view returns (uint256);\n\n    function reserveContribution() external view returns (uint24);\n\n    function withdrawCollateral(address target, uint256 amount) external;\n\n    function getUsableMint(uint256 totalMint, bool beforeFees) external view returns (uint256);\n\n    function getMintAmount(uint256 usableMint) external view returns (uint256);\n\n    function challengeData() external view returns (uint256 liqPrice, uint40 phase);\n\n    function notifyChallengeStarted(uint256 size) external;\n\n    function notifyChallengeAverted(uint256 size) external;\n\n    function notifyChallengeSucceeded(address _bidder, uint256 _size) external returns (address, uint256, uint256, uint32);\n\n    function forceSale(address buyer, uint256 collAmount, uint256 proceeds) external;\n\n}"
    },
    "contracts/minting/IPositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint40 _initPeriodSeconds,\n        uint40 _duration,\n        uint40 _challengePeriod,\n        uint24 _riskPremiumPPM,\n        uint256 _liqPrice,\n        uint24 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _existing) external returns (address);\n}\n"
    },
    "contracts/minting/MintingHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../rate/ILeadrate.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../minting/IPositionFactory.sol\";\nimport \"./PositionRoller.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @title Minting Hub\n * @notice The central hub for creating, cloning and challenging collateralized Frankencoin positions.\n * @dev Only one instance of this contract is required, whereas every new position comes with a new position\n * contract. Pending challenges are stored as structs in an array.\n */\ncontract MintingHub {\n    /**\n     * @notice Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\n     */\n    uint256 public constant OPENING_FEE = 1000 * 10 ** 18;\n\n    /**\n     * @notice The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\n     */\n    uint256 public constant CHALLENGER_REWARD = 20000; // 2%\n    uint256 public constant EXPIRED_PRICE_FACTOR = 10;\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IFrankencoin public immutable zchf; // currency\n    PositionRoller public immutable roller; // helper to roll positions\n    ILeadrate public immutable rate; // to determine the interest rate\n\n    Challenge[] public challenges; // list of open challenges\n\n    /**\n     * @notice Map to remember pending postponed collateral returns.\n     * @dev It maps collateral => beneficiary => amount.\n     */\n    mapping(address collateral => mapping(address owner => uint256 amount)) public pendingReturns;\n\n    struct Challenge {\n        address challenger; // the address from which the challenge was initiated\n        uint40 start; // the start of the challenge\n        IPosition position; // the position that was challenged\n        uint256 size; // how much collateral the challenger provided\n    }\n\n    event PositionOpened(address indexed owner, address indexed position, address original, address collateral);\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n    event ChallengeAverted(address indexed position, uint256 number, uint256 size);\n    event ChallengeSucceeded(\n        address indexed position,\n        uint256 number,\n        uint256 bid,\n        uint256 acquiredCollateral,\n        uint256 challengeSize\n    );\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\n    event ForcedSale(address pos, uint256 amount, uint256 priceE36MinusDecimals);\n\n    error UnexpectedPrice();\n    error InvalidPos();\n    error IncompatibleCollateral();\n    error InsufficientCollateral();\n\n    modifier validPos(address position) {\n        if (zchf.getPositionParent(position) != address(this)) revert InvalidPos();\n        _;\n    }\n\n    constructor(address _zchf, address _leadrate, address _roller, address _factory) {\n        zchf = IFrankencoin(_zchf);\n        rate = ILeadrate(_leadrate);\n        POSITION_FACTORY = IPositionFactory(_factory);\n        roller = PositionRoller(_roller);\n    }\n\n    /**\n     * @notice Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\n     * @dev For a successful call, you must set an allowance for the collateral token, allowing\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\n     * withdraw the fees.\n     *\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _riskPremium       ppm of minted amount that is added to the applicible minting fee as a risk premium\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\n     *                           e.g. 18 decimals for an 18 dec collateral, 36 decs for a 0 dec collateral.\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\n     * @return address           address of created position\n     */\n    function openPosition(\n        address _collateralAddress,\n        uint256 _minCollateral,\n        uint256 _initialCollateral,\n        uint256 _mintingMaximum,\n        uint40 _initPeriodSeconds,\n        uint40 _expirationSeconds,\n        uint40 _challengeSeconds,\n        uint24 _riskPremium,\n        uint256 _liqPrice,\n        uint24 _reservePPM\n    ) public returns (address) {\n        {\n            require(_riskPremium <= 1000000);\n            require(CHALLENGER_REWARD <= _reservePPM && _reservePPM <= 1000000);\n            require(IERC20(_collateralAddress).decimals() <= 24); // leaves 12 digits for price\n            uint256 invalidAmount = IERC20(_collateralAddress).totalSupply() + 1;\n            try IERC20(_collateralAddress).transfer(address(0x123), invalidAmount) {\n                revert IncompatibleCollateral(); // we need a collateral that reverts on failed transfers\n            } catch Error(string memory /*reason*/) {\n            } catch Panic(uint /*errorCode*/) {\n            } catch (bytes memory /*lowLevelData*/) {\n            }\n            if (_initialCollateral < _minCollateral) revert InsufficientCollateral();\n            if (_minCollateral * _liqPrice < 5000 ether * 10 ** 18) revert InsufficientCollateral(); // must start with at least 5000 ZCHF worth of collateral\n        }\n        IPosition pos = IPosition(\n            POSITION_FACTORY.createNewPosition(\n                msg.sender,\n                address(zchf),\n                _collateralAddress,\n                _minCollateral,\n                _mintingMaximum,\n                _initPeriodSeconds,\n                _expirationSeconds,\n                _challengeSeconds,\n                _riskPremium,\n                _liqPrice,\n                _reservePPM\n            )\n        );\n        zchf.registerPosition(address(pos));\n        zchf.collectProfits(msg.sender, OPENING_FEE);\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n        emit PositionOpened(msg.sender, address(pos), address(pos), _collateralAddress);\n        return address(pos);\n    }\n\n   function clone(address parent, uint256 _initialCollateral, uint256 _initialMint, uint40 expiration) public returns (address) {\n        return clone(msg.sender, parent, _initialCollateral, _initialMint, expiration);\n   }\n\n    /**\n     * @notice Clones an existing position and immediately tries to mint the specified amount using the given collateral.\n     * @dev This needs an allowance to be set on the collateral contract such that the minting hub can get the collateral.\n     */\n    function clone(address owner, address parent, uint256 _initialCollateral, uint256 _initialMint, uint40 expiration) public validPos(parent) returns (address) {\n        address pos = POSITION_FACTORY.clonePosition(parent);\n        IPosition child = IPosition(pos);\n        child.initialize(parent, expiration);\n        zchf.registerPosition(pos);\n        IERC20 collateral = child.collateral();\n        if (_initialCollateral < child.minimumCollateral()) revert InsufficientCollateral();\n        collateral.transferFrom(msg.sender, pos, _initialCollateral); // collateral must still come from sender for security\n        emit PositionOpened(owner, address(pos), parent, address(collateral));\n        child.mint(owner, _initialMint);\n        Ownable(address(child)).transferOwnership(owner);\n        return address(pos);\n    }\n\n    /**\n     * @notice Launch a challenge (Dutch auction) on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  amount of the collateral we want to challenge\n     * @param minimumPrice       position.price() to guard against the minter fruntrunning with a price change\n     * @return index of the challenge in challenge-array\n     */\n    function challenge(\n        address _positionAddr,\n        uint256 _collateralAmount,\n        uint256 minimumPrice\n    ) external validPos(_positionAddr) returns (uint256) {\n        IPosition position = IPosition(_positionAddr);\n        // challenger should be ok if frontrun by owner with a higher price\n        // in case owner fruntruns challenger with small price decrease to prevent challenge,\n        // the challenger should set minimumPrice to market price\n        if (position.price() < minimumPrice) revert UnexpectedPrice(); \n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n        uint256 pos = challenges.length;\n        challenges.push(Challenge(msg.sender, uint40(block.timestamp), position, _collateralAmount));\n        position.notifyChallengeStarted(_collateralAmount);\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n        return pos;\n    }\n\n    /**\n     * @notice Post a bid in ZCHF given an open challenge.\n     *\n     * @dev In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token\n     * has a blacklist and the challenger is on it), it is possible to postpone the return of the collateral.\n     *\n     * @param _challengeNumber  index of the challenge as broadcast in the event\n     * @param size              how much of the collateral the caller wants to bid for at most\n     *                          (automatically reduced to the available amount)\n     * @param postponeCollateralReturn To postpone the return of the collateral to the challenger. Usually false.\n     */\n    function bid(uint32 _challengeNumber, uint256 size, bool postponeCollateralReturn) external {\n        Challenge memory _challenge = challenges[_challengeNumber];\n        (uint256 liqPrice, uint40 phase) = _challenge.position.challengeData();\n        size = _challenge.size < size ? _challenge.size : size; // cannot bid for more than the size of the challenge\n\n        if (block.timestamp <= _challenge.start + phase) {\n            _avertChallenge(_challenge, _challengeNumber, liqPrice, size);\n            emit ChallengeAverted(address(_challenge.position), _challengeNumber, size);\n        } else {\n            _returnChallengerCollateral(_challenge, _challengeNumber, size, postponeCollateralReturn);\n            (uint256 transferredCollateral, uint256 offer) = _finishChallenge(_challenge, liqPrice, phase, size);\n            emit ChallengeSucceeded(address(_challenge.position), _challengeNumber, offer, transferredCollateral, size);\n        }\n    }\n\n    function _finishChallenge(Challenge memory _challenge, uint256 liqPrice, uint40 phase, uint256 size) internal returns (uint256, uint256) {\n        // Repayments depend on what was actually minted, whereas bids depend on the available collateral\n        (address owner, uint256 collateral, uint256 repayment, uint32 reservePPM) = _challenge.position.notifyChallengeSucceeded(msg.sender, size);\n\n        // No overflow possible thanks to invariant (col * price <= limit * 10**18)\n        // enforced in Position.setPrice and knowing that collateral <= col.\n        uint256 offer = (_calculatePrice(_challenge.start + phase, phase, liqPrice) * collateral) / 10 ** 18;\n        zchf.transferFrom(msg.sender, address(this), offer); // get money from bidder\n        uint256 reward = (offer * CHALLENGER_REWARD) / 1000_000;\n        zchf.transfer(_challenge.challenger, reward); // pay out the challenger reward\n        uint256 fundsAvailable = offer - reward; // funds available after reward\n\n        // Example: available funds are 90, repayment is 50, reserve 20%. Then 20%*(90-50)=16 are collected as profits\n        // and the remaining 34 are sent to the position owner. If the position owner maxed out debt before the challenge\n        // started and the liquidation price was 100, they would be slightly better off as they would get away with 80\n        // instead of 40+36 = 76 in this example.\n        if (fundsAvailable > repayment) {\n            // The excess amount is distributed between the system and the owner using the reserve ratio\n            // At this point, we cannot rely on the liquidation price because the challenge might have been started as a\n            // response to an unreasonable increase of the liquidation price, such that we have to use this heuristic\n            // for excess fund distribution, which make position owners that maxed out their positions slightly better\n            // off in comparison to those who did not.\n            uint256 profits = (reservePPM * (fundsAvailable - repayment)) / 1000_000;\n            zchf.collectProfits(address(this), profits);\n            zchf.transfer(owner, fundsAvailable - repayment - profits);\n        } else if (fundsAvailable < repayment) {\n            zchf.coverLoss(address(this), repayment - fundsAvailable); // ensure we have enough to pay everything\n        }\n        zchf.burnWithoutReserve(repayment, reservePPM); // Repay the challenged part, example: 50 ZCHF leading to 10 ZCHf in implicit profits\n        return (collateral, offer);\n    }\n\n    function _avertChallenge(Challenge memory _challenge, uint32 number, uint256 liqPrice, uint256 size) internal {\n        require(block.timestamp != _challenge.start); // do not allow to avert the challenge in the same transaction, see CS-ZCHF-037\n        if (msg.sender == _challenge.challenger) {\n            // allow challenger to cancel challenge without paying themselves\n        } else {\n            zchf.transferFrom(msg.sender, _challenge.challenger, (size * liqPrice) / (10 ** 18));\n        }\n\n        _challenge.position.notifyChallengeAverted(size);\n        _challenge.position.collateral().transfer(msg.sender, size);\n        if (size < _challenge.size) {\n            challenges[number].size = _challenge.size - size;\n        } else {\n            require(size == _challenge.size);\n            delete challenges[number];\n        }\n    }\n\n    /**\n     * @notice Returns 'amount' of the collateral to the challenger and reduces or deletes the relevant challenge.\n     */\n    function _returnChallengerCollateral(\n        Challenge memory _challenge,\n        uint32 number,\n        uint256 amount,\n        bool postpone\n    ) internal {\n        _returnCollateral(_challenge.position.collateral(), _challenge.challenger, amount, postpone);\n        if (_challenge.size == amount) {\n            // bid on full amount\n            delete challenges[number];\n        } else {\n            // bid on partial amount\n            challenges[number].size -= amount;\n        }\n    }\n\n    /**\n     * @notice Calculates the current Dutch auction price.\n     * @dev Starts at the full price at time 'start' and linearly goes to 0 as 'phase2' passes.\n     */\n    function _calculatePrice(uint40 start, uint40 phase2, uint256 liqPrice) internal view returns (uint256) {\n        uint40 timeNow = uint40(block.timestamp);\n        if (timeNow <= start) {\n            return liqPrice;\n        } else if (timeNow >= start + phase2) {\n            return 0;\n        } else {\n            uint256 timeLeft = phase2 - (timeNow - start);\n            return (liqPrice / phase2) * timeLeft;\n        }\n    }\n\n    /**\n     * @notice Get the price per unit of the collateral for the given challenge.\n     * @dev The price comes with (36-collateral.decimals()) digits, such that multiplying it with the\n     * raw collateral amount always yields a price with 36 digits, or 18 digits after dividing by 10**18 again.\n     */\n    function price(uint32 challengeNumber) public view returns (uint256) {\n        Challenge memory _challenge = challenges[challengeNumber];\n        if (_challenge.challenger == address(0x0)) {\n            return 0;\n        } else {\n            (uint256 liqPrice, uint40 phase) = _challenge.position.challengeData();\n            return _calculatePrice(_challenge.start + phase, phase, liqPrice);\n        }\n    }\n\n    /**\n     * @notice Challengers can call this method to withdraw collateral whose return was postponed.\n     */\n    function returnPostponedCollateral(address collateral, address target) external {\n        uint256 amount = pendingReturns[collateral][msg.sender];\n        delete pendingReturns[collateral][msg.sender];\n        IERC20(collateral).transfer(target, amount);\n    }\n\n    function _returnCollateral(IERC20 collateral, address recipient, uint256 amount, bool postpone) internal {\n        if (postpone) {\n            // Postponing helps in case the challenger was blacklisted or otherwise cannot receive at the moment.\n            pendingReturns[address(collateral)][recipient] += amount;\n            emit PostPonedReturn(address(collateral), recipient, amount);\n        } else {\n            collateral.transfer(recipient, amount); // return the challenger's collateral\n        }\n    }\n\n    /**\n     * The applicable purchase price when forcing the sale of collateral of an expired position.\n     * \n     * The price starts at 10x the liquidation price at the expiration time, linearly declines to\n     * 1x liquidation price over the course of one challenge period, and then linearly declines\n     * less steeply to 0 over the course of another challenge period.\n     */\n    function expiredPurchasePrice(IPosition pos) public view returns (uint256) {\n        uint256 liqprice = pos.price();\n        uint256 expiration = pos.expiration();\n        if (block.timestamp <= expiration) {\n            return EXPIRED_PRICE_FACTOR * liqprice;\n        } else {\n            uint256 challengePeriod = pos.challengePeriod();\n            uint256 timePassed = block.timestamp - expiration;\n            if (timePassed <= challengePeriod) {\n                // from 10x liquidation price to 1x in first phase\n                uint256 timeLeft = challengePeriod - timePassed;\n                return liqprice + (((EXPIRED_PRICE_FACTOR - 1) * liqprice) / challengePeriod) * timeLeft;\n            } else if (timePassed < 2 * challengePeriod) {\n                // from 1x liquidation price to 0 in second phase\n                uint256 timeLeft = 2 * challengePeriod - timePassed;\n                return (liqprice / challengePeriod) * timeLeft;\n            } else {\n                // get collateral for free after both phases passed\n                return 0;\n            }\n        }\n    }\n\n    /**\n     * Buys up to the desired amount of the collateral asset from the given expired position using\n     * the applicable 'expiredPurchasePrice' in that instant.\n     */\n    function buyExpiredCollateral(IPosition pos, uint256 upToAmount) external returns (uint256) {\n        uint256 max = pos.collateral().balanceOf(address(pos));\n        uint256 amount = upToAmount > max ? max : upToAmount;\n        uint256 forceSalePrice = expiredPurchasePrice(pos);\n        uint256 costs = (forceSalePrice * amount) / 10 ** 18;\n        pos.forceSale(msg.sender, amount, costs);\n        emit ForcedSale(address(pos), amount, forceSalePrice);\n        return amount;\n    }\n}\n"
    },
    "contracts/minting/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/Ownable.sol\";\nimport \"../utils/MathUtil.sol\";\n\nimport \"../erc20/IERC20.sol\";\nimport \"../rate/ILeadrate.sol\";\nimport \"./IPosition.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\n\n// import \"hardhat/console.sol\";\n\n/**\n * @title Position\n * @notice A collateralized minting position.\n */\ncontract Position is Ownable, IPosition, MathUtil {\n    /**\n     * @notice Note that this contract is intended to be cloned. All clones will share the same values for\n     * the constant and immutable fields, but have their own values for the other fields.\n     */\n\n    /**\n     * @notice The zchf price per unit of the collateral below which challenges succeed, (36 - collateral.decimals) decimals\n     */\n    uint256 public price;\n\n    /**\n     * @notice Net minted amount, including reserve.\n     */\n    uint256 public minted;\n\n    /**\n     * @notice How much has been minted in total. This variable is only used in the parent position.\n     */\n    uint256 private totalMinted;\n\n    uint256 public immutable limit;\n\n    /**\n     * @notice Amount of the collateral that is currently under a challenge.\n     * Used to figure out whether there are pending challenges.\n     */\n    uint256 public challengedAmount;\n\n    /**\n     * @notice Challenge period in seconds.\n     */\n    uint40 public immutable challengePeriod;\n\n    /**\n     * @notice Timestamp when minting can start and the position no longer denied.\n     */\n    uint40 public immutable start;\n\n    /**\n     * @notice End of the latest cooldown. If this is in the future, minting is suspended.\n     */\n    uint40 public cooldown;\n\n    /**\n     * @notice Timestamp of the expiration of the position. After expiration, challenges cannot be averted\n     * any more. This is also the basis for fee calculations.\n     */\n    uint40 public expiration;\n\n    bool private closed;\n\n    /**\n     * @notice The original position to help identifying clones.\n     */\n    address public immutable original;\n\n    /**\n     * @notice Pointer to the minting hub.\n     */\n    address public immutable hub;\n\n    /**\n     * @notice The Frankencoin contract.\n     */\n    IFrankencoin public immutable zchf;\n\n    /**\n     * @notice The collateral token.\n     */\n    IERC20 public immutable override collateral;\n\n    /**\n     * @notice Minimum acceptable collateral amount to prevent dust.\n     */\n    uint256 public immutable override minimumCollateral;\n\n    /**\n     * @notice The interest in parts per million per year that is deducted when minting Frankencoins.\n     * To be paid upfront.\n     */\n    uint24 public immutable riskPremiumPPM;\n\n    /**\n     * @notice The reserve contribution in parts per million of the minted amount.\n     */\n    uint24 public immutable reserveContribution;\n\n    event MintingUpdate(uint256 collateral, uint256 price, uint256 minted);\n    event PositionDenied(address indexed sender, string message); // emitted if closed by governance\n\n    error InsufficientCollateral(uint256 needed, uint256 available);\n    error TooLate();\n    error RepaidTooMuch(uint256 excess);\n    error LimitExceeded(uint256 tried, uint256 available);\n    error ChallengeTooSmall();\n    error Expired(uint40 time, uint40 expiration);\n    error Alive();\n    error Closed();\n    error Hot();\n    error PriceIncreaseTooHigh(uint256 maxPrice, uint256 whatWasTried);\n    error Challenged();\n    error NotHub();\n    error NotOriginal();\n    error InvalidExpiration();\n    error AlreadyInitialized();\n\n    modifier alive() {\n        if (block.timestamp >= expiration) revert Expired(uint40(block.timestamp), expiration);\n        _;\n    }\n\n    // requires that the position has always been backed by a minimal amount of collateral\n    modifier backed() {\n        if (isClosed()) revert Closed();\n        _;\n    }\n\n    modifier expired() {\n        if (block.timestamp < expiration) revert Alive();\n        _;\n    }\n\n    modifier noCooldown() {\n        if (block.timestamp <= cooldown) revert Hot();\n        _;\n    }\n\n    modifier noChallenge() {\n        if (challengedAmount > 0) revert Challenged();\n        _;\n    }\n\n    modifier onlyHub() {\n        if (msg.sender != address(hub)) revert NotHub();\n        _;\n    }\n\n    modifier ownerOrRoller() {\n        if (msg.sender != address(IHub(hub).roller())) _requireOwner(msg.sender);\n        _;\n    }\n\n    /**\n     * @dev See MintingHub.openPosition\n     */\n    constructor(address _owner, address _hub, address _zchf, address _collateral,\n        uint256 _minCollateral, uint256 _initialLimit,\n        uint40 _initPeriod, uint40 _duration, uint40 _challengePeriod,\n        uint24 _riskPremiumPPM, uint256 _liqPrice, uint24 _reservePPM) {\n        require(_initPeriod >= 3 days); // must be at least three days, recommended to use higher values\n        _setOwner(_owner);\n        original = address(this);\n        hub = _hub;\n        zchf = IFrankencoin(_zchf);\n        collateral = IERC20(_collateral);\n        riskPremiumPPM = _riskPremiumPPM;\n        reserveContribution = _reservePPM;\n        minimumCollateral = _minCollateral;\n        challengePeriod = _challengePeriod;\n        start = uint40(block.timestamp) + _initPeriod; // at least three days time to deny the position\n        cooldown = start;\n        expiration = start + _duration;\n        limit = _initialLimit;\n        _setPrice(_liqPrice, _initialLimit);\n    }\n\n    /**\n     * Initialization method for clones.\n     * Can only be called once. Should be called immediately after creating the clone.\n     */\n    function initialize(address parent, uint40 _expiration) external onlyHub {\n        if (expiration != 0) revert AlreadyInitialized();\n        if (_expiration < block.timestamp || _expiration > Position(original).expiration()) revert InvalidExpiration(); // expiration must not be later than original\n        expiration = _expiration;\n        price = Position(parent).price();\n        _setOwner(hub);\n    }\n\n    /**\n     * Cloning a position is only allowed if the position is not challenged, not expired and not in cooldown.\n     */\n    function assertCloneable() external noChallenge noCooldown alive backed {}\n\n    /**\n     * Notify the original that some amount has been minted.\n     */\n    function notifyMint(uint256 mint_) external {\n        if (zchf.getPositionParent(msg.sender) != hub) revert NotHub();\n        totalMinted += mint_;\n    }\n\n    function notifyRepaid(uint256 repaid_) external {\n        if (zchf.getPositionParent(msg.sender) != hub) revert NotHub();\n        totalMinted -= repaid_;\n    }\n\n    /**\n     * Should only be called on the original position.\n     * Better use 'availableForMinting'.\n     */\n    function availableForClones() external view returns (uint256) {\n        // reserve capacity for the original to the extent the owner provided collateral\n        uint256 potential = (_collateralBalance() * price) / ONE_DEC18;\n        uint256 unusedPotential = minted > potential ? 0 : potential - minted;\n        if (totalMinted + unusedPotential >= limit) {\n            return 0;\n        } else {\n            return limit - totalMinted - unusedPotential;\n        }\n    }\n\n    /**\n     * The amount available for minting in this position family.\n     * \n     * Does not check if positions are challenged, closed, or under cooldown.\n     */\n    function availableForMinting() public view returns (uint256) {\n        if (address(this) == original) {\n            return limit - totalMinted;\n        } else {\n            return Position(original).availableForClones();\n        }\n    }\n\n    /**\n     * @notice Qualified pool share holders can call this method to immediately expire a freshly proposed position.\n     */\n    function deny(address[] calldata helpers, string calldata message) external {\n        if (block.timestamp >= start) revert TooLate();\n        zchf.reserve().checkQualified(msg.sender, helpers);\n        _close();\n        emit PositionDenied(msg.sender, message);\n    }\n\n    /**\n     * Closes the position by putting it into eternal cooldown.\n     * This allows the users to still withdraw the collateral that is left, but never to mint again.\n     */\n    function _close() internal {\n        closed = true;\n    }\n\n    function isClosed() public view returns (bool) {\n        return closed;\n    }\n\n    /**\n     * @notice This is how much the minter can actually use when minting ZCHF, with the rest being used\n     * assigned to the minter reserve or (if applicable) fees.\n     */\n    function getUsableMint(uint256 totalMint, bool afterFees) public view returns (uint256) {\n        if (afterFees) {\n            return (totalMint * (1000_000 - reserveContribution - calculateCurrentFee())) / 1000_000;\n        } else {\n            return (totalMint * (1000_000 - reserveContribution)) / 1000_000;\n        }\n    }\n\n    /**\n     * Returns the corresponding mint amount (disregarding the limit).\n     */\n    function getMintAmount(uint256 usableMint) external view returns (uint256) {\n        return usableMint == 0 ? 0 :(usableMint * 1000_000 - 1) / (1000_000 - reserveContribution - calculateCurrentFee()) + 1;\n    }\n\n    /**\n     * @notice \"All in one\" function to adjust the outstanding amount of ZCHF, the collateral amount,\n     * and the price in one transaction.\n     */\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) external onlyOwner {\n        uint256 colbal = _collateralBalance();\n        if (newCollateral > colbal) {\n            collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\n        }\n        // Must be called after collateral deposit, but before withdrawal\n        if (newMinted < minted) {\n            zchf.burnFromWithReserve(msg.sender, minted - newMinted, reserveContribution);\n            _notifyRepaid(minted - newMinted);\n        }\n        if (newCollateral < colbal) {\n            _withdrawCollateral(msg.sender, colbal - newCollateral);\n        }\n        // Must be called after collateral withdrawal\n        if (newMinted > minted) {\n            _mint(msg.sender, newMinted - minted, newCollateral);\n        }\n        if (newPrice != price) {\n            _adjustPrice(newPrice);\n        }\n        emit MintingUpdate(newCollateral, newPrice, newMinted);\n    }\n\n    /**\n     * @notice Allows the position owner to adjust the liquidation price as long as there is no pending challenge.\n     * Lowering the liquidation price can be done with immediate effect, given that there is enough collateral.\n     * Increasing the liquidation price triggers a cooldown period of 3 days, during which minting is suspended.\n     */\n    function adjustPrice(uint256 newPrice) public onlyOwner {\n        _adjustPrice(newPrice);\n        emit MintingUpdate(_collateralBalance(), price, minted);\n    }\n\n    function _adjustPrice(uint256 newPrice) internal noChallenge alive backed {\n        if (newPrice > price) {\n            _preparePriceIncrease(newPrice);    \n        } else {\n            _checkCollateral(_collateralBalance(), newPrice);\n        }\n        _setPrice(newPrice, minted + availableForMinting());\n    }\n\n    function _preparePriceIncrease(uint256 newPrice) internal noCooldown {\n        if (newPrice > 3*price) revert PriceIncreaseTooHigh(3*price, newPrice);\n        _restrictMinting(3 days);\n    }\n\n    function _setPrice(uint256 newPrice, uint256 bounds) internal {\n        require(newPrice * minimumCollateral <= bounds * ONE_DEC18); // sanity check\n        price = newPrice;\n    }\n\n    function _collateralBalance() internal view returns (uint256) {\n        return IERC20(collateral).balanceOf(address(this));\n    }\n\n    /**\n     * @notice Mint ZCHF as long as there is no open challenge, the position is not subject to a cooldown,\n     * and there is sufficient collateral.\n     */\n    function mint(address target, uint256 amount) public ownerOrRoller {\n        uint256 collateralBalance = _collateralBalance();\n        _mint(target, amount, collateralBalance);\n        emit MintingUpdate(collateralBalance, price, minted);\n    }\n\n    /**\n     * The applicable upfront fee in ppm when minting more Frankencoins based on the annual interest rate and\n     * the expiration of the position.\n     */\n    function calculateCurrentFee() public view returns (uint24) {\n        return calculateFee(expiration);\n    }\n\n    /**\n     * The applicable interest rate in ppm when minting more Frankencoins.\n     * It consists on the globally valid interest plus an individual risk premium.\n     */\n    function annualInterestPPM() public view returns (uint24) {\n        return IHub(hub).rate().currentRatePPM() + riskPremiumPPM;\n    }\n\n    /**\n     * The fee in ppm when cloning and minting with the given expiration date.\n     */\n    function calculateFee(uint256 exp) public view returns (uint24) {\n        uint256 time = block.timestamp < start ? start : block.timestamp;\n        uint256 timePassed = exp - time;\n        // Time resolution is in the range of minutes for typical interest rates.\n        uint256 feePPM = (timePassed * annualInterestPPM()) / 365 days;\n        return uint24(feePPM > 1000000 ? 1000000 : feePPM); // fee cannot exceed 100%\n    }\n\n    function _mint(address target, uint256 amount, uint256 collateral_) internal noChallenge noCooldown alive backed {\n        if (amount > availableForMinting()) revert LimitExceeded(amount, availableForMinting());\n        Position(original).notifyMint(amount);\n        zchf.mintWithReserve(target, amount, reserveContribution, calculateCurrentFee());\n        minted += amount;\n        _checkCollateral(collateral_, price);\n    }\n\n    function _restrictMinting(uint40 period) internal {\n        uint40 horizon = uint40(block.timestamp) + period;\n        if (horizon > cooldown) {\n            cooldown = horizon;\n        }\n    }\n\n    /**\n     * @notice Repay some ZCHF. If too much is repaid, the call fails.\n     * It is possible to repay while there are challenges, but the collateral is locked until all is clear again.\n     *\n     * The repaid amount should fulfill the following equation in order to close the position,\n     * i.e. bring the minted amount to 0:\n     * minted = amount + zchf.calculateAssignedReserve(amount, reservePPM)\n     *\n     * Under normal circumstances, this implies:\n     * amount = minted * (1000000 - reservePPM)\n     *\n     * E.g. if minted is 50 and reservePPM is 200000, it is necessary to repay 40 to be able to close the position.\n     */\n    function repay(uint256 amount) public returns (uint256) {\n        IERC20(zchf).transferFrom(msg.sender, address(this), amount);\n        uint256 actuallyRepaid = IFrankencoin(zchf).burnWithReserve(amount, reserveContribution);\n        _notifyRepaid(actuallyRepaid);\n        emit MintingUpdate(_collateralBalance(), price, minted);\n        return actuallyRepaid;\n    }\n\n    function _notifyRepaid(uint256 amount) internal {\n        if (amount > minted) revert RepaidTooMuch(amount - minted);\n        Position(original).notifyRepaid(amount);\n        minted -= amount;\n    }\n\n    /**\n     * Force the sale of some collateral after the position is expired.\n     * \n     * Can only be called by the minting hub and the minting hub is trusted to calculate the price correctly.\n     * The proceeds from the sale are first used to repay the outstanding balance and then (if anything is left)\n     * it is sent to the owner of the position.\n     * \n     * Do not allow a forced sale as long as there is an open challenge. Otherwise, a forced sale by the owner\n     * himself could remove any incentive to launch challenges shortly before the expiration. (CS-ZCHF2-001)\n     */\n    function forceSale(address buyer, uint256 collAmount, uint256 proceeds) external onlyHub expired noChallenge {\n        // send collateral to buyer\n        uint256 remainingCollateral = _sendCollateral(buyer, collAmount);\n        if (minted > 0) {\n            uint256 availableReserve = zchf.calculateAssignedReserve(minted, reserveContribution);\n            if (proceeds + availableReserve >= minted) {\n                // repay everything from the buyer's account\n                uint256 returnedReserve = zchf.burnFromWithReserve(buyer, minted, reserveContribution);\n                assert(returnedReserve == availableReserve);\n                // transfer the remaining purchase price from the buyer to the owner\n                zchf.transferFrom(buyer, owner, proceeds + returnedReserve - minted);\n                _notifyRepaid(minted);\n            } else {\n                // we can only repay a part, nothing left to pay to owner\n                zchf.transferFrom(buyer, address(this), proceeds);\n                if (remainingCollateral == 0) {\n                    // CS-ZCHF2-002, bad debt should be properly handled. In this case, the proceeds from \n                    // the forced sale did not suffice to repay the position and there is a loss\n                    zchf.coverLoss(address(this), minted - proceeds); // more than we need, but returned again on next line\n                    zchf.burnWithoutReserve(minted, reserveContribution);\n                    _notifyRepaid(minted);\n                } else {\n                    uint256 repaid = zchf.burnWithReserve(proceeds, reserveContribution);\n                    _notifyRepaid(repaid);\n                }\n            }\n        } else {\n            // wire funds directly to owner\n            zchf.transferFrom(buyer, owner, proceeds);\n        }\n        emit MintingUpdate(_collateralBalance(), price, minted);\n    }\n\n    /**\n     * @notice Withdraw any ERC20 token that might have ended up on this address.\n     * Withdrawing collateral is subject to the same restrictions as withdrawCollateral(...).\n     */\n    function withdraw(address token, address target, uint256 amount) external onlyOwner {\n        if (token == address(collateral)) {\n            withdrawCollateral(target, amount);\n        } else {\n            uint256 balance = _collateralBalance();\n            IERC20(token).transfer(target, amount);\n            require(balance == _collateralBalance()); // guard against double-entry-point tokens\n        }\n    }\n\n    /**\n     * @notice Withdraw collateral from the position up to the extent that it is still well collateralized afterwards.\n     * Not possible as long as there is an open challenge or the contract is subject to a cooldown.\n     *\n     * Withdrawing collateral below the minimum collateral amount formally closes the position.\n     */\n    function withdrawCollateral(address target, uint256 amount) public ownerOrRoller {\n        uint256 balance = _withdrawCollateral(target, amount);\n        emit MintingUpdate(balance, price, minted);\n    }\n\n    function _withdrawCollateral(address target, uint256 amount) internal noChallenge noCooldown returns (uint256) {\n        uint256 balance = _sendCollateral(target, amount);\n        _checkCollateral(balance, price);\n        return balance;\n    }\n\n    function _sendCollateral(address target, uint256 amount) internal returns (uint256) {\n        if (amount > 0) {\n            // Some weird tokens fail when trying to transfer 0 amounts\n            IERC20(collateral).transfer(target, amount);\n        }\n        uint256 balance = _collateralBalance();\n        if (balance < minimumCollateral) {\n            _close();\n        }\n        return balance;\n    }\n\n    /**\n     * @notice This invariant must always hold and must always be checked when any of the three\n     * variables change in an adverse way.\n     */\n    function _checkCollateral(uint256 collateralReserve, uint256 atPrice) internal view {\n        uint256 relevantCollateral = collateralReserve < minimumCollateral ? 0 : collateralReserve;\n        if (relevantCollateral * atPrice < minted * ONE_DEC18) revert InsufficientCollateral(relevantCollateral * atPrice, minted * ONE_DEC18);\n    }\n\n    /**\n     * @notice Returns the liquidation price and the durations for phase1 and phase2 of the challenge.\n     * Both phases are usually of equal duration, but near expiration, phase one is adjusted such that\n     * it cannot last beyond the expiration date of the position.\n     */\n    function challengeData() external view returns (uint256 liqPrice, uint40 phase) {\n        return (price, challengePeriod);\n    }\n\n    function notifyChallengeStarted(uint256 size) external onlyHub alive {\n        // Require minimum size. Collateral balance can be below minimum if it was partially challenged before.\n        if (size < minimumCollateral && size < _collateralBalance()) revert ChallengeTooSmall();\n        if (size == 0) revert ChallengeTooSmall();\n        challengedAmount += size;\n    }\n\n    /**\n     * @param size   amount of collateral challenged (dec18)\n     */\n    function notifyChallengeAverted(uint256 size) external onlyHub {\n        challengedAmount -= size;\n\n        // Don't allow minter to close the position immediately so challenge can be repeated before\n        // the owner has a chance to mint more on an undercollateralized position\n        _restrictMinting(1 days);\n    }\n\n    /**\n     * @notice Notifies the position that a challenge was successful.\n     * Triggers the payout of the challenged part of the collateral.\n     * Everything else is assumed to be handled by the hub.\n     *\n     * @param _bidder   address of the bidder that receives the collateral\n     * @param _size     amount of the collateral bid for\n     * @return (position owner, effective challenge size in ZCHF, amount to be repaid, reserve ppm)\n     */\n    function notifyChallengeSucceeded(\n        address _bidder,\n        uint256 _size\n    ) external onlyHub returns (address, uint256, uint256, uint32) {\n        challengedAmount -= _size;\n        uint256 colBal = _collateralBalance();\n        if (colBal < _size) {\n            _size = colBal;\n        }\n        uint256 repayment = colBal == 0 ? 0 : (minted * _size) / colBal; // for enormous colBal, this could be rounded to 0, which is ok\n        _notifyRepaid(repayment); // we assume the caller takes care of the actual repayment\n\n        // Give time for additional challenges before the owner can mint again. In particular,\n        // the owner might have added collateral only seconds before the challenge ended, preventing a close.\n        _restrictMinting(3 days);\n\n        uint256 newBalance = _sendCollateral(_bidder, _size); // transfer collateral to the bidder and emit update\n\n        emit MintingUpdate(newBalance, price, minted);\n\n        return (owner, _size, repayment, reserveContribution);\n    }\n}\n\ninterface IHub {\n    function rate() external view returns (ILeadrate);\n    function roller() external view returns (address);\n}\n"
    },
    "contracts/minting/PositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Position.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\n\ncontract PositionFactory {\n    /**\n     * Create a completely new position in a newly deployed contract.\n     * Must be called through minting hub to be recognized as valid position.\n     */\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialLimit,\n        uint40 _initPeriod,\n        uint40 _duration,\n        uint40 _challengePeriod,\n        uint24 _riskPremiumPPM,\n        uint256 _liqPrice,\n        uint24 _reserve\n    ) external returns (address) {\n        return\n            address(\n                new Position(\n                    _owner,\n                    msg.sender,\n                    _zchf,\n                    _collateral,\n                    _minCollateral,\n                    _initialLimit,\n                    _initPeriod,\n                    _duration,\n                    _challengePeriod,\n                    _riskPremiumPPM,\n                    _liqPrice,\n                    _reserve\n                )\n            );\n    }\n\n    /**\n     * @notice clone an existing position. This can be a clone of another clone,\n     * or an original position.\n     * @param _parent address of the position we want to clone\n     * @return address of the newly created clone position\n     */\n    function clonePosition(address _parent) external returns (address) {\n        Position parent = Position(_parent);\n        parent.assertCloneable();\n        Position clone = Position(_createClone(parent.original()));\n        return address(clone);\n    }\n\n    // github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\n    function _createClone(address target) internal returns (address result) {\n        bytes20 targetBytes = bytes20(target);\n        assembly {\n            let clone := mload(0x40)\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n            mstore(add(clone, 0x14), targetBytes)\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n            result := create(0, clone, 0x37)\n        }\n        require(result != address(0), \"ERC1167: create failed\");\n    }\n}\n"
    },
    "contracts/minting/PositionRoller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"./IPosition.sol\";\nimport \"../utils/Ownable.sol\";\n\n/**\n * @title PositionRoller\n *\n * Helper to roll over a debt from an old position to a new one.\n * Both positions should have the same collateral. Otherwise, it does not make much sense.\n */\ncontract PositionRoller {\n\n    IFrankencoin private zchf;\n\n    error NotOwner(address pos);\n    error NotPosition(address pos);\n    error Log(uint256, uint256, uint256);\n\n    event Roll(address source, uint256 collWithdraw, uint256 repay, address target, uint256 collDeposit, uint256 mint);\n\n    constructor(address zchf_) {\n        zchf = IFrankencoin(zchf_);\n    }\n\n    /**\n     * Convenience method to roll and old position into a new one.\n     * \n     * Pre-condition is an allowance for the roller to spend the collateral assset on behalf of the caller,\n     * i.e. one should set collateral.approve(roller, collateral.balanceOf(sourcePosition));\n     * \n     * The following is assumed:\n     * - If the limit of the target position permits, the user wants to roll everything\n     * - The user does not want to add additional collateral, but excess collateral is returned\n     * - If not enough can be minted in the new position, it is ok for the roller to use ZCHF from the msg.sender\n     */\n    function rollFully(IPosition source, IPosition target) external {\n        rollFullyWithExpiration(source, target, target.expiration());\n    }\n\n    /**\n     * Like rollFully, but with a custom expiration date for the new position.\n     */\n    function rollFullyWithExpiration(IPosition source, IPosition target, uint40 expiration) public {\n        require(source.collateral() == target.collateral());\n        uint256 repay = findRepaymentAmount(source);\n        uint256 mintAmount = target.getMintAmount(repay);\n        uint256 collateralToWithdraw = IERC20(source.collateral()).balanceOf(address(source));\n        uint256 targetPrice = target.price();\n        uint256 depositAmount = (mintAmount * 10**18 + targetPrice - 1) / targetPrice; // round up\n        if (depositAmount > collateralToWithdraw){\n            // If we need more collateral than available from the old position, we opt for taking\n            // the missing funds from the caller instead of taking additional collateral from the caller\n            depositAmount = collateralToWithdraw;\n            mintAmount = depositAmount * target.price() / 10**18; // round down, rest will be taken from caller\n        }\n        roll(source, repay, collateralToWithdraw, target, mintAmount, depositAmount, expiration);\n    }\n\n    /**\n     * Doing a binary search is not very efficient, but guaranteed to return a valid result without rounding errors.\n     * To save gas costs, the frontend can also call this and other methods to calculate the right parameters and\n     * then call 'roll' directly.\n     */\n    function findRepaymentAmount(IPosition pos) public view returns (uint256) {\n        uint256 minted = pos.minted();\n        uint24 reservePPM = pos.reserveContribution();\n        if (minted == 0){\n            return 0;\n        }\n        uint256 higherResult = zchf.calculateFreedAmount(minted, reservePPM);\n        if (higherResult == minted){\n            return minted;\n        }\n        return binarySearch(minted, reservePPM, 0, 0, minted, higherResult);\n    }\n\n    // max call stack depth is 1024 in solidity. Binary search on 256 bit number takes at most 256 steps, so it should be fine.\n    function binarySearch(uint256 target, uint24 reservePPM, uint256 lowerBound, uint256 lowerResult, uint256 higherBound, uint256 higherResult) internal view returns (uint256) {\n        uint256 middle = (lowerBound + higherBound) / 2;\n        if (middle == lowerBound){\n            return higherBound; // we have reached max precision without exact match, return next higher result to be on the safe side\n        } else {\n            uint256 middleResult = zchf.calculateFreedAmount(middle, reservePPM);\n            if (middleResult == target){\n                return middle;\n            } else if (middleResult < target){\n                return binarySearch(target, reservePPM, middle, middleResult, higherBound, higherResult);\n            } else {\n                return binarySearch(target, reservePPM, lowerBound, lowerResult, middle, middleResult);\n            }\n        }\n    }\n\n    /**\n     * Rolls the source position into the target position using a flash loan.\n     * Both the source and the target position must recognize this roller.\n     * It is the responsibility of the caller to ensure that both positions are valid contracts.\n     * \n     * @param source The source position, must be owned by the msg.sender .\n     * @param repay The amount to flash loan in order to repay the source position and free up some or all collateral.\n     * @param collWithdraw Collateral to move from the source position to the msg.sender .\n     * @param target The target position. If not owned by msg.sender or if it does not have the desired expiration,\n     *               it is cloned to create a position owned by the msg.sender.\n     * @param mint The amount to be minted from the target position using collateral from msg.sender.\n     * @param collDeposit The amount of collateral to be send from msg.sender to the target position.\n     * @param expiration The desired expiration date for the target position.\n     */\n    function roll(IPosition source, uint256 repay, uint256 collWithdraw, IPosition target, uint256 mint, uint256 collDeposit, uint40 expiration) public valid(source) valid(target) own(source) {\n        zchf.mint(address(this), repay); // take a flash loan\n        source.repay(repay);\n        source.withdrawCollateral(msg.sender, collWithdraw);\n        if (mint > 0){\n            IERC20 targetCollateral = IERC20(target.collateral());\n            if (Ownable(address(target)).owner() != msg.sender || expiration != target.expiration()){\n                targetCollateral.transferFrom(msg.sender, address(this), collDeposit); // get the new collateral\n                targetCollateral.approve(target.hub(), collDeposit); // approve the new collateral and clone:\n                target = IPosition(IMintingHub(target.hub()).clone(msg.sender, address(target), collDeposit, mint, expiration));\n            } else {\n                // We can roll into the provided existing position\n                // We do not verify whether the target position has been created by the known minting hub in order\n                // to allow positions to be rolled into future versions of the minting hub\n                targetCollateral.transferFrom(msg.sender, address(target), collDeposit);\n                target.mint(msg.sender, mint);\n            }\n        }\n        zchf.burnFrom(msg.sender, repay); // repay the flash loan\n        emit Roll(address(source), collWithdraw, repay, address(target), collDeposit, mint);\n    }\n\n    modifier own(IPosition pos) {\n        if (Ownable(address(pos)).owner() != msg.sender) revert NotOwner(address(pos));\n        _;\n    }\n\n    modifier valid(IPosition pos) {\n        if (zchf.getPositionParent(address(pos)) == address(0x0)) revert NotPosition(address(pos));\n        _;\n    }\n}\n\ninterface IMintingHub {\n    function clone(address owner, address parent, uint256 _initialCollateral, uint256 _initialMint, uint40 expiration) external returns (address);\n}\n"
    },
    "contracts/rate/AbstractLeadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\n\n/**\n * @title Leadrate (attempt at translating the nicely concise German term 'Leitzins')\n *\n * A module that can provide other modules with the lead interest rate for the system.\n * \n * This is an abstract module that is agnostic about the way the lead rate is updated.\n *\n **/\nabstract contract AbstractLeadrate {\n\n    // the following five variables are less than 256 bit so they should be stored\n    // in the same slot, making them cheap to access together, right?\n\n    uint24 public currentRatePPM; // 24 bit allows rates of up to 1670% per year\n\n    uint40 private anchorTime; // 40 bits for time in seconds spans up to 1000 human generations\n    uint64 private ticksAnchor; // in bips * seconds, uint88 allows up to\n\n    event RateChanged(uint24 newRate);\n\n    constructor(uint24 initialRatePPM) {\n        currentRatePPM = initialRatePPM;\n        anchorTime = uint40(block.timestamp);\n        ticksAnchor = 0;\n        emit RateChanged(initialRatePPM); // emit for init indexing, if wanted\n    }\n\n    /**\n     * Setting a previously proposed interest rate change into force.\n     */\n    function updateRate(uint24 rate) internal {\n        uint40 timeNow = uint40(block.timestamp);\n        ticksAnchor += (timeNow - anchorTime) * currentRatePPM;\n        anchorTime = timeNow;\n        currentRatePPM = rate;\n        emit RateChanged(rate);\n    }\n\n    /**\n     * Total accumulated 'interest ticks' since this contract was deployed.\n     * One 'tick' is a ppm-second, so one months of 12% annual interest is\n     *   120000*30*24*3600 = 311040000000 ticks.\n     * Two months of 6% annual interest would result in the same number of\n     * ticks. For simplicity, this is linear, so there is no \"interest on interest\".\n     */\n    function currentTicks() public view returns (uint64) {\n        return ticks(block.timestamp);\n    }\n\n    function ticks(uint256 timestamp) public view returns (uint64) {\n        return ticksAnchor + (uint64(timestamp) - anchorTime) * currentRatePPM;\n    }\n\n}\n"
    },
    "contracts/rate/BridgedLeadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"./AbstractLeadrate.sol\";\n\n/**\n * @title Leadrate (attempt at translating the nicely concise German term 'Leitzins')\n *\n * A module that can provide other modules with the lead interest rate for the system.\n *\n **/\ncontract BridgedLeadrate is AbstractLeadrate, CCIPReceiver {\n    uint64 public immutable MAINNET_CHAIN_SELECTOR;\n    address public immutable MAINNET_LEADRATE_ADDRESS;\n\n    error InvalidSourceChain();\n    error InvalidSender();\n\n    constructor(address router_, uint24 initialRatePPM, uint64 mainnetChainSelector, address mainnetLeadrate) AbstractLeadrate(initialRatePPM) CCIPReceiver(router_) {\n        MAINNET_CHAIN_SELECTOR = mainnetChainSelector;\n        MAINNET_LEADRATE_ADDRESS = mainnetLeadrate;\n    }\n\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n        if (any2EvmMessage.sourceChainSelector != MAINNET_CHAIN_SELECTOR) revert InvalidSourceChain();\n        if (abi.decode(any2EvmMessage.sender, (address)) != MAINNET_LEADRATE_ADDRESS) revert InvalidSender();\n\n        uint24 newRate = abi.decode(any2EvmMessage.data, (uint24));\n        updateRate(newRate);\n    }\n}\n"
    },
    "contracts/rate/ILeadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILeadrate {\n   function currentRatePPM() external view returns (uint24);\n   function currentTicks() external view returns (uint64);\n}\n"
    },
    "contracts/rate/Leadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"./AbstractLeadrate.sol\";\n\n/**\n * @title Leadrate (attempt at translating the nicely concise German term 'Leitzins')\n *\n * A module that can provide other modules with the lead interest rate for the system.\n *\n **/\ncontract Leadrate is AbstractLeadrate {\n\n    IGovernance public immutable equity;\n\n    // the following five variables are less than 256 bit so they should be stored\n    // in the same slot, making them cheap to access together, right?\n\n    uint24 public nextRatePPM;\n    uint40 public nextChange;\n\n    event RateProposed(address who, uint24 nextRate, uint40 nextChange);\n    error NoPendingChange();\n    error ChangeNotReady();\n\n    constructor(IGovernance equity_, uint24 initialRatePPM) AbstractLeadrate(initialRatePPM) {\n        equity = equity_;\n        nextRatePPM = initialRatePPM;\n        nextChange = uint40(block.timestamp);\n    }\n\n    /**\n     * Proposes a new interest rate that will automatically be applied after seven days.\n     * To cancel a proposal, just overwrite it with a new one proposing the current rate.\n     */\n    function proposeChange(uint24 newRatePPM_, address[] calldata helpers) external {\n        equity.checkQualified(msg.sender, helpers);\n        nextRatePPM = newRatePPM_;\n        nextChange = uint40(block.timestamp + 7 days);\n        emit RateProposed(msg.sender, nextRatePPM, nextChange);\n    }\n\n    /**\n     * Setting a previously proposed interest rate change into force.\n     */\n    function applyChange() external {\n        if (currentRatePPM == nextRatePPM) revert NoPendingChange();\n        uint40 timeNow = uint40(block.timestamp);\n        if (timeNow < nextChange) revert ChangeNotReady();\n        super.updateRate(nextRatePPM);\n    }\n\n}\n"
    },
    "contracts/rate/LeadrateSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {Leadrate} from \"./Leadrate.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\n\ncontract LeadrateSender is CCIPSender {\n    Leadrate public immutable LEADRATE;\n\n    event Pushed(uint64 chain, bytes indexed bridgedLeadrate, uint24 newRatePPM);\n\n    error LengthMismatch(uint256 expected, uint256 given);\n\n    constructor(Leadrate _leadrate, IRouterClient _router, address _linkToken) CCIPSender(_router, _linkToken) {\n        LEADRATE = _leadrate;\n    }\n\n    function pushLeadrate(uint64[] calldata chains, bytes[] calldata targets) external payable {\n        pushLeadrate(chains, targets, new bytes[](chains.length));\n    }\n\n    function pushLeadrate(uint64[] calldata chains, bytes[] calldata targets, bytes[] memory extraArgs) public payable {\n        if (chains.length != targets.length) revert LengthMismatch(chains.length, targets.length);\n        if (chains.length != extraArgs.length) revert LengthMismatch(chains.length, extraArgs.length);\n        _applyPendingChanges();\n        uint24 currentRate = LEADRATE.currentRatePPM();\n        for (uint256 i; i < chains.length; i++) {\n            _sendLeadrate(chains[i], targets[i], currentRate, extraArgs[i]);\n        }\n    }\n\n    function pushLeadrate(uint64 chain, address target) external payable {\n        pushLeadrate(chain, _toReceiver(target), \"\");\n    }\n\n    function pushLeadrate(uint64 chain, address target, Client.EVMExtraArgsV2 calldata extraArgs) external payable {\n        pushLeadrate(chain, _toReceiver(target), Client._argsToBytes(extraArgs));\n    }\n\n    function pushLeadrate(uint64 chain, bytes memory target, bytes memory extraArgs) public payable {\n        _applyPendingChanges();\n        _sendLeadrate(chain, target, LEADRATE.currentRatePPM(), extraArgs);\n    }\n\n    function _sendLeadrate(uint64 chain, bytes memory target, uint24 newRatePPM, bytes memory extraArgs) internal {\n        _send(chain, _constructMessage(target, abi.encode(newRatePPM), new Client.EVMTokenAmount[](0), extraArgs));\n        emit Pushed(chain, target, newRatePPM);\n    }\n\n    function _applyPendingChanges() internal {\n        if (LEADRATE.currentRatePPM() != LEADRATE.nextRatePPM() && LEADRATE.nextChange() < block.timestamp) {\n            LEADRATE.applyChange(); // there is a pending change to apply\n        }\n    }\n}\n"
    },
    "contracts/savings/AbstractSavings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../rate/AbstractLeadrate.sol\";\n\n/**\n * @title Savings\n *\n * Module to enable savings based on a Leadrate (\"Leitzins\") module.\n *\n * As the interest rate changes, the speed at which 'ticks' are accumulated is\n * adjusted. The ticks counter serves as the basis for calculating the interest\n * due for the individual accoutns.\n *\n * The saved ZCHF are subject to a lockup of up to 3 days and only start to yield\n * an interest after the lockup ended. The purpose of this lockup is to discourage\n * short-term holdings and to avoid paying interest to transactional accounts.\n * Transactional accounts typically do not need an incentive to hold Frankencoins.\n */\nabstract contract AbstractSavings is AbstractLeadrate {\n    \n    uint64 public immutable INTEREST_DELAY = uint64(3 days);\n\n    IFrankencoin public immutable ZCHF;\n\n    mapping(address => Account) public savings;\n\n    struct Account {\n        uint192 saved;\n        uint64 ticks;\n        address referrer;\n        uint32 referralFeePPM;\n    }\n\n    event Saved(address indexed account , uint192 amount);\n    event InterestCollected(address indexed account, uint256 interest, uint256 referrerFee);\n    event Withdrawn(address indexed account, uint192 amount);\n\n    error FundsLocked(uint40 remainingSeconds);\n\n    // The module is considered disabled if the interest is zero or about to become zero within three days.\n    error ModuleDisabled();\n\n    error ReferralFeeTooHigh(uint32 fee);\n\n    constructor(IFrankencoin zchf){\n        ZCHF = zchf;\n    }\n\n    /**\n     * Shortcut for refreshBalance(msg.sender)\n     */\n    function refreshMyBalance() public returns (uint192) {\n        return refreshBalance(msg.sender);\n    }\n\n    /**\n     * Collects the accrued interest and adds it to the account.\n     *\n     * It can be beneficial to do so every now and then in order to start collecting\n     * interest on the accrued interest.\n     */\n    function refreshBalance(address owner) public returns (uint192) {\n        return refresh(owner).saved;\n    }\n\n    function refresh(address accountOwner) internal returns (Account storage) {\n        Account storage account = savings[accountOwner];\n        uint64 ticks = currentTicks();\n        if (ticks > account.ticks) {\n            uint192 earnedInterest = calculateInterest(account, ticks);\n            if (earnedInterest > 0) {\n                // collect interest as you go and trigger accounting event\n                ZCHF.coverLoss(address(this), earnedInterest);\n                uint192 referralFee = deductTransferReferralFee(account, earnedInterest);\n                account.saved += (earnedInterest - referralFee);\n                emit InterestCollected(accountOwner, earnedInterest, referralFee);\n            }\n            account.ticks = ticks;\n        }\n        return account;\n    }\n\n    function accruedInterest(address accountOwner) public view returns (uint192) {\n        return accruedInterest(accountOwner, block.timestamp);\n    }\n\n    function accruedInterest(address accountOwner, uint256 timestamp) public view returns (uint192) {\n        Account memory account = savings[accountOwner];\n        return calculateInterest(account, ticks(timestamp));\n    }\n\n    function calculateInterest(Account memory account, uint64 ticks) public pure returns (uint192) {\n        if (ticks <= account.ticks || account.ticks == 0) {\n            return 0;\n        } else {\n            return uint192((uint256(ticks - account.ticks) * account.saved) / 1000000 / 365 days);\n        }\n    }\n    \n    /**\n     * Save 'amount'.\n     */\n    function save(uint192 amount) public {\n        save(msg.sender, amount);\n    }\n\n    function adjust(uint192 targetAmount) public {\n        Account storage balance = refresh(msg.sender);\n        if (balance.saved < targetAmount) {\n            save(targetAmount - balance.saved);\n        } else if (balance.saved > targetAmount) {\n            withdraw(msg.sender, balance.saved - targetAmount);\n        }\n    }\n\n    /**\n     * Send 'amount' to the account of the provided owner.\n     * The funds sent to the account are locked for a while, depending on how much already is in there.\n     */\n    function save(address owner, uint192 amount) public {\n        if (currentRatePPM == 0) revert ModuleDisabled();\n       // if (nextRatePPM == 0 && (nextChange <= block.timestamp + INTEREST_DELAY)) revert ModuleDisabled(); TODO: figure out why this was in there\n        Account storage balance = refresh(owner);\n        ZCHF.transferFrom(msg.sender, address(this), amount);\n        uint64 ticks = currentTicks();\n        assert(balance.ticks >= ticks);\n        uint256 saved = balance.saved;\n        uint64 weightedAverage = uint64(\n            (saved * (balance.ticks - ticks) + uint256(amount) * currentRatePPM * INTEREST_DELAY) / (saved + amount)\n        );\n        balance.saved += amount;\n        balance.ticks = ticks + weightedAverage;\n        emit Saved(owner, amount);\n    }\n\n    /**\n     * Withdraw up to 'amount' to the target address.\n     * When trying to withdraw more than available, all that is available is withdrawn.\n     * Returns the acutally transferred amount.\n     */\n    function withdraw(address target, uint192 amount) public returns (uint256) {\n        Account storage account = refresh(msg.sender);\n        if (amount >= account.saved) {\n            amount = account.saved;\n            delete savings[msg.sender];\n        } else {\n            account.saved -= amount;\n        }\n        ZCHF.transfer(target, amount);\n        emit Withdrawn(msg.sender, amount);\n        return amount;\n    }\n\n    /**\n     * REFERRAL LOGIC\n     * \n     * The following functions can be used by a frontend or wallet contains functions to\n     * access the savings features of the Frankencoin system. It allows the frontend or\n     * wallet to set a referrer and a referral fee when calling save or adjust, but not\n     * when withdrawing. The referral fee can be up to 25% (250'000 ppm). It is deducted\n     * from the collected interest.\n     * \n     * The user can drop or change the referrer at any time, so the fee is not very sticky.\n     * The magnitude of the fee that can be charged mainly depends on how convenient the\n     * frontend or wallet is in comparison to the user directly interfering with the system\n     * himself. So economically, it really is a frontend fee that can only be charged to\n     * the extent that the frontend provides a more convenient way of interaction with the\n     * protocol and the users are willing to pay for that convenience.\n     */\n\n    /**\n     * Save the given amount and set the referrer to earn a fee on the collected interest.\n     * \n     * Referral fee is given in parts per million and can be at most 250'000, which is 25%.\n     */\n    function save(uint192 amount, address referrer, uint24 referralFeePPM) public {\n        save(msg.sender, amount);\n        setReferrer(referrer, referralFeePPM);\n    }\n\n    /**\n     * Withdraw the given amount and set the referrer to earn a fee on the collected interest.\n     * \n     * Referral fee is given in parts per million and can be at most 250'000, which is 25%.\n     */\n    function withdraw(uint192 amount, address referrer, uint24 referralFeePPM) public {\n        withdraw(msg.sender, amount);\n        setReferrer(referrer, referralFeePPM);\n    }\n\n    /**\n     * Adjust to the given amount and set the referrer to earn a fee on the collected interest.\n     * \n     * Referral fee is given in parts per million and can be at most 250'000, which is 25%.\n     */\n    function adjust(uint192 targetAmount, address referrer, uint24 referralFeePPM) public {\n        adjust(targetAmount);\n        setReferrer(referrer, referralFeePPM);\n    }\n\n    /**\n     * Remove the referrer.\n     */\n    function dropReferrer() public {\n        refresh(msg.sender); // pay accrued referral fee before dropping referrer\n        setReferrer(address(0x0), 0);\n    }\n\n    function setReferrer(address referrer, uint32 referralFeePPM) internal {\n        if (referralFeePPM > 250_000) revert ReferralFeeTooHigh(referralFeePPM); // don't allow more than 25%\n        savings[msg.sender].referrer = referrer;\n        savings[msg.sender].referralFeePPM = referralFeePPM;\n    }\n\n    function deductTransferReferralFee(Account memory balance, uint192 earnedInterest) internal returns (uint192) {\n        if (balance.referrer != address(0x0)){\n            uint256 referralFee = uint256(earnedInterest) * balance.referralFeePPM / 1000000;\n            ZCHF.transfer(balance.referrer, referralFee);\n            return uint192(referralFee);\n        } else {\n            return 0;\n        }\n    }\n\n}\n\ninterface IInterestSource {\n    function coverLoss(address source, uint256 amount) external;\n}\n"
    },
    "contracts/savings/BridgedSavings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../rate/BridgedLeadrate.sol\";\nimport \"./AbstractSavings.sol\";\nimport \"../erc20/IERC20.sol\";\n\n/**\n * @title BridgedSavings\n *\n * Module to enable savings based on a Leadrate (\"Leitzins\") module on a layer-two chain.\n */\ncontract BridgedSavings is AbstractSavings, BridgedLeadrate {\n    constructor(\n        IFrankencoin zchf_,\n        address router_,\n        uint24 initialRatePPM,\n        uint64 mainnetChainSelector,\n        address mainnetLeadrate\n    ) AbstractSavings(zchf_) BridgedLeadrate(router_, initialRatePPM, mainnetChainSelector, mainnetLeadrate) {}\n}\n"
    },
    "contracts/savings/Savings.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../rate/Leadrate.sol\";\nimport \"./AbstractSavings.sol\";\n\n/**\n * @title Savings\n *\n * Module to enable savings based on a Leadrate (\"Leitzins\") module on mainnet.\n */\ncontract Savings is Leadrate, AbstractSavings {\n\n    constructor(IFrankencoin zchf_, uint24 initialRatePPM) AbstractSavings(zchf_) Leadrate(zchf_.reserve(), initialRatePPM) {\n    }\n\n}\n"
    },
    "contracts/stablecoin/BridgedFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../equity/BridgedGovernance.sol\";\nimport \"../erc20/ERC20PermitLight.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"../equity/Equity.sol\";\nimport \"./IBasicFrankencoin.sol\";\nimport \"../erc20/CrossChainERC20.sol\";\nimport \"../bridge/CCIPSender.sol\";\n\n/**\n * @title Bridged Frankencoin ERC-20 Token\n *\n * Like its mainnet counterpart, it has the capapbility to add minting modules. This allows to\n * potentially add similar collateralized minting methods as in the mainnet Frankencoin.\n *\n * However, there is only one FPS, the one on mainnet and voting power has to be projected onto the\n * side chains.\n */\ncontract BridgedFrankencoin is CrossChainERC20, ERC20PermitLight, IBasicFrankencoin {\n    /**\n     * @notice Minimal fee and application period when suggesting a new minter.\n     */\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n    address public immutable BRIDGE_ACCOUNTING;\n    uint64 public immutable MAINNET_CHAIN_SELECTOR;\n    address public immutable CCIP_ADMIN;\n\n    /**\n     * @notice The contract that holds the reserve.\n     */\n    IGovernance public immutable override reserve;\n\n    /**\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n     * to mint Frankencoins.\n     */\n    mapping(address minter => uint256 validityStart) public minters;\n\n    /**\n     * @notice List of positions that are allowed to mint and the minter that registered them.\n     */\n    mapping(address position => address registeringMinter) public positions;\n\n    uint256 public accruedLoss;\n    bool public initialized;\n\n    event AccountingSynchronized(uint256 profit, uint256 losses);\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n    event MinterDenied(address indexed minter, string message);\n    event Loss(address indexed reportingMinter, uint256 amount);\n    event Profit(address indexed reportingMinter, uint256 amount);\n\n    error PeriodTooShort();\n    error FeeTooLow();\n    error AlreadyRegistered();\n    error NotMinter();\n    error TooLate();\n    error AlreadyInitialized();\n\n    modifier minterOnly() {\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n        _;\n    }\n\n    /**\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n     */\n    constructor(IGovernance reserve_, address router_, uint256 _minApplicationPeriod, address _linkToken, uint64 _mainnetChainSelector, address _bridgeAccounting, address _ccipAdmin) ERC20(18) CrossChainERC20(router_, _linkToken) {\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n        reserve = reserve_;\n        MAINNET_CHAIN_SELECTOR = _mainnetChainSelector;\n        BRIDGE_ACCOUNTING = _bridgeAccounting;\n        CCIP_ADMIN = _ccipAdmin;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Frankencoin\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"ZCHF\";\n    }\n\n    function initialize(address _minter, string calldata _message) external {\n        if (initialized) revert AlreadyInitialized();\n        minters[_minter] = block.timestamp;\n        initialized = true;\n        emit MinterApplied(_minter, 0, 0, _message);\n    }\n\n    /**\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\n     * the proposed minter.\n     *\n     * @param _minter              An address that is given the permission to mint Frankencoins\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\n     * @param _message             An optional human readable message to everyone watching this contract\n     */\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) external override {\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\n        if (minters[_minter] != 0) revert AlreadyRegistered();\n        _collectProfits(address(this), msg.sender, _applicationFee);\n        minters[_minter] = block.timestamp + _applicationPeriod;\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n    }\n\n    /**\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\n     * giving them arbitrary allowances does not pose an additional risk.\n     */\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\n        uint256 explicit = super._allowance(owner, spender);\n        if (explicit > 0) {\n            return explicit; // don't waste gas checking minter\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\n            return INFINITY;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n     */\n    function registerPosition(address _position) external override {\n        if (!isMinter(msg.sender)) revert NotMinter();\n        positions[_position] = msg.sender;\n    }\n\n    /**\n     * @notice Qualified pool share holders can deny minters during the application period.\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\n     */\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\n        if (block.timestamp > minters[_minter]) revert TooLate();\n        reserve.checkQualified(msg.sender, _helpers);\n        delete minters[_minter];\n        emit MinterDenied(_minter, _message);\n    }\n\n    function mint(address _target, uint256 _amount) external override minterOnly {\n        _mint(_target, _amount);\n    }\n\n    /**\n     * Anyone is allowed to burn their ZCHF.\n     */\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Burn someone elses ZCHF.\n     */\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\n        _burn(_owner, _amount);\n    }\n\n    function canMint(address _minterOrPosition) public view returns (bool) {\n        return isMinter(_minterOrPosition) || isMinter(positions[_minterOrPosition]);\n    }\n\n    /**\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\n     *\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\n     * by the reserve.\n     */\n    function coverLoss(address source, uint256 _amount) external minterOnly {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        if (_amount > reserveLeft) {\n            accruedLoss += (_amount - reserveLeft);\n            _mint(address(reserve), _amount - reserveLeft);\n        }\n        _transfer(address(reserve), source, _amount);\n        emit Loss(source, _amount);\n    }\n\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\n        _collectProfits(msg.sender, source, _amount);\n    }\n\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\n        _transfer(source, address(reserve), _amount);\n        if (accruedLoss > _amount) {\n            accruedLoss -= _amount;\n            _burn(address(reserve), _amount);\n        } else if (accruedLoss > 0) {\n            _burn(address(reserve), accruedLoss);\n            accruedLoss = 0;\n        }\n        emit Profit(minter, _amount);\n    }\n\n    function synchronizeAccounting() public payable {\n        synchronizeAccounting(\"\");\n    }\n\n    function synchronizeAccounting(Client.EVMExtraArgsV2 calldata extraArgs) public payable {\n        synchronizeAccounting(Client._argsToBytes(extraArgs));\n    }\n\n    /**\n     * Uses a multichain call to send home all accrued profits, if any\n     */\n    function synchronizeAccounting(bytes memory extraArgs) public payable {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        uint256 _accuredLoss = accruedLoss;\n        accruedLoss = 0;\n\n        if (reserveLeft > 0) {\n            _transfer(address(reserve), address(this), reserveLeft);\n            _approve(address(this), address(ROUTER), reserveLeft);\n        }\n\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        tokenAmounts[0] = Client.EVMTokenAmount({token: address(this), amount: reserveLeft});\n        Client.EVM2AnyMessage memory message = _constructMessage(_toReceiver(BRIDGE_ACCOUNTING), abi.encode(reserveLeft, _accuredLoss), tokenAmounts, extraArgs);\n        _send(MAINNET_CHAIN_SELECTOR, message);\n        emit AccountingSynchronized(reserveLeft, _accuredLoss);\n    }\n\n    /**\n     * @notice Returns true if the address is an approved minter.\n     */\n    function isMinter(address _minter) public view returns (bool) {\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n    }\n\n    /**\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\n     */\n    function getPositionParent(address _position) public view returns (address) {\n        return positions[_position];\n    }\n\n    /*\n     * @notice Used to register the token initialially in the CCIP environment\n     */\n    function getCCIPAdmin() external view returns(address) {\n        return CCIP_ADMIN;\n    }\n}\n"
    },
    "contracts/stablecoin/Frankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/ERC20PermitLight.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"../equity/Equity.sol\";\nimport \"./IBasicFrankencoin.sol\";\nimport \"./IFrankencoin.sol\";\n\n/**\n * @title FrankenCoin\n * @notice The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\n */\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\n    /**\n     * @notice Minimal fee and application period when suggesting a new minter.\n     */\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n\n    /**\n     * @notice The contract that holds the reserve.\n     */\n    IGovernance public immutable override reserve;\n\n    /**\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\n     * million (ppm) in reserve calculations.\n     */\n    uint256 private minterReserveE6;\n\n    /**\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n     * to mint Frankencoins.\n     */\n    mapping(address minter => uint256 validityStart) public minters;\n\n    /**\n     * @notice List of positions that are allowed to mint and the minter that registered them.\n     */\n    mapping(address position => address registeringMinter) public positions;\n\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n    event MinterDenied(address indexed minter, string message);\n    event Loss(address indexed reportingMinter, uint256 amount);\n    event Profit(address indexed reportingMinter, uint256 amount);\n\n    error PeriodTooShort();\n    error FeeTooLow();\n    error AlreadyRegistered();\n    error NotMinter();\n    error TooLate();\n\n    modifier minterOnly() {\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n        _;\n    }\n\n    /**\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n     */\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n        reserve = new Equity(this);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Frankencoin\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"ZCHF\";\n    }\n\n    function initialize(address _minter, string calldata _message) external {\n        require(totalSupply() == 0 && (Equity(address(reserve)).totalSupply() == 0));\n        minters[_minter] = block.timestamp;\n        emit MinterApplied(_minter, 0, 0, _message);\n    }\n\n    /**\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\n     * the proposed minter.\n     *\n     * @param _minter              An address that is given the permission to mint Frankencoins\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\n     * @param _message             An optional human readable message to everyone watching this contract\n     */\n    function suggestMinter(\n        address _minter,\n        uint256 _applicationPeriod,\n        uint256 _applicationFee,\n        string calldata _message\n    ) external override {\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\n        if (minters[_minter] != 0) revert AlreadyRegistered();\n        _collectProfits(address(this), msg.sender, _applicationFee);\n        minters[_minter] = block.timestamp + _applicationPeriod;\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n    }\n\n    /**\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\n     * giving them arbitrary allowances does not pose an additional risk.\n     */\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\n        uint256 explicit = super._allowance(owner, spender);\n        if (explicit > 0) {\n            return explicit; // don't waste gas checking minter\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\n            return INFINITY;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice The reserve provided by the owners of collateralized positions.\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\n     */\n    function minterReserve() public view returns (uint256) {\n        return minterReserveE6 / 1000000;\n    }\n\n    /**\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n     */\n    function registerPosition(address _position) external override {\n        if (!isMinter(msg.sender)) revert NotMinter();\n        positions[_position] = msg.sender;\n    }\n\n    /**\n     * @notice The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\n     * constitutes profits attributable to the pool share holders.\n     */\n    function equity() public view returns (uint256) {\n        uint256 balance = balanceOf(address(reserve));\n        uint256 minReserve = minterReserve();\n        if (balance <= minReserve) {\n            return 0;\n        } else {\n            return balance - minReserve;\n        }\n    }\n\n    /**\n     * @notice Qualified pool share holders can deny minters during the application period.\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\n     */\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\n        if (block.timestamp > minters[_minter]) revert TooLate();\n        reserve.checkQualified(msg.sender, _helpers);\n        delete minters[_minter];\n        emit MinterDenied(_minter, _message);\n    }\n\n    /**\n     * @notice Mints the provided amount of ZCHF to the target address, automatically forwarding\n     * the minting fee and the reserve to the right place.\n     */\n    function mintWithReserve(\n        address _target,\n        uint256 _amount,\n        uint32 _reservePPM,\n        uint32 _feesPPM\n    ) external override minterOnly {\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\n        _mint(_target, usableMint);\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\n        minterReserveE6 += _amount * _reservePPM;\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\n    }\n\n    function mint(address _target, uint256 _amount) external override minterOnly {\n        _mint(_target, _amount);\n    }\n\n    /**\n     * Anyone is allowed to burn their ZCHF.\n     */\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Burn someone elses ZCHF.\n     */\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\n        _burn(_owner, _amount);\n    }\n\n    /**\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\n     *\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\n     * the same _reservePPM amount.\n     *\n     * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF\n     * and paid 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this\n     * method, 50 ZCHF get burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are\n     * reassigned to the pool share holders.\n     *\n     * CS-ZCHF2-009: the Profit event can overstate profits in case there is no equity capital left.\n     */\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\n        _burn(msg.sender, amount);\n        uint256 reserveReduction = amount * reservePPM;\n        if (reserveReduction > minterReserveE6) {\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\n        } else {\n            minterReserveE6 -= reserveReduction;\n            emit Profit(msg.sender, reserveReduction / 1000_000);\n        }\n    }\n\n    /**\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\n     * same _reservePPM amount.\n     *\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\n     * Now they have 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\n     * 'debt' of the caller by 50 ZCHF in total. This total is returned by the method so the caller knows how much less\n     * they owe.\n     */\n    function burnWithReserve(\n        uint256 _amountExcludingReserve,\n        uint32 _reservePPM\n    ) external override minterOnly returns (uint256) {\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\n        return freedAmount;\n    }\n\n    /**\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\n     *\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves\n     * are only 90% covered, this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while\n     * reducing the minter reserve by 10.\n     */\n    function burnFromWithReserve(\n        address payer,\n        uint256 targetTotalBurnAmount,\n        uint32 reservePPM\n    ) external override minterOnly returns (uint256) {\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\n        return assigned;\n    }\n\n    /**\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\n     * Under normal circumstances, this is just the reserve requirement multiplied by the amount. However, after a\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\n     */\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\n        uint256 currentReserve = balanceOf(address(reserve));\n        uint256 minterReserve_ = minterReserve();\n        if (currentReserve < minterReserve_) {\n            // not enough reserves, owner has to take a loss\n            return (theoreticalReserve * currentReserve) / minterReserve_;\n        } else {\n            return theoreticalReserve;\n        }\n    }\n\n    /**\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\n     * taking into account potential losses. Example values in the comments.\n     */\n    function calculateFreedAmount(\n        uint256 amountExcludingReserve /* 41 */,\n        uint32 reservePPM /* 20% */\n    ) public view returns (uint256) {\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\n        uint256 minterReserve_ = minterReserve(); // 20\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\n            ? (reservePPM * currentReserve) / minterReserve_\n            : reservePPM; // 18%\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\n    }\n\n    /**\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\n     *\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\n     * by the reserve.\n     */\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        if (reserveLeft >= _amount) {\n            _transfer(address(reserve), source, _amount);\n        } else {\n            _transfer(address(reserve), source, reserveLeft);\n            _mint(source, _amount - reserveLeft);\n        }\n        emit Loss(source, _amount);\n    }\n\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\n        _collectProfits(msg.sender, source, _amount);\n    }\n\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\n        _transfer(source, address(reserve), _amount);\n        emit Profit(minter, _amount);\n    }\n\n    /**\n     * @notice Returns true if the address is an approved minter.\n     */\n    function isMinter(address _minter) public view override returns (bool) {\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n    }\n\n    /**\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\n     */\n    function getPositionParent(address _position) public view override returns (address) {\n        return positions[_position];\n    }\n}\n"
    },
    "contracts/stablecoin/IBasicFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../equity/IGovernance.sol\";\n\ninterface IBasicFrankencoin is IERC20 {\n\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) external;\n\n    function registerPosition(address position) external;\n\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\n\n    function reserve() external view returns (IGovernance);\n\n    function isMinter(address minter) external view returns (bool);\n\n    function getPositionParent(address position) external view returns (address);\n\n    function mint(address target, uint256 amount) external;\n\n    function burnFrom(address target, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function coverLoss(address source, uint256 amount) external;\n\n    function collectProfits(address source, uint256 _amount) external;\n}\n"
    },
    "contracts/stablecoin/IFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../equity/IGovernance.sol\";\nimport \"./IBasicFrankencoin.sol\";\n\ninterface IFrankencoin is IBasicFrankencoin {\n\n    function minterReserve() external view returns (uint256);\n\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) external view returns (uint256);\n\n    function calculateFreedAmount(uint256 amountExcludingReserve, uint32 reservePPM) external view returns (uint256);\n\n    function equity() external view returns (uint256);\n\n    function mintWithReserve(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\n\n    function burnWithoutReserve(uint256 amountIncludingReserve, uint32 reservePPM) external;\n\n    function burnFromWithReserve(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external returns (uint256);\n\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\n\n}\n"
    },
    "contracts/stablecoin/StablecoinBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../erc20/IERC677Receiver.sol\";\nimport \"./IFrankencoin.sol\";\n\n/**\n * @title Stable Coin Bridge\n * @notice A minting contract for another Swiss franc stablecoin ('source stablecoin') that we trust.\n * @author Frankencoin\n */\ncontract StablecoinBridge {\n    \n    IERC20 public immutable chf; // the source stablecoin\n    IFrankencoin public immutable zchf; // the Frankencoin\n\n    /**\n     * @notice The time horizon after which this bridge expires and needs to be replaced by a new contract.\n     */\n    uint256 public immutable horizon;\n\n    /**\n     * The maximum amount of outstanding converted source stablecoins.\n     */\n    uint256 public immutable limit;\n    uint256 public minted;\n\n    error Limit(uint256 amount, uint256 limit);\n    error Expired(uint256 time, uint256 expiration);\n    error UnsupportedToken(address token);\n\n    constructor(address other, address zchfAddress, uint256 limit_) {\n        chf = IERC20(other);\n        zchf = IFrankencoin(zchfAddress);\n        horizon = block.timestamp + 52 weeks;\n        limit = limit_;\n        minted = 0;\n    }\n\n    /**\n     * @notice Convenience method for mint(msg.sender, amount)\n     */\n    function mint(uint256 amount) external {\n        mintTo(msg.sender, amount);\n    }\n\n    /**\n     * @notice Mint the target amount of Frankencoins, taking the equal amount of source coins from the sender.\n     * @dev This only works if an allowance for the source coins has been set and the caller has enough of them.\n     */\n    function mintTo(address target, uint256 amount) public {\n        chf.transferFrom(msg.sender, address(this), amount);\n        _mint(target, amount);\n    }\n\n    function _mint(address target, uint256 amount) internal {\n        if (block.timestamp > horizon) revert Expired(block.timestamp, horizon);\n        zchf.mint(target, amount);\n        minted += amount;\n        if (minted > limit) revert Limit(amount, limit);\n    }\n\n    /**\n     * @notice Convenience method for burnAndSend(msg.sender, amount)\n     */\n    function burn(uint256 amount) external {\n        _burn(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Burn the indicated amount of Frankencoin and send the same number of source coin to the caller.\n     */\n    function burnAndSend(address target, uint256 amount) external {\n        _burn(msg.sender, target, amount);\n    }\n\n    function _burn(address zchfHolder, address target, uint256 amount) internal {\n        zchf.burnFrom(zchfHolder, amount);\n        chf.transfer(target, amount);\n        minted -= amount;\n    }\n}\n"
    },
    "contracts/test/CCIPLocalSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CCIPLocalSimulator} from \"@chainlink/local/src/ccip/CCIPLocalSimulator.sol\";"
    },
    "contracts/test/CCIPSenderTest.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\n\ncontract CCIPSenderTest is CCIPSender {\n    constructor(IRouterClient _router, address _link) CCIPSender(_router, _link) {}\n\n    function toReceiver(address target) public pure returns (bytes memory) {\n        return _toReceiver(target);\n    }\n\n    function constructMessage(\n        bytes memory _receiver,\n        bytes memory _payload,\n        Client.EVMTokenAmount[] memory _tokenAmounts,\n        bytes memory _extraArgs\n    ) public view returns (Client.EVM2AnyMessage memory) {\n        return _constructMessage(_receiver, _payload, _tokenAmounts, _extraArgs);\n    }\n\n    function constructMessage(\n        bytes memory _receiver,\n        bytes memory _payload,\n        Client.EVMTokenAmount[] memory _tokenAmounts,\n        bool nativeToken,\n        bytes memory _extraArgs\n    ) public view returns (Client.EVM2AnyMessage memory) {\n        return _constructMessage(_receiver, _payload, _tokenAmounts, nativeToken, _extraArgs);\n    }\n\n    function calculateFee(uint64 chain, Client.EVM2AnyMessage memory message) public view returns (uint256) {\n        return _calculateFee(chain, message);\n    }\n\n    function send(uint64 chain, Client.EVM2AnyMessage memory _message) public payable returns (bytes32, uint256) {\n        return _send(chain, _message);\n    }\n\n    function guessFeeToken() public view returns (address) {\n        return _guessFeeToken();\n    }\n}\n"
    },
    "contracts/test/DeployerFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../stablecoin/Frankencoin.sol\";\nimport \"../minting/PositionFactory.sol\";\nimport \"../minting/MintingHub.sol\";\nimport \"../rate/Leadrate.sol\";\nimport \"../equity/Equity.sol\";\n\ncontract DeployerFrankencoin {\n    string public constant NAME = \"DeployerV0\";\n    Frankencoin public zchf;\n    PositionFactory public factory;\n    Leadrate public leadrate;\n    PositionRoller public roller;\n    MintingHub public mintingHub;\n\n    event Log(address sender, string message);\n\n    constructor() {\n        zchf = new Frankencoin(1);\n        factory = new PositionFactory();\n        roller = new PositionRoller(address(zchf));\n        leadrate = new Leadrate(zchf.reserve(), 20000);\n        mintingHub = new MintingHub(address(zchf), address(leadrate), address(roller), address(factory));\n\n        zchf.initialize(msg.sender, \"Developer\");\n        zchf.initialize(address(this), \"Deployer\");\n        zchf.initialize(address(mintingHub), \"MintingHub\");\n        zchf.initialize(address(roller), \"Roller\");\n    }\n\n    function initA_Frankencoin() public {\n        uint256 toMint = 1_000_000 ether;\n        zchf.mint(address(this), 2 * toMint);\n        Equity(address(zchf.reserve())).invest(toMint, 1000 ether);\n\n        // for sender\n        zchf.mint(msg.sender, toMint);\n    }\n\n    function increaseLeadrate() public {\n        leadrate.proposeChange(leadrate.currentRatePPM() + 1000, new address[](0));\n    }\n\n    function revertLeadrate() public {\n        leadrate.proposeChange(leadrate.currentRatePPM(), new address[](0));\n    }\n}\n"
    },
    "contracts/test/FreakToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/ERC20.sol\";\n\ncontract FreakToken is ERC20 {\n    string public name;\n    string public symbol;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 dec\n    ) ERC20(dec) {\n        name = name_;\n        symbol = symbol_;\n\n        _mint(msg.sender, 1_000_000 * 1e18);\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n\n    function transfer(address, uint256) public virtual override returns (bool) {\n        return true;\n    }\n}\n"
    },
    "contracts/test/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}"
    },
    "contracts/test/MintingHubTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Strings.sol\";\nimport \"./TestToken.sol\";\nimport \"../equity/Equity.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../minting/Position.sol\";\nimport \"../minting/MintingHub.sol\";\nimport \"../stablecoin/StablecoinBridge.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../erc20/IERC20.sol\";\n\ncontract MintingHubTest {\n    MintingHub hub;\n    StablecoinBridge swap;\n\n    IERC20 xchf;\n    TestToken col;\n    IFrankencoin zchf;\n    Equity fps;\n\n    User alice;\n    User bob;\n\n    address latestPosition;\n    uint256 latestChallenge;\n\n    constructor(address hub_, address swap_) {\n        hub = MintingHub(hub_);\n        swap = StablecoinBridge(swap_);\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\n        xchf = swap.chf();\n        zchf = swap.zchf();\n        alice = new User(zchf);\n        bob = new User(zchf);\n        fps = Equity(address(fps));\n        require(fps.totalSupply() == 0, Strings.toString(fps.totalSupply()));\n    }\n\n    function initiateEquity() public {\n        require(zchf.equity() == 1003849100000000000001, Strings.toString(zchf.equity()));\n        require(fps.totalSupply() == 0, Strings.toString(fps.totalSupply()));\n        // ensure there is at least 25'000 ZCHF in equity\n        bob.obtainFrankencoins(swap, 10000 ether);\n        bob.invest(1000 ether);\n        require(fps.totalSupply() == 1000 ether, Strings.toString(fps.totalSupply()));\n        bob.invest(9000 ether);\n        alice.obtainFrankencoins(swap, 15000 ether);\n        alice.invest(15000 ether);\n        require(zchf.equity() > 25000 ether, Strings.toString(zchf.equity()));\n    }\n\n    function initiateAndDenyPosition() public {\n        alice.obtainFrankencoins(swap, 1000 ether);\n        address pos = alice.initiatePosition(col, hub);\n        bob.deny(hub, pos);\n    }\n\n    function initiatePosition() public {\n        alice.obtainFrankencoins(swap, 1000 ether);\n        latestPosition = alice.initiatePosition(col, hub);\n        require(col.balanceOf(address(alice)) == 0);\n    }\n\n    function testWithdraw() public {\n        alice.testWithdraw(swap, Position(latestPosition));\n    }\n\n    function letAliceMint() public {\n        alice.mint(latestPosition, 1); // test small amount to provoke rounding error\n        alice.transferOwnership(latestPosition, address(bob));\n        uint256 bobbalance = zchf.balanceOf(address(bob));\n        bob.mint(latestPosition, 7);\n        require(zchf.balanceOf(address(bob)) > bobbalance);\n        bob.transferOwnership(latestPosition, address(alice));\n        alice.mint(latestPosition, 0);\n        alice.mint(latestPosition, 100000 * (10 ** 18) - 8);\n        alice.adjustPosition(latestPosition);\n        require(Position(latestPosition).minted() == 100000 ether);\n    }\n\n    function letBobMint() public {\n        bob.mint(latestPosition, 1);\n    }\n\n    uint256 first;\n    uint256 second;\n\n    function letBobChallengePart1() public {\n        col.mint(address(bob), 1300);\n\n        // three challenges in parallel :)\n        first = bob.challenge(hub, latestPosition, 300);\n        second = bob.challenge(hub, latestPosition, 400);\n        latestChallenge = bob.challenge(hub, latestPosition, 500);\n    }\n\n    function letBobChallengePart2() public returns (uint256) {\n        /* alice.avertChallenge(hub, swap, first);\n        bob.obtainFrankencoins(swap, 30_000 ether);\n        bob.bid(hub, second, 10_000 ether);\n        bob.bid(hub, latestChallenge, 20_000 ether);\n        (address challenger, , , , , uint256 bid) = hub.challenges(\n            latestChallenge\n        );\n        require(challenger != address(0x0), \"challenge not found\");\n        require(bid == 20_000 ether);\n        return latestChallenge; */\n    }\n\n    function endChallenges() public {\n        uint256 reservesBefore = zchf.balanceOf(address(fps)) - zchf.equity();\n        // revertWith(\"reserves before \", reservesBefore);  // 21000.000000000000000000\n        endChallenge(latestChallenge); // can be absorbed with equity\n        uint256 reservesAfter = zchf.balanceOf(address(fps)) - zchf.equity();\n        require(reservesBefore - reservesAfter == 10000 ether); // latest challenge was 50'000 with 20% reserve\n        // revertWith(\"reserves before \", reservesAfter);  // 11000.000000000000000000\n        // revertWith(\"reserves before \", zchf.equity());     //  8601.000000000000000003\n        // splitAndEnd(latestChallenge - 1);\n    }\n\n    function endChallenge(uint256 challengeNumber) public {\n        uint256 equityBefore = zchf.equity();\n        (address challenger, uint40 start, IPosition p, uint256 size) = hub.challenges(challengeNumber);\n        require(challenger != address(0x0), \"challenge not found\");\n        // hub.end(challengeNumber, true);\n        User user = challenger == address(bob) ? bob : alice;\n        user.reclaimCollateral(hub, p.collateral(), size);\n\n        /*         uint256 borrowedAmount = 50000 * (10 ** 18);\n        uint256 reserve = (borrowedAmount * p.reserveContribution()) / 1000000;\n        uint256 reward = (bid * 20000) / 1000000;\n        uint256 missing = borrowedAmount + reward - bid - reserve;\n        uint256 equityAfter = zchf.equity();\n        uint256 assigned = zchf.calculateAssignedReserve(\n            1000000,\n            uint32(200000)\n        );\n        if (equityBefore >= missing) {\n            string memory message = string(\n                abi.encodePacked(\n                    Strings.toString(equityBefore),\n                    \" \",\n                    Strings.toString(equityAfter),\n                    \" \",\n                    Strings.toString(missing)\n                )\n            );\n            require(equityAfter + missing == equityBefore, message);\n        } else {\n            // revertWith(\"reserve \", assigned); // 50601000000000000000003\n            require(equityAfter == 0, Strings.toString(equityAfter)); // wiped out equity\n            require(\n                assigned == 0 ||\n                    zchf.calculateAssignedReserve(1000000, 200000) < assigned\n            );\n            // theoretical minter reserve at this point: 3000.000000000000000000, actual: 0\n        } */\n    }\n\n    uint256 number;\n\n    function testExcessiveChallengePart1() public {\n        // revertWith(\"reserve \", zchf.balanceOf(address(fps))); // 50601000000000000000003\n        Position pos = Position(latestPosition);\n        //uint256 minted = pos.minted();\n        //        require(minted == 10000 ether, Strings.toString(minted)); // assumes the other tests have been run before\n        uint256 collateralLeft = pos.collateral().balanceOf(latestPosition);\n        require(collateralLeft == 100, Strings.toString(collateralLeft)); // test assumption\n        number = bob.challenge(hub, latestPosition, 101); // challenge more than is left\n        //   alice.repay(pos, 5000 ether);\n        // require(pos.minted() + 5000 ether == minted);\n        // minted is now 9999.999999999999995000\n    }\n\n    function testExcessiveChallengePart2() public {\n        bob.avertChallenge(hub, swap, number);\n    }\n\n    function restructure() public {\n        address[] memory empty = new address[](0);\n        fps.checkQualified(address(alice), empty);\n        fps.checkQualified(address(bob), empty);\n        address[] memory list = new address[](1);\n        list[0] = address(bob);\n        Equity equity = Equity(address(fps));\n        uint256 totalVotes = equity.totalVotes();\n        uint256 supplyBefore = equity.totalSupply();\n        uint256 bobBefore = equity.balanceOf(address(bob));\n        alice.restructure(empty, list);\n        fps.checkQualified(address(alice), empty);\n        require(equity.totalVotes() < totalVotes);\n        require(equity.balanceOf(address(bob)) == 0);\n        uint256 supplyAfter = equity.totalSupply();\n        require(supplyAfter == supplyBefore - bobBefore);\n        // revertWith(\"Shortfall: \", zchf.minterReserve() - zchf.balanceOf(address(fps))); // 1000000000000000000000\n        alice.obtainFrankencoins(swap, 4000 ether);\n        alice.invest(4000 ether);\n        require(supplyAfter + 1000 ether == equity.totalSupply());\n    }\n\n    // poor man's replacement for console.out in solidity...\n    function revertWith(string memory message, uint256 errorNumber) public pure {\n        revert(string(abi.encodePacked(message, Strings.toString(errorNumber))));\n    }\n\n    function challengeExpiredPosition() public {\n        Position pos = Position(latestPosition);\n        require(pos.calculateCurrentFee() == 0);\n        require(pos.expiration() < block.timestamp);\n        uint256 size = pos.collateral().balanceOf(latestPosition);\n        latestChallenge = bob.challenge(hub, latestPosition, size);\n        // revertWith(\"col left \", size); // 100\n        bob.obtainFrankencoins(swap, 5000 ether);\n    }\n\n    function endLastChallenge() public {\n        Position pos = Position(latestPosition);\n        // hub.end(latestChallenge, false);\n        require(pos.collateral().balanceOf(latestPosition) == 0);\n    }\n}\n\ncontract User {\n    IFrankencoin zchf;\n    Equity fps;\n\n    constructor(IFrankencoin zchf_) {\n        zchf = zchf_;\n        fps = Equity(address(zchf.reserve()));\n    }\n\n    function obtainFrankencoins(StablecoinBridge bridge, uint256 amount) public {\n        TestToken xchf = TestToken(address(bridge.chf()));\n        xchf.mint(address(this), amount);\n        xchf.approve(address(bridge), amount);\n        require(xchf.allowance(address(this), address(bridge)) == amount);\n        bridge.mint(amount);\n    }\n\n    function invest(uint256 amount) public {\n        fps.invest(amount, 0);\n    }\n\n    function transfer(IERC20 token, address target, uint256 amount) public {\n        token.transfer(target, amount);\n    }\n\n    function initiatePosition(TestToken col, MintingHub hub) public returns (address) {\n        col.mint(address(this), 1001);\n        col.approve(address(hub), 1001);\n        uint256 balanceBefore = zchf.balanceOf(address(this));\n        address pos = hub.openPosition(\n            address(col),\n            100,\n            1001,\n            1000000 ether,\n            7 days,\n            100 days,\n            1 days,\n            25000,\n            100 * (10 ** 36),\n            200000\n        );\n        require((balanceBefore - hub.OPENING_FEE()) == zchf.balanceOf(address(this)));\n        Position(pos).adjust(0, 1001, 200 * (10 ** 36));\n        Position(pos).adjustPrice(100 * (10 ** 36));\n        return pos;\n    }\n\n    function transferOwnership(address pos, address newOwner) public {\n        Position(pos).transferOwnership(newOwner);\n    }\n\n    function deny(MintingHub, address pos) public {\n        address[] memory empty = new address[](0);\n        Position(pos).deny(empty, \"not approved\");\n    }\n\n    function adjustPosition(address pos) public {\n        Position position = Position(pos);\n        uint256 minted = position.minted();\n        uint256 col = position.collateral().balanceOf(pos);\n        uint256 price = position.price();\n        position.adjust(minted - 100, col - 1, price);\n        position.collateral().approve(pos, 1);\n        position.adjust(minted, col, price);\n        require(position.minted() == minted);\n        require(position.collateral().balanceOf(pos) == col);\n        require(position.price() == price);\n    }\n\n    function repay(Position pos, uint256 amount) public {\n        uint256 balanceBefore = zchf.balanceOf(address(this));\n        require(balanceBefore >= amount);\n        pos.repay(amount);\n        require(zchf.balanceOf(address(this)) + amount == balanceBefore);\n    }\n\n    function testWithdraw(StablecoinBridge bridge, Position pos) public {\n        IERC20 col = pos.collateral();\n        obtainFrankencoins(bridge, 1);\n        bridge.zchf().transfer(address(pos), 1);\n        uint256 initialBalance = col.balanceOf(address(pos));\n        pos.withdraw(address(bridge.zchf()), address(this), 1);\n        Position(pos).withdraw(address(col), address(this), 1);\n        require(col.balanceOf(address(pos)) == initialBalance - 1);\n        require(col.balanceOf(address(this)) == 1);\n    }\n\n    function mint(address pos, uint256 amount) public {\n        uint256 balanceBefore = zchf.balanceOf(address(this));\n        IPosition(pos).mint(address(this), amount);\n        uint256 obtained = zchf.balanceOf(address(this)) - balanceBefore;\n        uint256 usable = IPosition(pos).getUsableMint(amount, true);\n        require(\n            obtained == usable,\n            string(abi.encodePacked(Strings.toString(usable), \" should be \", Strings.toString(obtained)))\n        );\n        uint256 usableBeforeFee = IPosition(pos).getUsableMint(amount, false);\n        require(\n            usable <= 100 || usableBeforeFee > usable,\n            string(\n                abi.encodePacked(Strings.toString(usableBeforeFee), \" should be larger than \", Strings.toString(usable))\n            )\n        );\n    }\n\n    function challenge(MintingHub hub, address pos, uint256 size) public returns (uint256) {\n        IERC20 col = IPosition(pos).collateral();\n        col.approve(address(hub), size);\n        return hub.challenge(pos, size, IPosition(pos).price());\n    }\n\n    function avertChallenge(MintingHub hub, StablecoinBridge swap, uint256 first) public {\n        /* {\n            (, IPosition p, uint256 size, , , ) = hub.challenges(first);\n            uint256 amount = (size * p.price()) / 10 ** 18;\n            obtainFrankencoins(swap, amount);\n            hub.bid(first, amount, size); // avert challenge\n        }\n        (address challenger, , , , , ) = hub.challenges(first);\n        require(challenger == address(0x0), \"challenge not averted\");\n        require(!hub.isChallengeOpen(first)); */\n    }\n\n    function bid(MintingHub hub, uint256 number, uint256 amount) public {\n        /*   (, , uint256 size, , , ) = hub.challenges(number);\n        hub.bid(number, amount, size);\n        require(hub.minBid(number) > amount); // min bid must increase */\n    }\n\n    function reclaimCollateral(MintingHub hub, IERC20 collateral, uint256 expectedAmount) public {\n        uint256 balanceBefore = collateral.balanceOf(address(this));\n        hub.returnPostponedCollateral(address(collateral), address(this));\n        uint256 balanceAfter = collateral.balanceOf(address(this));\n        require(balanceBefore + expectedAmount == balanceAfter);\n    }\n\n    function restructure(address[] calldata helpers, address[] calldata addressesToWipe) public {\n        Equity(address(fps)).restructureCapTable(helpers, addressesToWipe);\n    }\n}\n"
    },
    "contracts/test/MockVOLToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/ERC20.sol\";\n\ncontract MockVOLToken is ERC20 {\n    constructor() ERC20(18) {\n        _mint(msg.sender, 1_000_000 * 1e18);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"VOL volatile mock token\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"VOL\";\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n}\n"
    },
    "contracts/test/PositionExpirationTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Strings.sol\";\nimport \"./TestToken.sol\";\nimport \"../equity/Equity.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../minting/Position.sol\";\nimport \"../minting/MintingHub.sol\";\nimport \"../stablecoin/StablecoinBridge.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../erc20/IERC20.sol\";\n\ncontract PositionExpirationTest {\n\n    MintingHub hub;\n    TestToken col;\n    IFrankencoin zchf;\n\n    constructor(address hub_) {\n        hub = MintingHub(hub_);\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\n        zchf = hub.zchf();\n    }\n\n    function openPositionFor(address owner) public returns (address) {\n        col.mint(address(this), 100);\n        col.approve(address(hub), 100);\n        address pos = hub.openPosition(address(col), 10, 100 /* collateral */, 1000000 * 10**18, 7 days, 30 days, 10 hours, 50000, 1000 * 10**36 /* price */, 200000);\n        Position(pos).transferOwnership(owner);\n        return pos;\n    }\n\n    function forceBuy(address pos, uint256 amount) public {\n        uint256 price = hub.expiredPurchasePrice(Position(pos));\n        uint256 balanceBefore = zchf.balanceOf(address(this));\n        uint256 colBalBefore = col.balanceOf(address(this));\n        hub.buyExpiredCollateral(Position(pos), amount);\n        uint256 balanceAfter = zchf.balanceOf(address(this));\n        uint256 colBalAfter = col.balanceOf(address(this));\n        require(colBalAfter - colBalBefore == amount, \"collateral amount\");\n        require((balanceBefore - balanceAfter) == amount * price / 10**18, \"price paid\");\n    }\n\n}\n"
    },
    "contracts/test/PositionRollingTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Strings.sol\";\nimport \"./TestToken.sol\";\nimport \"../equity/Equity.sol\";\nimport \"../utils/Ownable.sol\";\nimport \"../minting/Position.sol\";\nimport \"../minting/MintingHub.sol\";\nimport \"../stablecoin/StablecoinBridge.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../erc20/IERC20.sol\";\n\ncontract PositionRollingTest {\n\n    MintingHub hub;\n    TestToken col;\n    IFrankencoin zchf;\n    PositionRoller roller;\n\n    IPosition public p1;\n    IPosition public p2;\n\n    constructor(address hub_) {\n        hub = MintingHub(hub_);\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\n        zchf = hub.zchf();\n        roller = hub.roller();\n    }\n\n    function openTwoPositions() public {\n        p1 = IPosition(openPosition(100, uint40(3 days)));\n        p2 = IPosition(openPosition(10, uint40(7 days)));\n    }\n\n    function mintFromFirstPosition(uint256 amount) public {\n        p1.mint(address(this), amount);\n    }\n\n    function openPosition(uint256 collateral, uint40 initializationDelay) public returns (address) {\n        col.mint(address(this), collateral);\n        col.approve(address(hub), collateral);\n        return hub.openPosition(address(col), 10, collateral, 1000000 * 10**18, initializationDelay, 30 days, 10 hours, 50000, 1000 * 10**36, 200000);\n    }\n\n    function roll() public {\n        col.approve(address(roller), col.balanceOf(address(p1))); // approve full balance\n        roller.rollFully(p1, p2);\n        require(p1.minted() == 0);\n        require(zchf.balanceOf(address(this)) == 0);\n    }\n\n}\n"
    },
    "contracts/test/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}"
    },
    "contracts/test/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Math.sol\";\nimport \"./SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}"
    },
    "contracts/test/TestMathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/MathUtil.sol\";\n\ncontract TestMathUtil is MathUtil {\n\n    uint256 public result;\n\n    constructor(){\n        result = 1;\n    }\n\n    // make it a transaction so we can measure gas costs in our tests\n    function cubicRoot(uint256 a, bool recordResult) external {\n        uint256 r = _cubicRoot(a); \n        if (recordResult){\n            result = r;\n        }\n    }\n\n    function calculateShares(uint256 totalShares, uint256 capitalBefore, uint256 investment) external pure returns (uint256) {\n        uint256 newTotalShares = _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    function mulD18(uint256 _a, uint256 _b) external pure returns (uint256) {\n        return _mulD18(_a, _b);\n    }\n\n    function divD18(uint256 _a, uint256 _b) external pure returns (uint256) {\n        return _divD18(_a, _b);\n    }\n\n    function power3(uint256 _x) external pure returns (uint256) {\n        return _power3(_x);\n    }\n}\n"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/ERC20.sol\";\n\ncontract TestToken is ERC20 {\n    string public name;\n    string public symbol;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 dec\n    ) ERC20(dec) {\n        name = name_;\n        symbol = symbol_;\n\n        _mint(msg.sender, 1_000_000 * 1e18);\n    }\n\n    function mint(address _account, uint256 _amount) external {\n        _mint(_account, _amount);\n    }\n}\n"
    },
    "contracts/test/TestTokenAdminRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\ncontract TestTokenAdminRegistry {\n    struct TokenConfig {\n        address administrator; // the current administrator of the token\n        address pendingAdministrator; // the address that is pending to become the new administrator\n        address tokenPool; // the token pool for this token. Can be address(0) if not deployed or not configured.\n    }\n\n    mapping(address => TokenConfig) public tokenConfigs;\n\n    event FunctionCalled(string name, bytes args);\n\n    function getPool(address token) external returns (address) {\n        emit FunctionCalled(\"getPool\", abi.encode(token));\n        return address(0);\n    }\n\n    function proposeAdministrator(address localToken, address administrator) external {\n        emit FunctionCalled(\"proposeAdministrator\", abi.encode(localToken, administrator));\n    }\n\n    function acceptAdminRole(address localToken) external {\n        emit FunctionCalled(\"acceptAdminRole\", abi.encode(localToken));\n    }\n\n    function setPool(address localToken, address pool) external {\n        emit FunctionCalled(\"setPool\", abi.encode(localToken, pool));\n    }\n\n    function transferAdminRole(address localToken, address newAdmin) external {\n        emit FunctionCalled(\"transferAdminRole\", abi.encode(localToken, newAdmin));\n    }\n\n    function setTokenConfig(address token, TokenConfig memory config) external {\n        tokenConfigs[token] = config;\n    }\n\n    function getTokenConfig(address token) external returns (TokenConfig memory) {\n        emit FunctionCalled(\"getTokenConfig\", abi.encode(token));\n        return tokenConfigs[token];\n    }\n}\n"
    },
    "contracts/test/TestTokenPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {ITokenPool} from \"../bridge/ITokenPool.sol\";\nimport {RateLimiter} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol\";\n\ncontract TestTokenPool is ITokenPool {\n    event FunctionCalled(string name, bytes args);\n\n    function addRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external {\n        emit FunctionCalled(\"addRemotePool\", abi.encode(remoteChainSelector, remotePoolAddress));\n    }\n    function removeRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external {\n        emit FunctionCalled(\"removeRemotePool\", abi.encode(remoteChainSelector, remotePoolAddress));\n    }\n    function setChainRateLimiterConfig(\n        uint64 remoteChainSelectors,\n        RateLimiter.Config calldata outboundConfigs,\n        RateLimiter.Config calldata inboundConfigs\n    ) external {\n        emit FunctionCalled(\n            \"setChainRateLimiterConfig\",\n            abi.encode(remoteChainSelectors, outboundConfigs, inboundConfigs)\n        );\n    }\n    function applyChainUpdates(\n        uint64[] calldata remoteChainSelectorsToRemove,\n        ChainUpdate[] calldata chainsToAdd\n    ) external {\n        emit FunctionCalled(\"applyChainUpdates\", abi.encode(remoteChainSelectorsToRemove, chainsToAdd));\n    }\n\n    function acceptOwnership() external {\n        emit FunctionCalled(\"acceptOwnership\", \"\");\n    }\n    function transferOwnership(address to) external {\n        emit FunctionCalled(\"transferOwnership\", abi.encode(to));\n    }\n}\n"
    },
    "contracts/trading/Arbitrage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\ninterface IUniswapV3SwapCallback {\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\n}\n\ncontract Arbitrage is IUniswapV3SwapCallback {\n\n    IERC20 public immutable ZCHF;\n    IERC20 public immutable USDT;\n\n    IUniswapV3Pool public immutable POOL;\n    AggregatorV3Interface public immutable FEED;\n\n    event Balanced(uint256 priceBeforeE8, uint256 targetE8, uint256 priceAfterE8, int256 zchfFlowE18, int256 usdFlowE6, int256 profitsE6);\n    error NotProfitableEnough(int256 zchfFlowE18, int256 usdFlowE6, int256 profitsE6);\n\n    constructor() {\n        POOL = IUniswapV3Pool(0x8E4318E2cb1ae291254B187001a59a1f8ac78cEF);\n        FEED = AggregatorV3Interface(0x449d117117838fFA61263B61dA6301AA2a88B13A);\n        ZCHF = IERC20(0xB58E61C3098d85632Df34EecfB899A1Ed80921cB);\n        USDT = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n    }\n\n    function getChainlinkPrice() public view returns (uint256) {\n        (, int256 price,,,) = FEED.latestRoundData();\n        require(price > 0, \"Invalid price\");\n        return uint256(price); // 8 decimals\n    }\n\n    function convertToUniswapPrice(uint256 chainlinkPrice) public pure returns (uint160){\n        uint256 temp = chainlinkPrice << 192; // should not cause overflow as 1e8 is much less than 256 - 192 = 64 bits, whereas chainlink's 8 decimals are about 24 bits\n        return uint160(sqrt(temp) / 1e10);\n    }\n\n    function getUniswapPrice() public view returns (uint160) {\n        (uint160 sqrtPriceX96,,,,,,) = POOL.slot0();\n        return sqrtPriceX96;\n    }\n\n    function convertToChainlinkPrice(uint160 sqrtPriceX96) public pure returns (uint256){\n        uint256 temp = sqrtPriceX96 * (1e10) >> 96;\n        return temp * temp; // price ratio with 8 digits\n    }\n\n    function balance(int256 minProfitUSDTe6) external returns(int256, uint160, bytes memory) {\n        uint160 currentPrice = getUniswapPrice();\n\n        uint256 chainlinkPrice = getChainlinkPrice();\n        uint160 targetSqrtPriceX96 = convertToUniswapPrice(chainlinkPrice);\n        bool buyCHF = currentPrice < targetSqrtPriceX96;\n        int256 balanceZCHFBefore = int256(ZCHF.balanceOf(msg.sender));\n        int256 balanceUSDTBefore = int256(USDT.balanceOf(msg.sender));\n        int256 max = buyCHF ? balanceUSDTBefore : balanceZCHFBefore;\n\n        POOL.swap(msg.sender, !buyCHF, max, targetSqrtPriceX96, abi.encode(msg.sender));\n\n        int256 balanceZCHFAfter = int256(ZCHF.balanceOf(msg.sender));\n        int256 balanceUSDTAfter = int256(USDT.balanceOf(msg.sender));\n\n        int256 flowCHF = balanceZCHFAfter - balanceZCHFBefore;\n        int256 flowUSD = balanceUSDTAfter - balanceUSDTBefore;\n        int256 profits = flowUSD * 1e12 + flowCHF * int256(uint256(chainlinkPrice)) / 1e8;\n        if (profits < minProfitUSDTe6) revert NotProfitableEnough(flowCHF, flowUSD, profits);\n        emit Balanced(convertToChainlinkPrice(currentPrice), chainlinkPrice, convertToChainlinkPrice(getUniswapPrice()), flowCHF, flowUSD, profits);\n    }\n\n    function swap(bool buyCHF, int256 max, uint160 targetPrice) external {\n        POOL.swap(msg.sender, !buyCHF, max, targetPrice, abi.encode(msg.sender));\n    }\n\n    function sqrt(uint256 x) internal pure returns (uint256 y) {\n        uint256 z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n    }\n\n    function uniswapV3SwapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external {\n        require(msg.sender == address(POOL), \"Unauthorized\");\n        address sender = abi.decode(data, (address));\n        if (amount0Delta > 0) {\n            IERC20(ZCHF).transferFrom(sender, msg.sender, uint256(amount0Delta));\n        }\n        if (amount1Delta > 0) {\n            IERC20(USDT).transferFrom(sender, msg.sender, uint256(amount1Delta));\n        }\n    }\n}\n\ninterface IERC20 {\n    function transferFrom(address sender, address recipient, uint256 amount) external;\n    function balanceOf(address owner) external returns (uint256);\n}\n\ninterface AggregatorV3Interface {\n    function latestRoundData() external view returns (uint80, int256, uint256, uint256, uint80);\n}\n\ninterface IUniswapV3Pool {\n    function slot0() external view returns (uint160, int24, uint16, uint16, uint16, uint8, bool);\n\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external;\n}"
    },
    "contracts/utils/MathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Functions for share valuation\n */\ncontract MathUtil {\n    uint256 internal constant ONE_DEC18 = 10 ** 18;\n\n    // Let's go for 12 digits of precision (18-6)\n    uint256 internal constant THRESH_DEC18 = 10 ** 6;\n\n    /**\n     * @notice Cubic root with Halley approximation\n     *         Number 1e18 decimal\n     * @param _v     number for which we calculate x**(1/3)\n     * @return returns _v**(1/3)\n     */\n    function _cubicRoot(uint256 _v) internal pure returns (uint256) {\n        // Good first guess for _v slightly above 1.0, which is often the case in the Frankencoin system\n        uint256 x = _v > ONE_DEC18 && _v < 10 ** 19 ? (_v - ONE_DEC18) / 3 + ONE_DEC18 : ONE_DEC18;\n        uint256 diff;\n        do {\n            uint256 powX3 = _mulD18(_mulD18(x, x), x);\n            uint256 xnew = x * (powX3 + 2 * _v) / (2 * powX3 + _v);\n            diff = xnew > x ? xnew - x : x - xnew;\n            x = xnew;\n        } while (diff > THRESH_DEC18);\n        return x;\n    }\n\n    function _mulD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * _b) / ONE_DEC18;\n    }\n\n    function _divD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * ONE_DEC18) / _b;\n    }\n\n    function _power3(uint256 _x) internal pure returns (uint256) {\n        return _mulD18(_mulD18(_x, _x), _x);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n */\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    error NotOwner();\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public onlyOwner {\n        _setOwner(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _setOwner(address newOwner) internal {\n        require(newOwner != address(0x0));\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    function _requireOwner(address sender) internal view {\n        if (owner != sender) revert NotOwner();\n    }\n\n    modifier onlyOwner() {\n        _requireOwner(msg.sender);\n        _;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}