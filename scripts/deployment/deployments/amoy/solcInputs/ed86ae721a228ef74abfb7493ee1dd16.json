{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IAny2EVMMessageReceiver} from \"../interfaces/IAny2EVMMessageReceiver.sol\";\n\nimport {Client} from \"../libraries/Client.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @title CCIPReceiver - Base contract for CCIP applications that can receive messages.\nabstract contract CCIPReceiver is IAny2EVMMessageReceiver, IERC165 {\n  address internal immutable i_ccipRouter;\n\n  constructor(\n    address router\n  ) {\n    if (router == address(0)) revert InvalidRouter(address(0));\n    i_ccipRouter = router;\n  }\n\n  /// @notice IERC165 supports an interfaceId\n  /// @param interfaceId The interfaceId to check\n  /// @return true if the interfaceId is supported\n  /// @dev Should indicate whether the contract implements IAny2EVMMessageReceiver\n  /// e.g. return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId\n  /// This allows CCIP to check if ccipReceive is available before calling it.\n  /// If this returns false or reverts, only tokens are transferred to the receiver.\n  /// If this returns true, tokens are transferred and ccipReceive is called atomically.\n  /// Additionally, if the receiver address does not have code associated with\n  /// it at the time of execution (EXTCODESIZE returns 0), only tokens will be transferred.\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public view virtual override returns (bool) {\n    return interfaceId == type(IAny2EVMMessageReceiver).interfaceId || interfaceId == type(IERC165).interfaceId;\n  }\n\n  /// @inheritdoc IAny2EVMMessageReceiver\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external virtual override onlyRouter {\n    _ccipReceive(message);\n  }\n\n  /// @notice Override this function in your implementation.\n  /// @param message Any2EVMMessage\n  function _ccipReceive(\n    Client.Any2EVMMessage memory message\n  ) internal virtual;\n\n  /////////////////////////////////////////////////////////////////////\n  // Plumbing\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Return the current router\n  /// @return CCIP router address\n  function getRouter() public view virtual returns (address) {\n    return address(i_ccipRouter);\n  }\n\n  error InvalidRouter(address router);\n\n  /// @dev only calls from the set router are accepted.\n  modifier onlyRouter() {\n    if (msg.sender != getRouter()) revert InvalidRouter(msg.sender);\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IAny2EVMMessageReceiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\n/// @notice Application contracts that intend to receive messages from\n/// the router should implement this interface.\ninterface IAny2EVMMessageReceiver {\n  /// @notice Called by the Router to deliver a message.\n  /// If this reverts, any token transfers also revert. The message\n  /// will move to a FAILED state and become available for manual execution.\n  /// @param message CCIP Message\n  /// @dev Note ensure you check the msg.sender is the OffRampRouter\n  function ccipReceive(\n    Client.Any2EVMMessage calldata message\n  ) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IGetCCIPAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGetCCIPAdmin {\n  /// @notice Returns the admin of the token.\n  /// @dev This method is named to never conflict with existing methods.\n  function getCCIPAdmin() external view returns (address);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwner {\n  /// @notice Returns the owner of the contract.\n  /// @dev This method is named to match with the OpenZeppelin Ownable contract.\n  function owner() external view returns (address);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Pool} from \"../libraries/Pool.sol\";\n\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\n\n/// @notice Shared public interface for multiple V1 pool types.\n/// Each pool type handles a different child token model (lock/unlock, mint/burn.)\ninterface IPoolV1 is IERC165 {\n  /// @notice Lock tokens into the pool or burn the tokens.\n  /// @param lockOrBurnIn Encoded data fields for the processing of tokens on the source chain.\n  /// @return lockOrBurnOut Encoded data fields for the processing of tokens on the destination chain.\n  function lockOrBurn(\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\n  ) external returns (Pool.LockOrBurnOutV1 memory lockOrBurnOut);\n\n  /// @notice Releases or mints tokens to the receiver address.\n  /// @param releaseOrMintIn All data required to release or mint tokens.\n  /// @return releaseOrMintOut The amount of tokens released or minted on the local chain, denominated\n  /// in the local token's decimals.\n  /// @dev The offramp asserts that the balanceOf of the receiver has been incremented by exactly the number\n  /// of tokens that is returned in ReleaseOrMintOutV1.destinationAmount. If the amounts do not match, the tx reverts.\n  function releaseOrMint(\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\n  ) external returns (Pool.ReleaseOrMintOutV1 memory);\n\n  /// @notice Checks whether a remote chain is supported in the token pool.\n  /// @param remoteChainSelector The selector of the remote chain.\n  /// @return true if the given chain is a permissioned remote chain.\n  function isSupportedChain(\n    uint64 remoteChainSelector\n  ) external view returns (bool);\n\n  /// @notice Returns if the token pool supports the given token.\n  /// @param token The address of the token.\n  /// @return true if the token is supported by the pool.\n  function isSupportedToken(\n    address token\n  ) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRMN.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice This interface contains the only RMN-related functions that might be used on-chain by other CCIP contracts.\ninterface IRMN {\n  /// @notice A Merkle root tagged with the address of the commit store contract it is destined for.\n  struct TaggedRoot {\n    address commitStore;\n    bytes32 root;\n  }\n\n  /// @notice Callers MUST NOT cache the return value as a blessed tagged root could become unblessed.\n  function isBlessed(\n    TaggedRoot calldata taggedRoot\n  ) external view returns (bool);\n\n  /// @notice Iff there is an active global or legacy curse, this function returns true.\n  function isCursed() external view returns (bool);\n\n  /// @notice Iff there is an active global curse, or an active curse for `subject`, this function returns true.\n  /// @param subject To check whether a particular chain is cursed, set to bytes16(uint128(chainSelector)).\n  function isCursed(\n    bytes16 subject\n  ) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouter {\n  error OnlyOffRamp();\n\n  /// @notice Route the message to its intended receiver contract.\n  /// @param message Client.Any2EVMMessage struct.\n  /// @param gasForCallExactCheck of params for exec\n  /// @param gasLimit set of params for exec\n  /// @param receiver set of params for exec\n  /// @dev if the receiver is a contracts that signals support for CCIP execution through EIP-165.\n  /// the contract is called. If not, only tokens are transferred.\n  /// @return success A boolean value indicating whether the ccip message was received without errors.\n  /// @return retBytes A bytes array containing return data form CCIP receiver.\n  /// @return gasUsed the gas used by the external customer call. Does not include any overhead.\n  function routeMessage(\n    Client.Any2EVMMessage calldata message,\n    uint16 gasForCallExactCheck,\n    uint256 gasLimit,\n    address receiver\n  ) external returns (bool success, bytes memory retBytes, uint256 gasUsed);\n\n  /// @notice Returns the configured onramp for a specific destination chain.\n  /// @param destChainSelector The destination chain Id to get the onRamp for.\n  /// @return onRampAddress The address of the onRamp.\n  function getOnRamp(\n    uint64 destChainSelector\n  ) external view returns (address onRampAddress);\n\n  /// @notice Return true if the given offRamp is a configured offRamp for the given source chain.\n  /// @param sourceChainSelector The source chain selector to check.\n  /// @param offRamp The address of the offRamp to check.\n  function isOffRamp(uint64 sourceChainSelector, address offRamp) external view returns (bool isOffRamp);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Client} from \"../libraries/Client.sol\";\n\ninterface IRouterClient {\n  error UnsupportedDestinationChain(uint64 destChainSelector);\n  error InsufficientFeeTokenAmount();\n  error InvalidMsgValue();\n\n  /// @notice Checks if the given chain ID is supported for sending/receiving.\n  /// @param destChainSelector The chain to check.\n  /// @return supported is true if it is supported, false if not.\n  function isChainSupported(\n    uint64 destChainSelector\n  ) external view returns (bool supported);\n\n  /// @param destinationChainSelector The destination chainSelector\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return fee returns execution fee for the message\n  /// delivery to destination chain, denominated in the feeToken specified in the message.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function getFee(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage memory message\n  ) external view returns (uint256 fee);\n\n  /// @notice Request a message to be sent to the destination chain\n  /// @param destinationChainSelector The destination chain ID\n  /// @param message The cross-chain CCIP message including data and/or tokens\n  /// @return messageId The message ID\n  /// @dev Note if msg.value is larger than the required fee (from getFee) we accept\n  /// the overpayment with no refund.\n  /// @dev Reverts with appropriate reason upon invalid message.\n  function ccipSend(\n    uint64 destinationChainSelector,\n    Client.EVM2AnyMessage calldata message\n  ) external payable returns (bytes32);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/ITokenAdminRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\ninterface ITokenAdminRegistry {\n  /// @notice Returns the pool for the given token.\n  function getPool(\n    address token\n  ) external view returns (address);\n\n  /// @notice Proposes an administrator for the given token as pending administrator.\n  /// @param localToken The token to register the administrator for.\n  /// @param administrator The administrator to register.\n  function proposeAdministrator(address localToken, address administrator) external;\n\n  /// @notice Accepts the administrator role for a token.\n  /// @param localToken The token to accept the administrator role for.\n  /// @dev This function can only be called by the pending administrator.\n  function acceptAdminRole(\n    address localToken\n  ) external;\n\n  /// @notice Sets the pool for a token. Setting the pool to address(0) effectively delists the token\n  /// from CCIP. Setting the pool to any other address enables the token on CCIP.\n  /// @param localToken The token to set the pool for.\n  /// @param pool The pool to set for the token.\n  function setPool(address localToken, address pool) external;\n\n  /// @notice Transfers the administrator role for a token to a new address with a 2-step process.\n  /// @param localToken The token to transfer the administrator role for.\n  /// @param newAdmin The address to transfer the administrator role to. Can be address(0) to cancel\n  /// a pending transfer.\n  /// @dev The new admin must call `acceptAdminRole` to accept the role.\n  function transferAdminRole(address localToken, address newAdmin) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// End consumer library.\nlibrary Client {\n  /// @dev RMN depends on this struct, if changing, please notify the RMN maintainers.\n  struct EVMTokenAmount {\n    address token; // token address on the local chain.\n    uint256 amount; // Amount of tokens.\n  }\n\n  struct Any2EVMMessage {\n    bytes32 messageId; // MessageId corresponding to ccipSend on source.\n    uint64 sourceChainSelector; // Source chain selector.\n    bytes sender; // abi.decode(sender) if coming from an EVM chain.\n    bytes data; // payload sent in original message.\n    EVMTokenAmount[] destTokenAmounts; // Tokens and their amounts in their destination chain representation.\n  }\n\n  // If extraArgs is empty bytes, the default is 200k gas limit.\n  struct EVM2AnyMessage {\n    bytes receiver; // abi.encode(receiver address) for dest EVM chains\n    bytes data; // Data payload\n    EVMTokenAmount[] tokenAmounts; // Token transfers\n    address feeToken; // Address of feeToken. address(0) means you will send msg.value.\n    bytes extraArgs; // Populate this with _argsToBytes(EVMExtraArgsV2)\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV1\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V1_TAG = 0x97a657c9;\n\n  struct EVMExtraArgsV1 {\n    uint256 gasLimit;\n  }\n\n  function _argsToBytes(\n    EVMExtraArgsV1 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V1_TAG, extraArgs);\n  }\n\n  // bytes4(keccak256(\"CCIP EVMExtraArgsV2\"));\n  bytes4 public constant EVM_EXTRA_ARGS_V2_TAG = 0x181dcf10;\n\n  /// @param gasLimit: gas limit for the callback on the destination chain.\n  /// @param allowOutOfOrderExecution: if true, it indicates that the message can be executed in any order relative to other messages from the same sender.\n  /// This value's default varies by chain. On some chains, a particular value is enforced, meaning if the expected value\n  /// is not set, the message request will revert.\n  struct EVMExtraArgsV2 {\n    uint256 gasLimit;\n    bool allowOutOfOrderExecution;\n  }\n\n  function _argsToBytes(\n    EVMExtraArgsV2 memory extraArgs\n  ) internal pure returns (bytes memory bts) {\n    return abi.encodeWithSelector(EVM_EXTRA_ARGS_V2_TAG, extraArgs);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @notice This library contains various token pool functions to aid constructing the return data.\nlibrary Pool {\n  // The tag used to signal support for the pool v1 standard\n  // bytes4(keccak256(\"CCIP_POOL_V1\"))\n  bytes4 public constant CCIP_POOL_V1 = 0xaff2afbf;\n\n  // The number of bytes in the return data for a pool v1 releaseOrMint call.\n  // This should match the size of the ReleaseOrMintOutV1 struct.\n  uint16 public constant CCIP_POOL_V1_RET_BYTES = 32;\n\n  // The default max number of bytes in the return data for a pool v1 lockOrBurn call.\n  // This data can be used to send information to the destination chain token pool. Can be overwritten\n  // in the TokenTransferFeeConfig.destBytesOverhead if more data is required.\n  uint32 public constant CCIP_LOCK_OR_BURN_V1_RET_BYTES = 32;\n\n  struct LockOrBurnInV1 {\n    bytes receiver; //  The recipient of the tokens on the destination chain, abi encoded\n    uint64 remoteChainSelector; // ─╮ The chain ID of the destination chain\n    address originalSender; // ─────╯ The original sender of the tx on the source chain\n    uint256 amount; //  The amount of tokens to lock or burn, denominated in the source token's decimals\n    address localToken; //  The address on this chain of the token to lock or burn\n  }\n\n  struct LockOrBurnOutV1 {\n    // The address of the destination token, abi encoded in the case of EVM chains\n    // This value is UNTRUSTED as any pool owner can return whatever value they want.\n    bytes destTokenAddress;\n    // Optional pool data to be transferred to the destination chain. Be default this is capped at\n    // CCIP_LOCK_OR_BURN_V1_RET_BYTES bytes. If more data is required, the TokenTransferFeeConfig.destBytesOverhead\n    // has to be set for the specific token.\n    bytes destPoolData;\n  }\n\n  struct ReleaseOrMintInV1 {\n    bytes originalSender; //          The original sender of the tx on the source chain\n    uint64 remoteChainSelector; // ─╮ The chain ID of the source chain\n    address receiver; // ───────────╯ The recipient of the tokens on the destination chain.\n    uint256 amount; //                The amount of tokens to release or mint, denominated in the source token's decimals\n    address localToken; //            The address on this chain of the token to release or mint\n    /// @dev WARNING: sourcePoolAddress should be checked prior to any processing of funds. Make sure it matches the\n    /// expected pool address for the given remoteChainSelector.\n    bytes sourcePoolAddress; //       The address of the source pool, abi encoded in the case of EVM chains\n    bytes sourcePoolData; //          The data received from the source pool to process the release or mint\n    /// @dev WARNING: offchainTokenData is untrusted data.\n    bytes offchainTokenData; //       The offchain data to process the release or mint\n  }\n\n  struct ReleaseOrMintOutV1 {\n    // The number of tokens released or minted on the destination chain, denominated in the local token's decimals.\n    // This value is expected to be equal to the ReleaseOrMintInV1.amount in the case where the source and destination\n    // chain have the same number of decimals.\n    uint256 destinationAmount;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.4;\n\n/// @notice Implements Token Bucket rate limiting.\n/// @dev uint128 is safe for rate limiter state.\n/// For USD value rate limiting, it can adequately store USD value in 18 decimals.\n/// For ERC20 token amount rate limiting, all tokens that will be listed will have at most\n/// a supply of uint128.max tokens, and it will therefore not overflow the bucket.\n/// In exceptional scenarios where tokens consumed may be larger than uint128,\n/// e.g. compromised issuer, an enabled RateLimiter will check and revert.\nlibrary RateLimiter {\n  error BucketOverfilled();\n  error OnlyCallableByAdminOrOwner();\n  error TokenMaxCapacityExceeded(uint256 capacity, uint256 requested, address tokenAddress);\n  error TokenRateLimitReached(uint256 minWaitInSeconds, uint256 available, address tokenAddress);\n  error AggregateValueMaxCapacityExceeded(uint256 capacity, uint256 requested);\n  error AggregateValueRateLimitReached(uint256 minWaitInSeconds, uint256 available);\n  error InvalidRateLimitRate(Config rateLimiterConfig);\n  error DisabledNonZeroRateLimit(Config config);\n  error RateLimitMustBeDisabled();\n\n  event TokensConsumed(uint256 tokens);\n  event ConfigChanged(Config config);\n\n  struct TokenBucket {\n    uint128 tokens; // ──────╮ Current number of tokens that are in the bucket.\n    uint32 lastUpdated; //   │ Timestamp in seconds of the last token refill, good for 100+ years.\n    bool isEnabled; // ──────╯ Indication whether the rate limiting is enabled or not\n    uint128 capacity; // ────╮ Maximum number of tokens that can be in the bucket.\n    uint128 rate; // ────────╯ Number of tokens per second that the bucket is refilled.\n  }\n\n  struct Config {\n    bool isEnabled; // Indication whether the rate limiting should be enabled\n    uint128 capacity; // ────╮ Specifies the capacity of the rate limiter\n    uint128 rate; //  ───────╯ Specifies the rate of the rate limiter\n  }\n\n  /// @notice _consume removes the given tokens from the pool, lowering the\n  /// rate tokens allowed to be consumed for subsequent calls.\n  /// @param requestTokens The total tokens to be consumed from the bucket.\n  /// @param tokenAddress The token to consume capacity for, use 0x0 to indicate aggregate value capacity.\n  /// @dev Reverts when requestTokens exceeds bucket capacity or available tokens in the bucket\n  /// @dev emits removal of requestTokens if requestTokens is > 0\n  function _consume(TokenBucket storage s_bucket, uint256 requestTokens, address tokenAddress) internal {\n    // If there is no value to remove or rate limiting is turned off, skip this step to reduce gas usage\n    if (!s_bucket.isEnabled || requestTokens == 0) {\n      return;\n    }\n\n    uint256 tokens = s_bucket.tokens;\n    uint256 capacity = s_bucket.capacity;\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\n\n    if (timeDiff != 0) {\n      if (tokens > capacity) revert BucketOverfilled();\n\n      // Refill tokens when arriving at a new block time\n      tokens = _calculateRefill(capacity, tokens, timeDiff, s_bucket.rate);\n\n      s_bucket.lastUpdated = uint32(block.timestamp);\n    }\n\n    if (capacity < requestTokens) {\n      // Token address 0 indicates consuming aggregate value rate limit capacity.\n      if (tokenAddress == address(0)) revert AggregateValueMaxCapacityExceeded(capacity, requestTokens);\n      revert TokenMaxCapacityExceeded(capacity, requestTokens, tokenAddress);\n    }\n    if (tokens < requestTokens) {\n      uint256 rate = s_bucket.rate;\n      // Wait required until the bucket is refilled enough to accept this value, round up to next higher second\n      // Consume is not guaranteed to succeed after wait time passes if there is competing traffic.\n      // This acts as a lower bound of wait time.\n      uint256 minWaitInSeconds = ((requestTokens - tokens) + (rate - 1)) / rate;\n\n      if (tokenAddress == address(0)) revert AggregateValueRateLimitReached(minWaitInSeconds, tokens);\n      revert TokenRateLimitReached(minWaitInSeconds, tokens, tokenAddress);\n    }\n    tokens -= requestTokens;\n\n    // Downcast is safe here, as tokens is not larger than capacity\n    s_bucket.tokens = uint128(tokens);\n    emit TokensConsumed(requestTokens);\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function _currentTokenBucketState(\n    TokenBucket memory bucket\n  ) internal view returns (TokenBucket memory) {\n    // We update the bucket to reflect the status at the exact time of the\n    // call. This means we might need to refill a part of the bucket based\n    // on the time that has passed since the last update.\n    bucket.tokens =\n      uint128(_calculateRefill(bucket.capacity, bucket.tokens, block.timestamp - bucket.lastUpdated, bucket.rate));\n    bucket.lastUpdated = uint32(block.timestamp);\n    return bucket;\n  }\n\n  /// @notice Sets the rate limited config.\n  /// @param s_bucket The token bucket\n  /// @param config The new config\n  function _setTokenBucketConfig(TokenBucket storage s_bucket, Config memory config) internal {\n    // First update the bucket to make sure the proper rate is used for all the time\n    // up until the config change.\n    uint256 timeDiff = block.timestamp - s_bucket.lastUpdated;\n    if (timeDiff != 0) {\n      s_bucket.tokens = uint128(_calculateRefill(s_bucket.capacity, s_bucket.tokens, timeDiff, s_bucket.rate));\n\n      s_bucket.lastUpdated = uint32(block.timestamp);\n    }\n\n    s_bucket.tokens = uint128(_min(config.capacity, s_bucket.tokens));\n    s_bucket.isEnabled = config.isEnabled;\n    s_bucket.capacity = config.capacity;\n    s_bucket.rate = config.rate;\n\n    emit ConfigChanged(config);\n  }\n\n  /// @notice Validates the token bucket config\n  function _validateTokenBucketConfig(Config memory config, bool mustBeDisabled) internal pure {\n    if (config.isEnabled) {\n      if (config.rate >= config.capacity || config.rate == 0) {\n        revert InvalidRateLimitRate(config);\n      }\n      if (mustBeDisabled) {\n        revert RateLimitMustBeDisabled();\n      }\n    } else {\n      if (config.rate != 0 || config.capacity != 0) {\n        revert DisabledNonZeroRateLimit(config);\n      }\n    }\n  }\n\n  /// @notice Calculate refilled tokens\n  /// @param capacity bucket capacity\n  /// @param tokens current bucket tokens\n  /// @param timeDiff block time difference since last refill\n  /// @param rate bucket refill rate\n  /// @return the value of tokens after refill\n  function _calculateRefill(\n    uint256 capacity,\n    uint256 tokens,\n    uint256 timeDiff,\n    uint256 rate\n  ) private pure returns (uint256) {\n    return _min(capacity, tokens + timeDiff * rate);\n  }\n\n  /// @notice Return the smallest of two integers\n  /// @param a first int\n  /// @param b second int\n  /// @return smallest\n  function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/pools/TokenPool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {IPoolV1} from \"../interfaces/IPool.sol\";\nimport {IRMN} from \"../interfaces/IRMN.sol\";\nimport {IRouter} from \"../interfaces/IRouter.sol\";\n\nimport {Ownable2StepMsgSender} from \"../../shared/access/Ownable2StepMsgSender.sol\";\nimport {Pool} from \"../libraries/Pool.sol\";\nimport {RateLimiter} from \"../libraries/RateLimiter.sol\";\n\nimport {IERC20} from \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from\n  \"../../vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {IERC165} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @dev This pool supports different decimals on different chains but using this feature could impact the total number\n/// of tokens in circulation. Since all of the tokens are locked/burned on the source, and a rounded amount is minted/released on the\n/// destination, the number of tokens minted/released could be less than the number of tokens burned/locked. This is because the source\n/// chain does not know about the destination token decimals. This is not a problem if the decimals are the same on both\n/// chains.\n///\n/// Example:\n/// Assume there is a token with 6 decimals on chain A and 3 decimals on chain B.\n/// - 1.234567 tokens are burned on chain A.\n/// - 1.234    tokens are minted on chain B.\n/// When sending the 1.234 tokens back to chain A, you will receive 1.234000 tokens on chain A, effectively losing\n/// 0.000567 tokens.\n/// In the case of a burnMint pool on chain A, these funds are burned in the pool on chain A.\n/// In the case of a lockRelease pool on chain A, these funds accumulate in the pool on chain A.\nabstract contract TokenPool is IPoolV1, Ownable2StepMsgSender {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using RateLimiter for RateLimiter.TokenBucket;\n\n  error CallerIsNotARampOnRouter(address caller);\n  error ZeroAddressNotAllowed();\n  error SenderNotAllowed(address sender);\n  error AllowListNotEnabled();\n  error NonExistentChain(uint64 remoteChainSelector);\n  error ChainNotAllowed(uint64 remoteChainSelector);\n  error CursedByRMN();\n  error ChainAlreadyExists(uint64 chainSelector);\n  error InvalidSourcePoolAddress(bytes sourcePoolAddress);\n  error InvalidToken(address token);\n  error Unauthorized(address caller);\n  error PoolAlreadyAdded(uint64 remoteChainSelector, bytes remotePoolAddress);\n  error InvalidRemotePoolForChain(uint64 remoteChainSelector, bytes remotePoolAddress);\n  error InvalidRemoteChainDecimals(bytes sourcePoolData);\n  error MismatchedArrayLengths();\n  error OverflowDetected(uint8 remoteDecimals, uint8 localDecimals, uint256 remoteAmount);\n  error InvalidDecimalArgs(uint8 expected, uint8 actual);\n\n  event Locked(address indexed sender, uint256 amount);\n  event Burned(address indexed sender, uint256 amount);\n  event Released(address indexed sender, address indexed recipient, uint256 amount);\n  event Minted(address indexed sender, address indexed recipient, uint256 amount);\n  event ChainAdded(\n    uint64 remoteChainSelector,\n    bytes remoteToken,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n  event ChainConfigured(\n    uint64 remoteChainSelector,\n    RateLimiter.Config outboundRateLimiterConfig,\n    RateLimiter.Config inboundRateLimiterConfig\n  );\n  event ChainRemoved(uint64 remoteChainSelector);\n  event RemotePoolAdded(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\n  event RemotePoolRemoved(uint64 indexed remoteChainSelector, bytes remotePoolAddress);\n  event AllowListAdd(address sender);\n  event AllowListRemove(address sender);\n  event RouterUpdated(address oldRouter, address newRouter);\n  event RateLimitAdminSet(address rateLimitAdmin);\n\n  struct ChainUpdate {\n    uint64 remoteChainSelector; // Remote chain selector\n    bytes[] remotePoolAddresses; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n  }\n\n  struct RemoteChainConfig {\n    RateLimiter.TokenBucket outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n    RateLimiter.TokenBucket inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n    EnumerableSet.Bytes32Set remotePools; // Set of remote pool hashes, ABI encoded in the case of a remote EVM chain.\n  }\n\n  /// @dev The bridgeable token that is managed by this pool. Pools could support multiple tokens at the same time if\n  /// required, but this implementation only supports one token.\n  IERC20 internal immutable i_token;\n  /// @dev The number of decimals of the token managed by this pool.\n  uint8 internal immutable i_tokenDecimals;\n  /// @dev The address of the RMN proxy\n  address internal immutable i_rmnProxy;\n  /// @dev The immutable flag that indicates if the pool is access-controlled.\n  bool internal immutable i_allowlistEnabled;\n  /// @dev A set of addresses allowed to trigger lockOrBurn as original senders.\n  /// Only takes effect if i_allowlistEnabled is true.\n  /// This can be used to ensure only token-issuer specified addresses can move tokens.\n  EnumerableSet.AddressSet internal s_allowlist;\n  /// @dev The address of the router\n  IRouter internal s_router;\n  /// @dev A set of allowed chain selectors. We want the allowlist to be enumerable to\n  /// be able to quickly determine (without parsing logs) who can access the pool.\n  /// @dev The chain selectors are in uint256 format because of the EnumerableSet implementation.\n  EnumerableSet.UintSet internal s_remoteChainSelectors;\n  mapping(uint64 remoteChainSelector => RemoteChainConfig) internal s_remoteChainConfigs;\n  /// @notice A mapping of hashed pool addresses to their unhashed form. This is used to be able to find the actually\n  /// configured pools and not just their hashed versions.\n  mapping(bytes32 poolAddressHash => bytes poolAddress) internal s_remotePoolAddresses;\n  /// @notice The address of the rate limiter admin.\n  /// @dev Can be address(0) if none is configured.\n  address internal s_rateLimitAdmin;\n\n  constructor(IERC20 token, uint8 localTokenDecimals, address[] memory allowlist, address rmnProxy, address router) {\n    if (address(token) == address(0) || router == address(0) || rmnProxy == address(0)) revert ZeroAddressNotAllowed();\n    i_token = token;\n    i_rmnProxy = rmnProxy;\n\n    try IERC20Metadata(address(token)).decimals() returns (uint8 actualTokenDecimals) {\n      if (localTokenDecimals != actualTokenDecimals) {\n        revert InvalidDecimalArgs(localTokenDecimals, actualTokenDecimals);\n      }\n    } catch {\n      // The decimals function doesn't exist, which is possible since it's optional in the ERC20 spec. We skip the check and\n      // assume the supplied token decimals are correct.\n    }\n    i_tokenDecimals = localTokenDecimals;\n\n    s_router = IRouter(router);\n\n    // Pool can be set as permissioned or permissionless at deployment time only to save hot-path gas.\n    i_allowlistEnabled = allowlist.length > 0;\n    if (i_allowlistEnabled) {\n      _applyAllowListUpdates(new address[](0), allowlist);\n    }\n  }\n\n  /// @inheritdoc IPoolV1\n  function isSupportedToken(\n    address token\n  ) public view virtual returns (bool) {\n    return token == address(i_token);\n  }\n\n  /// @notice Gets the IERC20 token that this pool can lock or burn.\n  /// @return token The IERC20 token representation.\n  function getToken() public view returns (IERC20 token) {\n    return i_token;\n  }\n\n  /// @notice Get RMN proxy address\n  /// @return rmnProxy Address of RMN proxy\n  function getRmnProxy() public view returns (address rmnProxy) {\n    return i_rmnProxy;\n  }\n\n  /// @notice Gets the pool's Router\n  /// @return router The pool's Router\n  function getRouter() public view returns (address router) {\n    return address(s_router);\n  }\n\n  /// @notice Sets the pool's Router\n  /// @param newRouter The new Router\n  function setRouter(\n    address newRouter\n  ) public onlyOwner {\n    if (newRouter == address(0)) revert ZeroAddressNotAllowed();\n    address oldRouter = address(s_router);\n    s_router = IRouter(newRouter);\n\n    emit RouterUpdated(oldRouter, newRouter);\n  }\n\n  /// @notice Signals which version of the pool interface is supported\n  function supportsInterface(\n    bytes4 interfaceId\n  ) public pure virtual override returns (bool) {\n    return interfaceId == Pool.CCIP_POOL_V1 || interfaceId == type(IPoolV1).interfaceId\n      || interfaceId == type(IERC165).interfaceId;\n  }\n\n  // ================================================================\n  // │                         Validation                           │\n  // ================================================================\n\n  /// @notice Validates the lock or burn input for correctness on\n  /// - token to be locked or burned\n  /// - RMN curse status\n  /// - allowlist status\n  /// - if the sender is a valid onRamp\n  /// - rate limit status\n  /// @param lockOrBurnIn The input to validate.\n  /// @dev This function should always be called before executing a lock or burn. Not doing so would allow\n  /// for various exploits.\n  function _validateLockOrBurn(\n    Pool.LockOrBurnInV1 calldata lockOrBurnIn\n  ) internal {\n    if (!isSupportedToken(lockOrBurnIn.localToken)) revert InvalidToken(lockOrBurnIn.localToken);\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(lockOrBurnIn.remoteChainSelector)))) revert CursedByRMN();\n    _checkAllowList(lockOrBurnIn.originalSender);\n\n    _onlyOnRamp(lockOrBurnIn.remoteChainSelector);\n    _consumeOutboundRateLimit(lockOrBurnIn.remoteChainSelector, lockOrBurnIn.amount);\n  }\n\n  /// @notice Validates the release or mint input for correctness on\n  /// - token to be released or minted\n  /// - RMN curse status\n  /// - if the sender is a valid offRamp\n  /// - if the source pool is valid\n  /// - rate limit status\n  /// @param releaseOrMintIn The input to validate.\n  /// @dev This function should always be called before executing a release or mint. Not doing so would allow\n  /// for various exploits.\n  function _validateReleaseOrMint(\n    Pool.ReleaseOrMintInV1 calldata releaseOrMintIn\n  ) internal {\n    if (!isSupportedToken(releaseOrMintIn.localToken)) revert InvalidToken(releaseOrMintIn.localToken);\n    if (IRMN(i_rmnProxy).isCursed(bytes16(uint128(releaseOrMintIn.remoteChainSelector)))) revert CursedByRMN();\n    _onlyOffRamp(releaseOrMintIn.remoteChainSelector);\n\n    // Validates that the source pool address is configured on this pool.\n    if (!isRemotePool(releaseOrMintIn.remoteChainSelector, releaseOrMintIn.sourcePoolAddress)) {\n      revert InvalidSourcePoolAddress(releaseOrMintIn.sourcePoolAddress);\n    }\n\n    _consumeInboundRateLimit(releaseOrMintIn.remoteChainSelector, releaseOrMintIn.amount);\n  }\n\n  // ================================================================\n  // │                      Token decimals                          │\n  // ================================================================\n\n  /// @notice Gets the IERC20 token decimals on the local chain.\n  function getTokenDecimals() public view virtual returns (uint8 decimals) {\n    return i_tokenDecimals;\n  }\n\n  function _encodeLocalDecimals() internal view virtual returns (bytes memory) {\n    return abi.encode(i_tokenDecimals);\n  }\n\n  function _parseRemoteDecimals(\n    bytes memory sourcePoolData\n  ) internal view virtual returns (uint8) {\n    // Fallback to the local token decimals if the source pool data is empty. This allows for backwards compatibility.\n    if (sourcePoolData.length == 0) {\n      return i_tokenDecimals;\n    }\n    if (sourcePoolData.length != 32) {\n      revert InvalidRemoteChainDecimals(sourcePoolData);\n    }\n    uint256 remoteDecimals = abi.decode(sourcePoolData, (uint256));\n    if (remoteDecimals > type(uint8).max) {\n      revert InvalidRemoteChainDecimals(sourcePoolData);\n    }\n    return uint8(remoteDecimals);\n  }\n\n  /// @notice Calculates the local amount based on the remote amount and decimals.\n  /// @param remoteAmount The amount on the remote chain.\n  /// @param remoteDecimals The decimals of the token on the remote chain.\n  /// @return The local amount.\n  /// @dev This function protects against overflows. If there is a transaction that hits the overflow check, it is\n  /// probably incorrect as that means the amount cannot be represented on this chain. If the local decimals have been\n  /// wrongly configured, the token issuer could redeploy the pool with the correct decimals and manually re-execute the\n  /// CCIP tx to fix the issue.\n  function _calculateLocalAmount(uint256 remoteAmount, uint8 remoteDecimals) internal view virtual returns (uint256) {\n    if (remoteDecimals == i_tokenDecimals) {\n      return remoteAmount;\n    }\n    if (remoteDecimals > i_tokenDecimals) {\n      uint8 decimalsDiff = remoteDecimals - i_tokenDecimals;\n      if (decimalsDiff > 77) {\n        // This is a safety check to prevent overflow in the next calculation.\n        revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\n      }\n      // Solidity rounds down so there is no risk of minting more tokens than the remote chain sent.\n      return remoteAmount / (10 ** decimalsDiff);\n    }\n\n    // This is a safety check to prevent overflow in the next calculation.\n    // More than 77 would never fit in a uint256 and would cause an overflow. We also check if the resulting amount\n    // would overflow.\n    uint8 diffDecimals = i_tokenDecimals - remoteDecimals;\n    if (diffDecimals > 77 || remoteAmount > type(uint256).max / (10 ** diffDecimals)) {\n      revert OverflowDetected(remoteDecimals, i_tokenDecimals, remoteAmount);\n    }\n\n    return remoteAmount * (10 ** diffDecimals);\n  }\n\n  // ================================================================\n  // │                     Chain permissions                        │\n  // ================================================================\n\n  /// @notice Gets the pool address on the remote chain.\n  /// @param remoteChainSelector Remote chain selector.\n  /// @dev To support non-evm chains, this value is encoded into bytes\n  function getRemotePools(\n    uint64 remoteChainSelector\n  ) public view returns (bytes[] memory) {\n    bytes32[] memory remotePoolHashes = s_remoteChainConfigs[remoteChainSelector].remotePools.values();\n\n    bytes[] memory remotePools = new bytes[](remotePoolHashes.length);\n    for (uint256 i = 0; i < remotePoolHashes.length; ++i) {\n      remotePools[i] = s_remotePoolAddresses[remotePoolHashes[i]];\n    }\n\n    return remotePools;\n  }\n\n  /// @notice Checks if the pool address is configured on the remote chain.\n  /// @param remoteChainSelector Remote chain selector.\n  /// @param remotePoolAddress The address of the remote pool.\n  function isRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) public view returns (bool) {\n    return s_remoteChainConfigs[remoteChainSelector].remotePools.contains(keccak256(remotePoolAddress));\n  }\n\n  /// @notice Gets the token address on the remote chain.\n  /// @param remoteChainSelector Remote chain selector.\n  /// @dev To support non-evm chains, this value is encoded into bytes\n  function getRemoteToken(\n    uint64 remoteChainSelector\n  ) public view returns (bytes memory) {\n    return s_remoteChainConfigs[remoteChainSelector].remoteTokenAddress;\n  }\n\n  /// @notice Adds a remote pool for a given chain selector. This could be due to a pool being upgraded on the remote\n  /// chain. We don't simply want to replace the old pool as there could still be valid inflight messages from the old\n  /// pool. This function allows for multiple pools to be added for a single chain selector.\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\n  /// @param remotePoolAddress The address of the new remote pool.\n  function addRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external onlyOwner {\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\n\n    _setRemotePool(remoteChainSelector, remotePoolAddress);\n  }\n\n  /// @notice Removes the remote pool address for a given chain selector.\n  /// @dev All inflight txs from the remote pool will be rejected after it is removed. To ensure no loss of funds, there\n  /// should be no inflight txs from the given pool.\n  function removeRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external onlyOwner {\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\n\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.remove(keccak256(remotePoolAddress))) {\n      revert InvalidRemotePoolForChain(remoteChainSelector, remotePoolAddress);\n    }\n\n    emit RemotePoolRemoved(remoteChainSelector, remotePoolAddress);\n  }\n\n  /// @inheritdoc IPoolV1\n  function isSupportedChain(\n    uint64 remoteChainSelector\n  ) public view returns (bool) {\n    return s_remoteChainSelectors.contains(remoteChainSelector);\n  }\n\n  /// @notice Get list of allowed chains\n  /// @return list of chains.\n  function getSupportedChains() public view returns (uint64[] memory) {\n    uint256[] memory uint256ChainSelectors = s_remoteChainSelectors.values();\n    uint64[] memory chainSelectors = new uint64[](uint256ChainSelectors.length);\n    for (uint256 i = 0; i < uint256ChainSelectors.length; ++i) {\n      chainSelectors[i] = uint64(uint256ChainSelectors[i]);\n    }\n\n    return chainSelectors;\n  }\n\n  /// @notice Sets the permissions for a list of chains selectors. Actual senders for these chains\n  /// need to be allowed on the Router to interact with this pool.\n  /// @param remoteChainSelectorsToRemove A list of chain selectors to remove.\n  /// @param chainsToAdd A list of chains and their new permission status & rate limits. Rate limits\n  /// are only used when the chain is being added through `allowed` being true.\n  /// @dev Only callable by the owner\n  function applyChainUpdates(\n    uint64[] calldata remoteChainSelectorsToRemove,\n    ChainUpdate[] calldata chainsToAdd\n  ) external virtual onlyOwner {\n    for (uint256 i = 0; i < remoteChainSelectorsToRemove.length; ++i) {\n      uint64 remoteChainSelectorToRemove = remoteChainSelectorsToRemove[i];\n      // If the chain doesn't exist, revert\n      if (!s_remoteChainSelectors.remove(remoteChainSelectorToRemove)) {\n        revert NonExistentChain(remoteChainSelectorToRemove);\n      }\n\n      // Remove all remote pool hashes for the chain\n      bytes32[] memory remotePools = s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.values();\n      for (uint256 j = 0; j < remotePools.length; ++j) {\n        s_remoteChainConfigs[remoteChainSelectorToRemove].remotePools.remove(remotePools[j]);\n      }\n\n      delete s_remoteChainConfigs[remoteChainSelectorToRemove];\n\n      emit ChainRemoved(remoteChainSelectorToRemove);\n    }\n\n    for (uint256 i = 0; i < chainsToAdd.length; ++i) {\n      ChainUpdate memory newChain = chainsToAdd[i];\n      RateLimiter._validateTokenBucketConfig(newChain.outboundRateLimiterConfig, false);\n      RateLimiter._validateTokenBucketConfig(newChain.inboundRateLimiterConfig, false);\n\n      if (newChain.remoteTokenAddress.length == 0) {\n        revert ZeroAddressNotAllowed();\n      }\n\n      // If the chain already exists, revert\n      if (!s_remoteChainSelectors.add(newChain.remoteChainSelector)) {\n        revert ChainAlreadyExists(newChain.remoteChainSelector);\n      }\n\n      RemoteChainConfig storage remoteChainConfig = s_remoteChainConfigs[newChain.remoteChainSelector];\n\n      remoteChainConfig.outboundRateLimiterConfig = RateLimiter.TokenBucket({\n        rate: newChain.outboundRateLimiterConfig.rate,\n        capacity: newChain.outboundRateLimiterConfig.capacity,\n        tokens: newChain.outboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: newChain.outboundRateLimiterConfig.isEnabled\n      });\n      remoteChainConfig.inboundRateLimiterConfig = RateLimiter.TokenBucket({\n        rate: newChain.inboundRateLimiterConfig.rate,\n        capacity: newChain.inboundRateLimiterConfig.capacity,\n        tokens: newChain.inboundRateLimiterConfig.capacity,\n        lastUpdated: uint32(block.timestamp),\n        isEnabled: newChain.inboundRateLimiterConfig.isEnabled\n      });\n      remoteChainConfig.remoteTokenAddress = newChain.remoteTokenAddress;\n\n      for (uint256 j = 0; j < newChain.remotePoolAddresses.length; ++j) {\n        _setRemotePool(newChain.remoteChainSelector, newChain.remotePoolAddresses[j]);\n      }\n\n      emit ChainAdded(\n        newChain.remoteChainSelector,\n        newChain.remoteTokenAddress,\n        newChain.outboundRateLimiterConfig,\n        newChain.inboundRateLimiterConfig\n      );\n    }\n  }\n\n  /// @notice Adds a pool address to the allowed remote token pools for a particular chain.\n  /// @param remoteChainSelector The remote chain selector for which the remote pool address is being added.\n  /// @param remotePoolAddress The address of the new remote pool.\n  function _setRemotePool(uint64 remoteChainSelector, bytes memory remotePoolAddress) internal {\n    if (remotePoolAddress.length == 0) {\n      revert ZeroAddressNotAllowed();\n    }\n\n    bytes32 poolHash = keccak256(remotePoolAddress);\n\n    // Check if the pool already exists.\n    if (!s_remoteChainConfigs[remoteChainSelector].remotePools.add(poolHash)) {\n      revert PoolAlreadyAdded(remoteChainSelector, remotePoolAddress);\n    }\n\n    // Add the pool to the mapping to be able to un-hash it later.\n    s_remotePoolAddresses[poolHash] = remotePoolAddress;\n\n    emit RemotePoolAdded(remoteChainSelector, remotePoolAddress);\n  }\n\n  // ================================================================\n  // │                        Rate limiting                         │\n  // ================================================================\n\n  /// @dev The inbound rate limits should be slightly higher than the outbound rate limits. This is because many chains\n  /// finalize blocks in batches. CCIP also commits messages in batches: the commit plugin bundles multiple messages in\n  /// a single merkle root.\n  /// Imagine the following scenario.\n  /// - Chain A has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\n  /// - Chain B has an inbound and outbound rate limit of 100 tokens capacity and 1 token per second refill rate.\n  ///\n  /// At time 0:\n  /// - Chain A sends 100 tokens to Chain B.\n  /// At time 5:\n  /// - Chain A sends 5 tokens to Chain B.\n  /// At time 6:\n  /// The epoch that contains blocks [0-5] is finalized.\n  /// Both transactions will be included in the same merkle root and become executable at the same time. This means\n  /// the token pool on chain B requires a capacity of 105 to successfully execute both messages at the same time.\n  /// The exact additional capacity required depends on the refill rate and the size of the source chain epochs and the\n  /// CCIP round time. For simplicity, a 5-10% buffer should be sufficient in most cases.\n\n  /// @notice Sets the rate limiter admin address.\n  /// @dev Only callable by the owner.\n  /// @param rateLimitAdmin The new rate limiter admin address.\n  function setRateLimitAdmin(\n    address rateLimitAdmin\n  ) external onlyOwner {\n    s_rateLimitAdmin = rateLimitAdmin;\n    emit RateLimitAdminSet(rateLimitAdmin);\n  }\n\n  /// @notice Gets the rate limiter admin address.\n  function getRateLimitAdmin() external view returns (address) {\n    return s_rateLimitAdmin;\n  }\n\n  /// @notice Consumes outbound rate limiting capacity in this pool\n  function _consumeOutboundRateLimit(uint64 remoteChainSelector, uint256 amount) internal {\n    s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._consume(amount, address(i_token));\n  }\n\n  /// @notice Consumes inbound rate limiting capacity in this pool\n  function _consumeInboundRateLimit(uint64 remoteChainSelector, uint256 amount) internal {\n    s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._consume(amount, address(i_token));\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function getCurrentOutboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._currentTokenBucketState();\n  }\n\n  /// @notice Gets the token bucket with its values for the block it was requested at.\n  /// @return The token bucket.\n  function getCurrentInboundRateLimiterState(\n    uint64 remoteChainSelector\n  ) external view returns (RateLimiter.TokenBucket memory) {\n    return s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._currentTokenBucketState();\n  }\n\n  /// @notice Sets multiple chain rate limiter configs.\n  /// @param remoteChainSelectors The remote chain selector for which the rate limits apply.\n  /// @param outboundConfigs The new outbound rate limiter config, meaning the onRamp rate limits for the given chain.\n  /// @param inboundConfigs The new inbound rate limiter config, meaning the offRamp rate limits for the given chain.\n  function setChainRateLimiterConfigs(\n    uint64[] calldata remoteChainSelectors,\n    RateLimiter.Config[] calldata outboundConfigs,\n    RateLimiter.Config[] calldata inboundConfigs\n  ) external {\n    if (msg.sender != s_rateLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n    if (remoteChainSelectors.length != outboundConfigs.length || remoteChainSelectors.length != inboundConfigs.length) {\n      revert MismatchedArrayLengths();\n    }\n\n    for (uint256 i = 0; i < remoteChainSelectors.length; ++i) {\n      _setRateLimitConfig(remoteChainSelectors[i], outboundConfigs[i], inboundConfigs[i]);\n    }\n  }\n\n  /// @notice Sets the chain rate limiter config.\n  /// @param remoteChainSelector The remote chain selector for which the rate limits apply.\n  /// @param outboundConfig The new outbound rate limiter config, meaning the onRamp rate limits for the given chain.\n  /// @param inboundConfig The new inbound rate limiter config, meaning the offRamp rate limits for the given chain.\n  function setChainRateLimiterConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) external {\n    if (msg.sender != s_rateLimitAdmin && msg.sender != owner()) revert Unauthorized(msg.sender);\n\n    _setRateLimitConfig(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  function _setRateLimitConfig(\n    uint64 remoteChainSelector,\n    RateLimiter.Config memory outboundConfig,\n    RateLimiter.Config memory inboundConfig\n  ) internal {\n    if (!isSupportedChain(remoteChainSelector)) revert NonExistentChain(remoteChainSelector);\n    RateLimiter._validateTokenBucketConfig(outboundConfig, false);\n    s_remoteChainConfigs[remoteChainSelector].outboundRateLimiterConfig._setTokenBucketConfig(outboundConfig);\n    RateLimiter._validateTokenBucketConfig(inboundConfig, false);\n    s_remoteChainConfigs[remoteChainSelector].inboundRateLimiterConfig._setTokenBucketConfig(inboundConfig);\n    emit ChainConfigured(remoteChainSelector, outboundConfig, inboundConfig);\n  }\n\n  // ================================================================\n  // │                           Access                             │\n  // ================================================================\n\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\n  /// is a permissioned onRamp for the given chain on the Router.\n  function _onlyOnRamp(\n    uint64 remoteChainSelector\n  ) internal view {\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\n    if (!(msg.sender == s_router.getOnRamp(remoteChainSelector))) revert CallerIsNotARampOnRouter(msg.sender);\n  }\n\n  /// @notice Checks whether remote chain selector is configured on this contract, and if the msg.sender\n  /// is a permissioned offRamp for the given chain on the Router.\n  function _onlyOffRamp(\n    uint64 remoteChainSelector\n  ) internal view {\n    if (!isSupportedChain(remoteChainSelector)) revert ChainNotAllowed(remoteChainSelector);\n    if (!s_router.isOffRamp(remoteChainSelector, msg.sender)) revert CallerIsNotARampOnRouter(msg.sender);\n  }\n\n  // ================================================================\n  // │                          Allowlist                           │\n  // ================================================================\n\n  function _checkAllowList(\n    address sender\n  ) internal view {\n    if (i_allowlistEnabled) {\n      if (!s_allowlist.contains(sender)) {\n        revert SenderNotAllowed(sender);\n      }\n    }\n  }\n\n  /// @notice Gets whether the allowlist functionality is enabled.\n  /// @return true is enabled, false if not.\n  function getAllowListEnabled() external view returns (bool) {\n    return i_allowlistEnabled;\n  }\n\n  /// @notice Gets the allowed addresses.\n  /// @return The allowed addresses.\n  function getAllowList() external view returns (address[] memory) {\n    return s_allowlist.values();\n  }\n\n  /// @notice Apply updates to the allow list.\n  /// @param removes The addresses to be removed.\n  /// @param adds The addresses to be added.\n  function applyAllowListUpdates(address[] calldata removes, address[] calldata adds) external onlyOwner {\n    _applyAllowListUpdates(removes, adds);\n  }\n\n  /// @notice Internal version of applyAllowListUpdates to allow for reuse in the constructor.\n  function _applyAllowListUpdates(address[] memory removes, address[] memory adds) internal {\n    if (!i_allowlistEnabled) revert AllowListNotEnabled();\n\n    for (uint256 i = 0; i < removes.length; ++i) {\n      address toRemove = removes[i];\n      if (s_allowlist.remove(toRemove)) {\n        emit AllowListRemove(toRemove);\n      }\n    }\n    for (uint256 i = 0; i < adds.length; ++i) {\n      address toAdd = adds[i];\n      if (toAdd == address(0)) {\n        continue;\n      }\n      if (s_allowlist.add(toAdd)) {\n        emit AllowListAdd(toAdd);\n      }\n    }\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/RegistryModuleOwnerCustom.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {ITypeAndVersion} from \"../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IGetCCIPAdmin} from \"../interfaces/IGetCCIPAdmin.sol\";\nimport {IOwner} from \"../interfaces/IOwner.sol\";\nimport {ITokenAdminRegistry} from \"../interfaces/ITokenAdminRegistry.sol\";\n\nimport {AccessControl} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/access/AccessControl.sol\";\n\ncontract RegistryModuleOwnerCustom is ITypeAndVersion {\n  error CanOnlySelfRegister(address admin, address token);\n  error RequiredRoleNotFound(address msgSender, bytes32 role, address token);\n  error AddressZero();\n\n  event AdministratorRegistered(address indexed token, address indexed administrator);\n\n  string public constant override typeAndVersion = \"RegistryModuleOwnerCustom 1.6.0\";\n\n  // The TokenAdminRegistry contract\n  ITokenAdminRegistry internal immutable i_tokenAdminRegistry;\n\n  constructor(\n    address tokenAdminRegistry\n  ) {\n    if (tokenAdminRegistry == address(0)) {\n      revert AddressZero();\n    }\n    i_tokenAdminRegistry = ITokenAdminRegistry(tokenAdminRegistry);\n  }\n\n  /// @notice Registers the admin of the token using the `getCCIPAdmin` method.\n  /// @param token The token to register the admin for.\n  /// @dev The caller must be the admin returned by the `getCCIPAdmin` method.\n  function registerAdminViaGetCCIPAdmin(\n    address token\n  ) external {\n    _registerAdmin(token, IGetCCIPAdmin(token).getCCIPAdmin());\n  }\n\n  /// @notice Registers the admin of the token using the `owner` method.\n  /// @param token The token to register the admin for.\n  /// @dev The caller must be the admin returned by the `owner` method.\n  function registerAdminViaOwner(\n    address token\n  ) external {\n    _registerAdmin(token, IOwner(token).owner());\n  }\n\n  /// @notice Registers the admin of the token using OZ's AccessControl DEFAULT_ADMIN_ROLE.\n  /// @param token The token to register the admin for.\n  /// @dev The caller must have the DEFAULT_ADMIN_ROLE as defined by the contract itself.\n  function registerAccessControlDefaultAdmin(\n    address token\n  ) external {\n    bytes32 defaultAdminRole = AccessControl(token).DEFAULT_ADMIN_ROLE();\n    if (!AccessControl(token).hasRole(defaultAdminRole, msg.sender)) {\n      revert RequiredRoleNotFound(msg.sender, defaultAdminRole, token);\n    }\n\n    _registerAdmin(token, msg.sender);\n  }\n\n  /// @notice Registers the admin of the token to msg.sender given that the\n  /// admin is equal to msg.sender.\n  /// @param token The token to register the admin for.\n  /// @param admin The caller must be the admin.\n  function _registerAdmin(address token, address admin) internal {\n    if (admin != msg.sender) {\n      revert CanOnlySelfRegister(admin, token);\n    }\n\n    i_tokenAdminRegistry.proposeAdministrator(token, admin);\n\n    emit AdministratorRegistered(token, admin);\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/TokenAdminRegistry.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity 0.8.24;\n\nimport {ITypeAndVersion} from \"../../shared/interfaces/ITypeAndVersion.sol\";\nimport {IPoolV1} from \"../interfaces/IPool.sol\";\nimport {ITokenAdminRegistry} from \"../interfaces/ITokenAdminRegistry.sol\";\n\nimport {OwnerIsCreator} from \"../../shared/access/OwnerIsCreator.sol\";\n\nimport {EnumerableSet} from \"../../vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @notice This contract stores the token pool configuration for all CCIP enabled tokens. It works\n/// on a self-serve basis, where tokens can be registered without intervention from the CCIP owner.\n/// @dev This contract is not considered upgradable, as it is a customer facing contract that will store\n/// significant amounts of data.\ncontract TokenAdminRegistry is ITokenAdminRegistry, ITypeAndVersion, OwnerIsCreator {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  error OnlyRegistryModuleOrOwner(address sender);\n  error OnlyAdministrator(address sender, address token);\n  error OnlyPendingAdministrator(address sender, address token);\n  error AlreadyRegistered(address token);\n  error ZeroAddress();\n  error InvalidTokenPoolToken(address token);\n\n  event PoolSet(address indexed token, address indexed previousPool, address indexed newPool);\n  event AdministratorTransferRequested(address indexed token, address indexed currentAdmin, address indexed newAdmin);\n  event AdministratorTransferred(address indexed token, address indexed newAdmin);\n  event RegistryModuleAdded(address module);\n  event RegistryModuleRemoved(address indexed module);\n\n  // The struct is packed in a way that optimizes the attributes that are accessed together.\n  // solhint-disable-next-line gas-struct-packing\n  struct TokenConfig {\n    address administrator; // the current administrator of the token\n    address pendingAdministrator; // the address that is pending to become the new administrator\n    address tokenPool; // the token pool for this token. Can be address(0) if not deployed or not configured.\n  }\n\n  string public constant override typeAndVersion = \"TokenAdminRegistry 1.5.0\";\n\n  // Mapping of token address to token configuration\n  mapping(address token => TokenConfig) internal s_tokenConfig;\n\n  // All tokens that have been configured\n  EnumerableSet.AddressSet internal s_tokens;\n\n  // Registry modules are allowed to register administrators for tokens\n  EnumerableSet.AddressSet internal s_registryModules;\n\n  /// @notice Returns all pools for the given tokens.\n  /// @dev Will return address(0) for tokens that do not have a pool.\n  function getPools(\n    address[] calldata tokens\n  ) external view returns (address[] memory) {\n    address[] memory pools = new address[](tokens.length);\n    for (uint256 i = 0; i < tokens.length; ++i) {\n      pools[i] = s_tokenConfig[tokens[i]].tokenPool;\n    }\n    return pools;\n  }\n\n  /// @inheritdoc ITokenAdminRegistry\n  function getPool(\n    address token\n  ) external view returns (address) {\n    return s_tokenConfig[token].tokenPool;\n  }\n\n  /// @notice Returns the configuration for a token.\n  /// @param token The token to get the configuration for.\n  /// @return config The configuration for the token.\n  function getTokenConfig(\n    address token\n  ) external view returns (TokenConfig memory) {\n    return s_tokenConfig[token];\n  }\n\n  /// @notice Returns a list of tokens that are configured in the token admin registry.\n  /// @param startIndex Starting index in list, can be 0 if you want to start from the beginning.\n  /// @param maxCount Maximum number of tokens to retrieve. Since the list can be large,\n  /// it is recommended to use a paging mechanism to retrieve all tokens. If querying for very\n  /// large lists, RPCs can time out. If you want all tokens, use type(uint64).max.\n  /// @return tokens List of configured tokens.\n  /// @dev The function is paginated to avoid RPC timeouts.\n  /// @dev The ordering is guaranteed to remain the same as it is not possible to remove tokens\n  /// from s_tokens.\n  function getAllConfiguredTokens(uint64 startIndex, uint64 maxCount) external view returns (address[] memory tokens) {\n    uint256 numberOfTokens = s_tokens.length();\n    if (startIndex >= numberOfTokens) {\n      return tokens;\n    }\n    uint256 count = maxCount;\n    if (count + startIndex > numberOfTokens) {\n      count = numberOfTokens - startIndex;\n    }\n    tokens = new address[](count);\n    for (uint256 i = 0; i < count; ++i) {\n      tokens[i] = s_tokens.at(startIndex + i);\n    }\n\n    return tokens;\n  }\n\n  // ================================================================\n  // │                  Administrator functions                     │\n  // ================================================================\n\n  /// @notice Sets the pool for a token. Setting the pool to address(0) effectively delists the token\n  /// from CCIP. Setting the pool to any other address enables the token on CCIP.\n  /// @param localToken The token to set the pool for.\n  /// @param pool The pool to set for the token.\n  function setPool(address localToken, address pool) external onlyTokenAdmin(localToken) {\n    // The pool has to support the token, but we want to allow removing the pool, so we only check\n    // if the pool supports the token if it is not address(0).\n    if (pool != address(0) && !IPoolV1(pool).isSupportedToken(localToken)) {\n      revert InvalidTokenPoolToken(localToken);\n    }\n\n    TokenConfig storage config = s_tokenConfig[localToken];\n\n    address previousPool = config.tokenPool;\n    config.tokenPool = pool;\n\n    if (previousPool != pool) {\n      emit PoolSet(localToken, previousPool, pool);\n    }\n  }\n\n  /// @notice Transfers the administrator role for a token to a new address with a 2-step process.\n  /// @param localToken The token to transfer the administrator role for.\n  /// @param newAdmin The address to transfer the administrator role to. Can be address(0) to cancel\n  /// a pending transfer.\n  /// @dev The new admin must call `acceptAdminRole` to accept the role.\n  function transferAdminRole(address localToken, address newAdmin) external onlyTokenAdmin(localToken) {\n    TokenConfig storage config = s_tokenConfig[localToken];\n    config.pendingAdministrator = newAdmin;\n\n    emit AdministratorTransferRequested(localToken, msg.sender, newAdmin);\n  }\n\n  /// @notice Accepts the administrator role for a token.\n  /// @param localToken The token to accept the administrator role for.\n  /// @dev This function can only be called by the pending administrator.\n  function acceptAdminRole(\n    address localToken\n  ) external {\n    TokenConfig storage config = s_tokenConfig[localToken];\n    if (config.pendingAdministrator != msg.sender) {\n      revert OnlyPendingAdministrator(msg.sender, localToken);\n    }\n\n    config.administrator = msg.sender;\n    config.pendingAdministrator = address(0);\n\n    emit AdministratorTransferred(localToken, msg.sender);\n  }\n\n  // ================================================================\n  // │                    Administrator config                      │\n  // ================================================================\n\n  /// @notice Public getter to check for permissions of an administrator\n  function isAdministrator(address localToken, address administrator) external view returns (bool) {\n    return s_tokenConfig[localToken].administrator == administrator;\n  }\n\n  /// @inheritdoc ITokenAdminRegistry\n  /// @dev Can only be called by a registry module.\n  function proposeAdministrator(address localToken, address administrator) external {\n    if (!isRegistryModule(msg.sender) && msg.sender != owner()) {\n      revert OnlyRegistryModuleOrOwner(msg.sender);\n    }\n    if (administrator == address(0)) {\n      revert ZeroAddress();\n    }\n    TokenConfig storage config = s_tokenConfig[localToken];\n\n    if (config.administrator != address(0)) {\n      revert AlreadyRegistered(localToken);\n    }\n\n    config.pendingAdministrator = administrator;\n\n    // We don't care if it's already in the set, as it's a no-op.\n    s_tokens.add(localToken);\n\n    emit AdministratorTransferRequested(localToken, address(0), administrator);\n  }\n\n  // ================================================================\n  // │                      Registry Modules                        │\n  // ================================================================\n\n  /// @notice Checks if an address is a registry module.\n  /// @param module The address to check.\n  /// @return True if the address is a registry module, false otherwise.\n  function isRegistryModule(\n    address module\n  ) public view returns (bool) {\n    return s_registryModules.contains(module);\n  }\n\n  /// @notice Adds a new registry module to the list of allowed modules.\n  /// @param module The module to add.\n  function addRegistryModule(\n    address module\n  ) external onlyOwner {\n    if (s_registryModules.add(module)) {\n      emit RegistryModuleAdded(module);\n    }\n  }\n\n  /// @notice Removes a registry module from the list of allowed modules.\n  /// @param module The module to remove.\n  function removeRegistryModule(\n    address module\n  ) external onlyOwner {\n    if (s_registryModules.remove(module)) {\n      emit RegistryModuleRemoved(module);\n    }\n  }\n\n  // ================================================================\n  // │                           Access                             │\n  // ================================================================\n\n  /// @notice Checks if an address is the administrator of the given token.\n  modifier onlyTokenAdmin(\n    address token\n  ) {\n    if (s_tokenConfig[token].administrator != msg.sender) {\n      revert OnlyAdministrator(msg.sender, token);\n    }\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwnerWithProposal} from \"./ConfirmedOwnerWithProposal.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwner is ConfirmedOwnerWithProposal {\n  constructor(address newOwner) ConfirmedOwnerWithProposal(newOwner, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/ConfirmedOwnerWithProposal.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @title The ConfirmedOwner contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract ConfirmedOwnerWithProposal is IOwnable {\n  address private s_owner;\n  address private s_pendingOwner;\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    // solhint-disable-next-line gas-custom-errors\n    require(newOwner != address(0), \"Cannot set owner to zero\");\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_pendingOwner, \"Must be proposed owner\");\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  function _transferOwnership(address to) private {\n    // solhint-disable-next-line gas-custom-errors\n    require(to != msg.sender, \"Cannot transfer to self\");\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    // solhint-disable-next-line gas-custom-errors\n    require(msg.sender == s_owner, \"Only callable by owner\");\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/Ownable2Step.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {IOwnable} from \"../interfaces/IOwnable.sol\";\n\n/// @notice A minimal contract that implements 2-step ownership transfer and nothing more. It's made to be minimal\n/// to reduce the impact of the bytecode size on any contract that inherits from it.\ncontract Ownable2Step is IOwnable {\n  /// @notice The pending owner is the address to which ownership may be transferred.\n  address private s_pendingOwner;\n  /// @notice The owner is the current owner of the contract.\n  /// @dev The owner is the second storage variable so any implementing contract could pack other state with it\n  /// instead of the much less used s_pendingOwner.\n  address private s_owner;\n\n  error OwnerCannotBeZero();\n  error MustBeProposedOwner();\n  error CannotTransferToSelf();\n  error OnlyCallableByOwner();\n\n  event OwnershipTransferRequested(address indexed from, address indexed to);\n  event OwnershipTransferred(address indexed from, address indexed to);\n\n  constructor(address newOwner, address pendingOwner) {\n    if (newOwner == address(0)) {\n      revert OwnerCannotBeZero();\n    }\n\n    s_owner = newOwner;\n    if (pendingOwner != address(0)) {\n      _transferOwnership(pendingOwner);\n    }\n  }\n\n  /// @notice Get the current owner\n  function owner() public view override returns (address) {\n    return s_owner;\n  }\n\n  /// @notice Allows an owner to begin transferring ownership to a new address. The new owner needs to call\n  /// `acceptOwnership` to accept the transfer before any permissions are changed.\n  /// @param to The address to which ownership will be transferred.\n  function transferOwnership(address to) public override onlyOwner {\n    _transferOwnership(to);\n  }\n\n  /// @notice validate, transfer ownership, and emit relevant events\n  /// @param to The address to which ownership will be transferred.\n  function _transferOwnership(address to) private {\n    if (to == msg.sender) {\n      revert CannotTransferToSelf();\n    }\n\n    s_pendingOwner = to;\n\n    emit OwnershipTransferRequested(s_owner, to);\n  }\n\n  /// @notice Allows an ownership transfer to be completed by the recipient.\n  function acceptOwnership() external override {\n    if (msg.sender != s_pendingOwner) {\n      revert MustBeProposedOwner();\n    }\n\n    address oldOwner = s_owner;\n    s_owner = msg.sender;\n    s_pendingOwner = address(0);\n\n    emit OwnershipTransferred(oldOwner, msg.sender);\n  }\n\n  /// @notice validate access\n  function _validateOwnership() internal view {\n    if (msg.sender != s_owner) {\n      revert OnlyCallableByOwner();\n    }\n  }\n\n  /// @notice Reverts if called by anyone other than the contract owner.\n  modifier onlyOwner() {\n    _validateOwnership();\n    _;\n  }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/Ownable2StepMsgSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport {Ownable2Step} from \"./Ownable2Step.sol\";\n\n/// @notice Sets the msg.sender to be the owner of the contract and does not set a pending owner.\ncontract Ownable2StepMsgSender is Ownable2Step {\n  constructor() Ownable2Step(msg.sender, address(0)) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/access/OwnerIsCreator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {ConfirmedOwner} from \"./ConfirmedOwner.sol\";\n\n/// @title The OwnerIsCreator contract\n/// @notice A contract with helpers for basic contract ownership.\ncontract OwnerIsCreator is ConfirmedOwner {\n  constructor() ConfirmedOwner(msg.sender) {}\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/IOwnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOwnable {\n  function owner() external returns (address);\n\n  function transferOwnership(address recipient) external;\n\n  function acceptOwnership() external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/shared/interfaces/ITypeAndVersion.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ITypeAndVersion {\n  function typeAndVersion() external pure returns (string memory);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n   */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n   */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n   */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v4.8.3/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `to`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address to, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `from` to `to` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.20;\n\nimport {IAccessControl} from \"./IAccessControl.sol\";\nimport {Context} from \"../utils/Context.sol\";\nimport {ERC165} from \"../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```solidity\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```solidity\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}\n * to enforce additional security measures for this role.\n */\nabstract contract AccessControl is Context, IAccessControl, ERC165 {\n    struct RoleData {\n        mapping(address account => bool) hasRole;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 role => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with an {AccessControlUnauthorizedAccount} error including the required role.\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual returns (bool) {\n        return _roles[role].hasRole[account];\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`\n     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`\n     * is missing `role`.\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert AccessControlUnauthorizedAccount(account, role);\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) public virtual {\n        if (callerConfirmation != _msgSender()) {\n            revert AccessControlBadConfirmation();\n        }\n\n        _revokeRole(role, callerConfirmation);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (!hasRole(role, account)) {\n            _roles[role].hasRole[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {\n        if (hasRole(role, account)) {\n            _roles[role].hasRole[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev The `account` is missing a role.\n     */\n    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);\n\n    /**\n     * @dev The caller of a function is not the expected one.\n     *\n     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.\n     */\n    error AccessControlBadConfirmation();\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `callerConfirmation`.\n     */\n    function renounceRole(bytes32 role, address callerConfirmation) external;\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@chainlink/contracts-ccip/src/v0.8/vendor/openzeppelin-solidity/v5.0.2/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/bridge/CCIPAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {IGovernance} from \"../equity/IGovernance.sol\";\nimport {ITokenPool} from \"./ITokenPool.sol\";\nimport {TokenAdminRegistry} from \"@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/TokenAdminRegistry.sol\";\nimport {RateLimiter} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol\";\nimport {BridgeAccounting} from \"../equity/BridgeAccounting.sol\";\nimport {IBasicFrankencoin} from \"../stablecoin/IBasicFrankencoin.sol\";\nimport {RegistryModuleOwnerCustom} from \"@chainlink/contracts-ccip/src/v0.8/ccip/tokenAdminRegistry/RegistryModuleOwnerCustom.sol\";\n\n/**\n * The admin for briding Frankencoins using CCIP.\n * Each chain needs an instance of this administrator.\n */\ncontract CCIPAdmin {\n    uint64 public constant DAY = 24 * 60 * 60;\n\n    IGovernance public immutable GOVERNANCE;\n    ITokenPool public tokenPool;\n    TokenAdminRegistry public immutable TOKEN_ADMIN_REGISTRY;\n    address public immutable ZCHF;\n\n    struct RemotePoolUpdate {\n        bool add; // true if adding, false if removing\n        uint64 chain;\n        bytes poolAddress;\n    }\n\n    mapping(bytes32 hash => uint64 deadline) public proposals;\n\n    error TooEarly(uint64 deadline);\n    error UnknownProposal(bytes32 hash);\n    error ProposalAlreadyMade(bytes32 hash);\n    error AlreadySet();\n\n    event ProposalMade(bytes32 hash, uint64 deadline);\n    event ProposalDenied(bytes32 hash);\n    event ProposalEnacted(bytes32 hash);\n\n    event RemotePoolUpdateProposed(bytes32 hash, address indexed proposer, RemotePoolUpdate update);\n    event RemoveChainProposed(bytes32 hash, address indexed proposer, uint64 chain);\n    event AddChainProposed(bytes32 hash, address indexed proposer, ITokenPool.ChainUpdate update);\n    event AdminTransferProposed(bytes32 hash, address indexed proposer, address newAdmin);\n\n    event RemotePoolAdded(uint64 indexed chain, bytes indexed poolAddress);\n    event RemotePoolRemoved(uint64 indexed chain, bytes indexed poolAddress);\n    event ChainRemoved(uint64 id);\n    event ChainAdded(ITokenPool.ChainUpdate config);\n    event AdminTransfered(address newAdmin);\n    event RateLimit(uint64 remoteChain, RateLimiter.Config inboundConfigs, RateLimiter.Config outboundConfig);\n\n    modifier onlyQualified(address[] calldata helpers) {\n        GOVERNANCE.checkQualified(msg.sender, helpers);\n        _;\n    }\n\n    constructor(TokenAdminRegistry tokenAdminRegistry, IBasicFrankencoin zchf) {\n        GOVERNANCE = zchf.reserve();\n        TOKEN_ADMIN_REGISTRY = tokenAdminRegistry;\n        ZCHF = address(zchf);\n    }\n\n    /**\n    * @notice Registers the token in the CCIP system\n    * @dev Can only be called while the token admin is not set\n    * @param registry The registry to register the token with\n    */\n    function registerToken(RegistryModuleOwnerCustom registry) external {\n        if(TOKEN_ADMIN_REGISTRY.getTokenConfig(ZCHF).administrator != address(0)) {\n            revert AlreadySet();\n        }\n        registry.registerAdminViaGetCCIPAdmin(ZCHF);\n        acceptAdmin();\n    }\n\n    /**\n     * @notice Sets the token pool to administer and sets in in the TokenAdminRegistry\n     * @dev The token pool can only be set once\n     * @param _tokenPool The token pool to set\n     */\n    function setTokenPool(ITokenPool _tokenPool) external {\n        if (address(tokenPool) != address(0)) revert AlreadySet();\n        tokenPool = _tokenPool;\n        TOKEN_ADMIN_REGISTRY.setPool(ZCHF, address(_tokenPool));\n    }\n\n    /**\n     * @notice Accepts the admin role transfer on the TokenAdminRegistry\n     */\n    function acceptAdmin() public {\n        TOKEN_ADMIN_REGISTRY.acceptAdminRole(ZCHF);\n    }\n\n    /**\n     * @notice Accepts ownership transfer on the TokenPool\n     */\n    function acceptOwnership() public {\n        tokenPool.acceptOwnership();\n    }\n\n    /**\n     * @notice Proposed a remote pool update\n     * @dev The contract only stores the hash. So the data has to be passed in during apply again\n     * @param update  The update proposal\n     * @param helpers The helpers to get enough votes\n     */\n    function proposeRemotePoolUpdate(RemotePoolUpdate memory update, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"remotePoolUpdate\", update));\n        propose(hash, 7, helpers);\n        emit RemotePoolUpdateProposed(hash, msg.sender, update);\n    }\n\n    /**\n     * @notice Applies the update on the TokenPool\n     * @param update RemotePoolUpdate information\n     */\n    function applyRemotePoolUpdate(RemotePoolUpdate memory update) external {\n        enact(keccak256(abi.encode(\"remotePoolUpdate\", update)));\n        if (update.add) {\n            tokenPool.addRemotePool(update.chain, update.poolAddress);\n            emit RemotePoolAdded(update.chain, update.poolAddress);\n        } else {\n            tokenPool.removeRemotePool(update.chain, update.poolAddress);\n            emit RemotePoolRemoved(update.chain, update.poolAddress);\n        }\n    }\n\n    /**\n     * @notice Sets the rate limits for the given chain. Any qualified voter can apply rate limits with immediate effect.\n     * Rate limits can only do limited harm, so it is acceptable to be very permissive. At the same time, rate limits are typically\n     * applied during emergencies, e.g. when a chain has been hacked. Therefore, it is desirable to ensure that\n     * they can be applied quickly. Nonetheless, the proposal fee is still charged to discourage shenenigans.\n     * @param chain The chain to set the rate limits for\n     * @param inbound The inbound rate limits\n     * @param outbound The outbound rate limits\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function applyRateLimit(uint64 chain, RateLimiter.Config calldata inbound, RateLimiter.Config calldata outbound, address[] calldata helpers) external onlyQualified(helpers) {\n        tokenPool.setChainRateLimiterConfig(chain, inbound, outbound);\n        emit RateLimit(chain, inbound, outbound);\n    }\n\n    /**\n     * @notice Propose to add or remove remote chains\n     * @dev The contract only stores the hash. So the data has to be passed in during apply again\n     * @param chainId The chain to remove\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function proposeRemoveChain(uint64 chainId, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"removeChain\", chainId));\n        propose(hash, 7, helpers);\n        emit RemoveChainProposed(hash, msg.sender, chainId);\n    }\n\n    /**\n     * @notice Applies the remove chain proposal\n     * @param chainId The chain to remove\n     */\n    function applyRemoveChain(uint64 chainId) external {\n        enact(keccak256(abi.encode(\"removeChain\", chainId)));\n        uint64[] memory chainsToRemove = new uint64[](1);\n        chainsToRemove[0] = chainId;\n        ITokenPool.ChainUpdate[] memory chainsToAdd = new ITokenPool.ChainUpdate[](0);\n        tokenPool.applyChainUpdates(chainsToRemove, chainsToAdd);\n        emit ChainRemoved(chainId);\n    }\n\n    /**\n     * @notice Propose to add or remove remote chains\n     * @dev The contract only stores the hash. So the data has to be passed in during apply again\n     * @param config The chain configuration\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function proposeAddChain(ITokenPool.ChainUpdate calldata config, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"addChain\", config));\n        propose(hash, 7, helpers);\n        emit AddChainProposed(hash, msg.sender, config);\n    }\n\n    /**\n     * @notice Applies the remote chain updates\n     * @dev Bulk function that allows multiple updates at once\n     * @param config RemoteChainUpdate information\n     */\n    function applyAddChain(ITokenPool.ChainUpdate memory config) external {\n        enact(keccak256(abi.encode(\"addChain\", config)));\n        uint64[] memory chainsToRemove = new uint64[](0);\n        ITokenPool.ChainUpdate[] memory chainsToAdd = new ITokenPool.ChainUpdate[](1);\n        chainsToAdd[0] = config;\n        tokenPool.applyChainUpdates(chainsToRemove, chainsToAdd);\n        emit ChainAdded(config);\n    }\n\n    /**\n     * @notice Proposed a new admin for the TokenPool and Admin on the Token registry\n     * @dev Useful to transfer to a new CCIPAdmin contract\n     * @param newAdmin  The address of the new admin\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function proposeAdminTransfer(address newAdmin, address[] calldata helpers) external {\n        bytes32 hash = keccak256(abi.encode(\"adminTransfer\", newAdmin));\n        propose(hash, 21, helpers);\n        emit AdminTransferProposed(hash, msg.sender, newAdmin);\n    }\n\n    /**\n     * @notice Applies the admin transfer\n     * @dev Transfers admin on the TokenPool and ownership on the ZCHF token on the TokenAdminRegistry\n     * @param newAdmin The address of the new admin\n     */\n    function applyAdminTransfer(address newAdmin) external {\n        enact(keccak256(abi.encode(\"adminTransfer\", newAdmin)));\n        TOKEN_ADMIN_REGISTRY.transferAdminRole(ZCHF, newAdmin);\n        tokenPool.transferOwnership(newAdmin);\n        emit AdminTransfered(newAdmin);\n    }\n\n    /**\n     * @notice Denies and removes a pending proposal\n     * @dev Only qualified voters can deny proposals\n     * @param hash The hash of the proposal to deny\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function deny(bytes32 hash, address[] calldata helpers) external onlyQualified(helpers) {\n        if (proposals[hash] == 0) revert UnknownProposal(hash);\n        delete proposals[hash];\n        emit ProposalDenied(hash);\n    }\n\n    /**\n     * @notice Enacts a pending proposal\n     * @param hash The hash of the proposal to enact\n     */\n    function enact(bytes32 hash) internal {\n        uint64 deadline = proposals[hash];\n        if (deadline == 0) revert UnknownProposal(hash);\n        if (deadline > block.timestamp) revert TooEarly(deadline);\n        delete proposals[hash];\n        emit ProposalEnacted(hash);\n    }\n\n    /**\n     * @notice Creates a new proposal with a delay period\n     * @dev Only qualified voters can create proposals\n     * @param hash The hash of the proposal data\n     * @param delayInDays Number of days to delay the proposal execution\n     * @param helpers Array of helper addresses for qualification check\n     */\n    function propose(bytes32 hash, uint64 delayInDays, address[] calldata helpers) internal onlyQualified(helpers) {\n        if (proposals[hash] > 0) revert ProposalAlreadyMade(hash);\n        proposals[hash] = uint64(block.timestamp) + delayInDays * DAY;\n        emit ProposalMade(hash, proposals[hash]);\n    }\n}\n"
    },
    "contracts/bridge/CCIPSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {IERC20} from \"../erc20/IERC20.sol\";\n\nabstract contract CCIPSender {\n    IRouterClient public immutable ROUTER;\n    address public immutable LINK;\n\n    error InsufficientFeeTokens(address token, uint256 fee);\n    error InsufficientFeeTokenAllowance(address token, uint256 fee);\n\n    constructor(IRouterClient _router, address _link) {\n        ROUTER = _router;\n        LINK = _link;\n    }\n\n    function _toReceiver(address target) internal pure returns (bytes memory) {\n        return abi.encode(target);\n    }\n\n    function _constructMessage(bytes memory _receiver, bytes memory _payload, Client.EVMTokenAmount[] memory _tokenAmounts, bytes memory _extraArgs) internal view returns (Client.EVM2AnyMessage memory) {\n        return Client.EVM2AnyMessage(_receiver, _payload, _tokenAmounts, _guessFeeToken(), _extraArgs);\n    }\n\n    function _constructMessage(bytes memory _receiver, bytes memory _payload, Client.EVMTokenAmount[] memory _tokenAmounts, bool nativeToken,  bytes memory _extraArgs) internal view returns (Client.EVM2AnyMessage memory) {\n        return Client.EVM2AnyMessage(_receiver, _payload, _tokenAmounts, nativeToken ? address(0) : LINK, _extraArgs);\n    }\n\n    function _calculateFee(uint64 chain, Client.EVM2AnyMessage memory message) internal view returns (uint256) {\n        return ROUTER.getFee(chain, message);\n    }\n\n    /**\n     * @dev External call to msg.sender if fees are paid in native token. This function has a potential reentrancy.\n     *      Thus use it wisely.\n     */\n    function _send(uint64 chain, Client.EVM2AnyMessage memory _message) internal returns (bytes32, uint256) {\n        uint256 fee = _calculateFee(chain, _message);\n        bytes32 messageId;\n        if (_message.feeToken != address(0)) {\n            // We trust the feeToken to be not malicious.\n            // ROUTER.getFee() verifies that the feeToken is supported by CCIP and thus vetted.\n            if (IERC20(_message.feeToken).balanceOf(msg.sender) < fee) revert InsufficientFeeTokens(_message.feeToken, fee);\n            if (IERC20(_message.feeToken).allowance(msg.sender, address(this)) < fee) revert InsufficientFeeTokenAllowance(_message.feeToken, fee);\n            IERC20(_message.feeToken).transferFrom(msg.sender, address(this), fee);\n            IERC20(_message.feeToken).approve(address(ROUTER), fee);\n            messageId = ROUTER.ccipSend(chain, _message);\n            uint256 leftover = IERC20(_message.feeToken).balanceOf(address(this));\n            if (leftover > 0) IERC20(_message.feeToken).transfer(msg.sender, leftover);\n        } else {\n            if (msg.value < fee) revert InsufficientFeeTokens(_message.feeToken, fee);\n            messageId = ROUTER.ccipSend{value: fee}(chain, _message);\n            payable(msg.sender).call{value: msg.value - fee}(\"\"); // return overpaid fee to sender\n        }\n        return (messageId, fee);\n    }\n\n    function _guessFeeToken() internal view returns (address) {\n        return (msg.value > 0) ? address(0) : LINK;\n    }\n}\n"
    },
    "contracts/bridge/ITokenPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {RateLimiter} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/RateLimiter.sol\";\n\ninterface ITokenPool {\n    \n    struct ChainUpdate {\n        uint64 remoteChainSelector; // Remote chain selector\n        bytes[] remotePoolAddresses; // Address of the remote pool, ABI encoded in the case of a remote EVM chain.\n        bytes remoteTokenAddress; // Address of the remote token, ABI encoded in the case of a remote EVM chain.\n        RateLimiter.Config outboundRateLimiterConfig; // Outbound rate limited config, meaning the rate limits for all of the onRamps for the given chain\n        RateLimiter.Config inboundRateLimiterConfig; // Inbound rate limited config, meaning the rate limits for all of the offRamps for the given chain\n    }\n\n    function addRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external;\n    function removeRemotePool(uint64 remoteChainSelector, bytes calldata remotePoolAddress) external;\n\n    function setChainRateLimiterConfig(\n        uint64 remoteChainSelectors,\n        RateLimiter.Config calldata outboundConfigs,\n        RateLimiter.Config calldata inboundConfigs\n    ) external;\n    \n    function applyChainUpdates(\n        uint64[] calldata remoteChainSelectorsToRemove,\n        ChainUpdate[] calldata chainsToAdd\n    ) external;\n\n    function acceptOwnership() external;\n    function transferOwnership(address to) external;\n}\n"
    },
    "contracts/equity/BridgeAccounting.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {ITokenAdminRegistry} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/ITokenAdminRegistry.sol\";\nimport {TokenPool} from \"@chainlink/contracts-ccip/src/v0.8/ccip/pools/TokenPool.sol\";\nimport {IBasicFrankencoin} from \"../stablecoin/IBasicFrankencoin.sol\";\n\ncontract BridgeAccounting is CCIPReceiver {\n    IBasicFrankencoin public immutable ZCHF;\n    ITokenAdminRegistry public immutable TOKEN_ADMIN_REGISTRY;\n\n    event ReceivedProfits(uint256 amount);\n    event ReceivedLosses(uint256 losses);\n    event SenderAdded(uint64 indexed chain, bytes indexed sender);\n\n    error InvalidSender(uint64 chain, bytes sender);\n\n    constructor(IBasicFrankencoin zchf, ITokenAdminRegistry _registry, address router) CCIPReceiver(router) {\n        ZCHF = zchf;\n        TOKEN_ADMIN_REGISTRY = _registry;\n    }\n\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n        _validateSender(any2EvmMessage);\n\n        (uint256 profits, uint256 losses) = abi.decode(any2EvmMessage.data, (uint256, uint256));\n        if (profits > 0) {\n            _handleProfits();\n        }\n\n        if (losses > 0) {\n            _handleLosses(losses);\n        }\n    }\n\n    function _validateSender(Client.Any2EVMMessage memory any2EvmMessage) internal view {\n        TokenPool pool = TokenPool(TOKEN_ADMIN_REGISTRY.getPool(address(ZCHF)));\n        bytes memory expectedSender = pool.getRemoteToken(any2EvmMessage.sourceChainSelector);\n        if (keccak256(any2EvmMessage.sender) != keccak256(expectedSender)) {\n            revert InvalidSender(any2EvmMessage.sourceChainSelector, any2EvmMessage.sender);\n        }\n    }\n\n    function _handleProfits() internal {\n        // Use total balance to remove dust\n        uint256 balance = ZCHF.balanceOf(address(this));\n        ZCHF.collectProfits(address(this), balance);\n        emit ReceivedProfits(balance);\n    }\n\n    function _handleLosses(uint256 amount) internal {\n        ZCHF.coverLoss(address(this), amount); // to trigger the Loss event\n        // the BridgedFrankencoin already minted new tokens and made the minter whole.\n        // the tokens minted by the main Frankencoin are therefore a duplicate and need to be burned\n        // otherwise a loss would have double the impact\n        ZCHF.burn(amount); \n        emit ReceivedLosses(amount);\n    }\n}\n"
    },
    "contracts/equity/BridgedGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {CCIPReceiver} from \"@chainlink/contracts-ccip/src/v0.8/ccip/applications/CCIPReceiver.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {SyncVote, SyncMessage} from \"./IGovernance.sol\";\nimport {Governance} from \"./Governance.sol\";\n\ncontract BridgedGovernance is CCIPReceiver, Governance {\n    uint64 public immutable MAINNET_CHAIN_SELECTOR;\n    address public immutable MAINNET_GOVERNANCE_ADDRESS;\n\n    mapping(address => uint256) private _votes;\n    uint256 private _totalVotes;\n\n    event MessageReceived(bytes32 messageId, uint64 sourceChain, uint256 totalVotes, SyncVote[] syncedVotes);\n\n    error InvalidSourceChain();\n    error InvalidSender();\n\n    constructor(address _router, uint64 _mainnetChainSelector, address _mainnetGovernanceAddress) CCIPReceiver(_router) {\n        MAINNET_CHAIN_SELECTOR = _mainnetChainSelector;\n        MAINNET_GOVERNANCE_ADDRESS = _mainnetGovernanceAddress;\n    }\n\n    /**\n     * @notice Get the number of votes held by a holder.\n     * @param holder The address to check.\n     */\n    function votes(address holder) public view override returns (uint256) {\n        return _votes[holder];\n    }\n\n    /**\n     * @notice Get the total number of votes.\n     */\n    function totalVotes() public view override returns (uint256) {\n        return _totalVotes;\n    }\n\n    /**\n     * @notice Required for frankencoin contract\n     */\n    function totalSupply() public view returns (uint256) {\n        return totalVotes();\n    }\n\n    /**\n     * @notice Process a received message.\n     * @param any2EvmMessage The message to process.\n     */\n    function _ccipReceive(Client.Any2EVMMessage memory any2EvmMessage) internal override {\n        if (any2EvmMessage.sourceChainSelector != MAINNET_CHAIN_SELECTOR) revert InvalidSourceChain();\n        if (abi.decode(any2EvmMessage.sender, (address)) != MAINNET_GOVERNANCE_ADDRESS) revert InvalidSender();\n\n        SyncMessage memory syncMessage = abi.decode(any2EvmMessage.data, (SyncMessage)); // abi-decoding of the sent text\n\n        _processSyncMessage(syncMessage);\n\n        emit MessageReceived({messageId: any2EvmMessage.messageId, sourceChain: any2EvmMessage.sourceChainSelector, totalVotes: syncMessage.totalVotes, syncedVotes: syncMessage.votes});\n    }\n\n    /**\n     * @notice Updates internal state with received message\n     * @param syncMessage The message to process.\n     */\n    function _processSyncMessage(SyncMessage memory syncMessage) internal {\n        _totalVotes = syncMessage.totalVotes;\n\n        // omitted unchecked optimization for readability\n        for (uint64 i = 0; i < syncMessage.votes.length; i++) {\n            SyncVote memory syncVote = syncMessage.votes[i];\n            _votes[syncVote.voter] = syncVote.votes;\n            delegate(syncVote.voter, syncVote.delegatee);\n        }\n    }\n}\n"
    },
    "contracts/equity/Equity.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./Governance.sol\";\nimport \"../stablecoin/Frankencoin.sol\";\nimport \"../utils/MathUtil.sol\";\nimport \"../erc20/IERC677Receiver.sol\";\n\n/**\n * @title Equity\n * @notice If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\n * weighted reserve pool shares gains veto power and can veto new proposals.\n */\ncontract Equity is Governance, ERC20PermitLight, MathUtil {\n    /**\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\n     *\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\n     *\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\n     * |          1000 |          3000 |             3 |         1000 |\n     * |       1000000 |       3000000 |           300 |        10000 |\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\n     *\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\n     */\n    uint32 public constant VALUATION_FACTOR = 3;\n\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\n\n    /**\n     * @notice The number of digits to store the average holding time of share tokens.\n     */\n    uint8 private constant TIME_RESOLUTION_BITS = 20;\n\n    /**\n     * @notice The minimum holding duration. You are not allowed to redeem your pool shares if you held them\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\n     * holding duration of your shares is only 55 days < 90 days.\n     */\n    uint256 public constant MIN_HOLDING_DURATION = 90 days << TIME_RESOLUTION_BITS; // Set to 5 for local testing\n\n    Frankencoin public immutable zchf;\n\n    /**\n     * @dev To track the total number of votes we need to know the number of votes at the anchor time and when the\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\n     * the total vote count 192 Bits. Given the sub-second resolution of 20 Bits, the implicit assumption is\n     * that the timestamp can always be stored in 44 Bits (i.e. it does not exceed half a million years). Further,\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed\n     *   192 - 60 - 44 - 20 = 68 Bits\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact,\n     * a limit of about 2**36 shares (that's about 2**96 Bits when taking into account the decimals) is imposed\n     * when minting. This means that the maximum supply is billions shares, which is could only be reached in\n     * a scenario with hyper inflation, in which case the stablecoin is worthless anyway.\n     */\n    uint192 private totalVotesAtAnchor; // Total number of votes at the anchor time, see comment on the um\n    uint64 private totalVotesAnchorTime; // 44 Bit for the time stamp, 20 Bit sub-second time resolution\n\n    /**\n     * @notice A time stamp in the past such that: votes = balance * (time passed since anchor was set)\n     */\n    mapping(address owner => uint64 timestamp) private voteAnchor; // 44 bits for time stamp, 20 subsecond resolution\n\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\n\n    constructor(Frankencoin zchf_) ERC20(18) {\n        zchf = zchf_;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Frankencoin Pool Share\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"FPS\";\n    }\n\n    /**\n     * @notice Returns the price of one FPS in ZCHF with 18 decimals precision.\n     */\n    function price() public view returns (uint256) {\n        uint256 equity = zchf.equity();\n        if (equity == 0 || totalSupply() == 0) {\n            return ONE_DEC18; // initial price is 1000 ZCHF for the first 1000 FPS\n        } else {\n            return (VALUATION_FACTOR * zchf.equity() * ONE_DEC18) / totalSupply();\n        }\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n        if (amount > 0) {\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\n            // their votes so everything falls nicely into place. Recipient votes should stay the same, but grow\n            // faster in the future, requiring an adjustment of the anchor.\n            uint256 roundingLoss = _adjustRecipientVoteAnchor(to, amount);\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\n            _adjustTotalVotes(from, amount, roundingLoss);\n        }\n    }\n\n    /**\n     * @notice Returns whether the given address is allowed to redeem FPS, which is the\n     * case after their average holding duration is larger than the required minimum.\n     */\n    function canRedeem(address owner) public view returns (bool) {\n        return _anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\n    }\n\n    /**\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\n     * @param from      sender\n     * @param amount    amount to be sent\n     */\n    function _adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n        uint64 time = _anchorTime();\n        uint256 lostVotes = from == address(0x0) ? 0 : (time - voteAnchor[from]) * amount;\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n        totalVotesAnchorTime = time;\n    }\n\n    /**\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\n     * votes does not change despite the higher balance.\n     * @param to        receiver address\n     * @param amount    amount to be received\n     * @return the number of votes lost due to rounding errors\n     */\n    function _adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256) {\n        if (to != address(0x0)) {\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 seconds\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\n            // new example anchor is only 21 / 11 = 1 second in the past\n            voteAnchor[to] = uint64(_anchorTime() - recipientVotes / newbalance);\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\n        } else {\n            // optimization for burn, vote anchor of null address does not matter\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Time stamp with some additional bits for higher resolution.\n     */\n    function _anchorTime() internal view returns (uint64) {\n        return uint64(block.timestamp << TIME_RESOLUTION_BITS);\n    }\n\n    /**\n     * @notice The relative voting power of the address.\n     * @return A percentage with 1e18 being 100%\n     */\n    function relativeVotes(address holder) external view returns (uint256) {\n        return (ONE_DEC18 * votes(holder)) / totalVotes();\n    }\n\n    /**\n     * @notice The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) public override view returns (uint256) {\n        return balanceOf(holder) * (_anchorTime() - voteAnchor[holder]);\n    }\n\n    /**\n     * @notice How long the holder already held onto their average FPS in seconds.\n     */\n    function holdingDuration(address holder) public view returns (uint256) {\n        return (_anchorTime() - voteAnchor[holder]) >> TIME_RESOLUTION_BITS;\n    }\n\n    /**\n     * @notice Total number of votes in the system.\n     */\n    function totalVotes() public override view returns (uint256) {\n        return totalVotesAtAnchor + totalSupply() * (_anchorTime() - totalVotesAnchorTime);\n    }\n\n    /**\n     * @notice Since quorum is rather low, it is important to have a way to prevent malicious minority holders\n     * from blocking the whole system. This method provides a way for the good guys to team up and destroy\n     * the bad guy's votes (at the cost of also reducing their own votes). This mechanism potentially\n     * gives full control over the system to whoever has 51% of the votes.\n     *\n     * Since this is a rather aggressive measure, delegation is not supported. Every holder must call this\n     * method on their own.\n     * @param targets   The target addresses to remove votes from\n     * @param votesToDestroy    The maximum number of votes the caller is willing to sacrifice\n     */\n    function kamikaze(address[] calldata targets, uint256 votesToDestroy) external {\n        uint256 budget = _reduceVotes(msg.sender, votesToDestroy);\n        uint256 destroyedVotes = 0;\n        for (uint256 i = 0; i < targets.length && destroyedVotes < budget; i++) {\n            destroyedVotes += _reduceVotes(targets[i], budget - destroyedVotes);\n        }\n        require(destroyedVotes > 0); // sanity check\n        totalVotesAtAnchor = uint192(totalVotes() - destroyedVotes - budget);\n        totalVotesAnchorTime = _anchorTime();\n    }\n\n    function _reduceVotes(address target, uint256 amount) internal returns (uint256) {\n        uint256 votesBefore = votes(target);\n        if (amount >= votesBefore) {\n            voteAnchor[target] = _anchorTime();\n            return votesBefore;\n        } else {\n            voteAnchor[target] = uint64(_anchorTime() - (votesBefore - amount) / balanceOf(target));\n            return votesBefore - votes(target);\n        }\n    }\n\n    /**\n     * @notice Call this method to obtain newly minted pool shares in exchange for Frankencoins.\n     * No allowance required (i.e. it is hardcoded in the Frankencoin token contract).\n     * Make sure to invest at least 10e-12 * market cap to avoid rounding losses.\n     *\n     * @dev If equity is close to zero or negative, you need to send enough ZCHF to bring equity back to 1000 ZCHF.\n     *\n     * @param amount            Frankencoins to invest\n     * @param expectedShares    Minimum amount of expected shares for frontrunning protection\n     */\n    function invest(uint256 amount, uint256 expectedShares) external returns (uint256) {\n        zchf.transferFrom(msg.sender, address(this), amount);\n        uint256 equity = zchf.equity();\n        require(equity >= MINIMUM_EQUITY, \"insuf equity\"); // ensures that the initial deposit is at least 1000 ZCHF\n\n        uint256 shares = _calculateShares(equity <= amount ? 0 : equity - amount, amount);\n        require(shares >= expectedShares);\n        _mint(msg.sender, shares);\n        emit Trade(msg.sender, int(shares), amount, price());\n\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\n        // the 36 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\n        require(totalSupply() <= type(uint96).max, \"total supply exceeded\");\n        return shares;\n    }\n\n    /**\n     * @notice Calculate shares received when investing Frankencoins\n     * @param investment    ZCHF to be invested\n     * @return shares to be received in return\n     */\n    function calculateShares(uint256 investment) external view returns (uint256) {\n        return _calculateShares(zchf.equity(), investment);\n    }\n\n    function _calculateShares(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 investmentExFees = (investment * 997) / 1000; // remove 0.3% fee\n        // Assign 1000 FPS for the initial deposit, calculate the amount otherwise\n        uint256 newTotalShares = capitalBefore < MINIMUM_EQUITY || totalShares == 0\n            ? totalShares + 1000 * ONE_DEC18\n            : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investmentExFees, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    /**\n     * @notice Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\n     * @return The amount of ZCHF transferred to the target\n     */\n    function redeem(address target, uint256 shares) external returns (uint256) {\n        return _redeemFrom(msg.sender, target, shares);\n    }\n\n    /**\n     * @notice Like redeem(...), but with an extra parameter to protect against frontrunning.\n     * @param expectedProceeds  The minimum acceptable redemption proceeds.\n     */\n    function redeemExpected(address target, uint256 shares, uint256 expectedProceeds) external returns (uint256) {\n        uint256 proceeds = _redeemFrom(msg.sender, target, shares);\n        require(proceeds >= expectedProceeds);\n        return proceeds;\n    }\n\n    /**\n     * @notice Redeem FPS based on an allowance from the owner to the caller.\n     * See also redeemExpected(...).\n     */\n    function redeemFrom(\n        address owner,\n        address target,\n        uint256 shares,\n        uint256 expectedProceeds\n    ) external returns (uint256) {\n        _useAllowance(owner, msg.sender, shares);\n        uint256 proceeds = _redeemFrom(owner, target, shares);\n        require(proceeds >= expectedProceeds);\n        return proceeds;\n    }\n\n    function _redeemFrom(address owner, address target, uint256 shares) internal returns (uint256) {\n        require(canRedeem(owner));\n        uint256 proceeds = calculateProceeds(shares);\n        _burn(owner, shares);\n        zchf.transfer(target, proceeds);\n        emit Trade(owner, -int(shares), proceeds, price());\n        return proceeds;\n    }\n\n    /**\n     * @notice Calculate ZCHF received when depositing shares\n     * @param shares number of shares we want to exchange for ZCHF,\n     *               in dec18 format\n     * @return amount of ZCHF received for the shares\n     */\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n        uint256 capital = zchf.equity();\n        uint256 reductionAfterFees = (shares * 997) / 1000;\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(totalShares - reductionAfterFees, totalShares)));\n        return capital - newCapital;\n    }\n\n    /**\n     * @notice If there is less than 1000 ZCHF in equity left (maybe even negative), the system is at risk\n     * and we should allow qualified FPS holders to restructure the system.\n     *\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\n     * Frankencoin system except for a group of small FPS holders who still believes in it and is willing to provide\n     * 2'000'000 ZCHF to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\n     * would be wrong to force them to share the other million with the passive FPS holders. Instead, they will get\n     * the possibility to bootstrap the system again owning 100% of all FPS shares.\n     *\n     * @param helpers          A list of addresses that delegate to the caller in incremental order\n     * @param addressesToWipe  A list of addresses whose FPS will be burned to zero\n     */\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) external {\n        require(zchf.equity() < MINIMUM_EQUITY);\n        checkQualified(msg.sender, helpers);\n        for (uint256 i = 0; i < addressesToWipe.length; i++) {\n            address current = addressesToWipe[i];\n            _burn(current, balanceOf(current));\n        }\n    }\n}\n"
    },
    "contracts/equity/Governance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernance.sol\";\n\nabstract contract Governance is IGovernance {\n\n    /**\n     * @notice The quorum in basis points. 100 is 1%.\n     */\n    uint32 private constant QUORUM = 200;\n\n    /**\n     * @notice Keeping track on who delegated votes to whom.\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\n     */\n    mapping(address owner => address delegate) public delegates;\n\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\n\n    /**\n     * @notice The votes of the holder, excluding votes from delegates.\n     */\n    function votes(address holder) virtual public view returns (uint256);\n\n    /**\n     * @notice Total number of votes in the system.\n     */\n    function totalVotes() virtual public view returns (uint256);\n\n    /**\n     * @notice The number of votes the sender commands when taking the support of the helpers into account.\n     * @param sender    The address whose total voting power is of interest\n     * @param helpers   An incrementally sorted list of helpers without duplicates and without the sender.\n     *                  The call fails if the list contains an address that does not delegate to sender.\n     *                  For indirect delegates, i.e. a -> b -> c, both a and b must be included for both to count.\n     * @return          The total number of votes of sender at the current point in time.\n     */\n    function votesDelegated(address sender, address[] calldata helpers) public view returns (uint256) {\n        uint256 _votes = votes(sender);\n        require(_checkDuplicatesAndSorted(helpers));\n        for (uint i = 0; i < helpers.length; i++) {\n            address current = helpers[i];\n            require(current != sender);\n            require(_canVoteFor(sender, current));\n            _votes += votes(current);\n        }\n        return _votes;\n    }\n\n    function _checkDuplicatesAndSorted(address[] calldata helpers) internal pure returns (bool ok) {\n        if (helpers.length <= 1) {\n            return true;\n        } else {\n            address prevAddress = helpers[0];\n            for (uint i = 1; i < helpers.length; i++) {\n                if (helpers[i] <= prevAddress) {\n                    return false;\n                }\n                prevAddress = helpers[i];\n            }\n            return true;\n        }\n    }\n\n    /**\n     * @notice Checks whether the sender address is qualified given a list of helpers that delegated their votes\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\n     * helpes are necessary and to identify them by scanning the blockchain for Delegation events.\n     */\n    function checkQualified(address sender, address[] calldata helpers) public view override {\n        uint256 _votes = votesDelegated(sender, helpers);\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\n    }\n\n    error NotQualified();\n\n    /**\n     * @notice Increases the voting power of the delegate by your number of votes without taking away any voting power\n     * from the sender.\n     */\n    function delegateVoteTo(address delegate_) external {\n        delegate(msg.sender, delegate_);\n    }\n\n    function delegate(address owner, address delegate_) internal {\n        delegates[owner] = delegate_;\n        emit Delegation(owner, delegate_);\n    }\n\n    function _canVoteFor(address delegate_, address owner) internal view returns (bool) {\n        if (owner == delegate_) {\n            return true;\n        } else if (owner == address(0x0)) {\n            return false;\n        } else {\n            return _canVoteFor(delegate_, delegates[owner]);\n        }\n    }\n\n}"
    },
    "contracts/equity/GovernanceSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {SyncVote, SyncMessage} from \"./IGovernance.sol\";\nimport {Governance} from \"./Governance.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {IERC20} from \"../erc20/IERC20.sol\";\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\n\ncontract GovernanceSender is CCIPSender {\n    Governance public immutable GOVERNANCE;\n\n    event VotesSynced(\n        uint64 indexed chain, // The chain selector of the destination chain.\n        bytes receiver,\n        address[] syncedVoters\n    );\n\n    constructor(Governance _governance, IRouterClient _router, address _linkToken) CCIPSender(_router, _linkToken) {\n        GOVERNANCE = _governance;\n    }\n\n    function syncVotes(uint64 chain, address _receiver, address[] calldata _voters) external payable {\n        syncVotes(chain, _toReceiver(_receiver), _voters, \"\");\n    }\n\n    function syncVotes(uint64 chain, address _receiver, address[] calldata _voters, Client.EVMExtraArgsV2 calldata _extraArgs) public payable {\n        syncVotes(chain, _toReceiver(_receiver), _voters, Client._argsToBytes(_extraArgs));\n    }\n\n    /**\n     * @notice Sync governance votes to destination paying with native token\n     * @dev extraArgs for CCIP can be provided such as gasLimit or out-of-order execution\n     *\n     * @param _receiver                 Address of the recipient on the destination chain\n     * @param chain Chain selector of the destination chain\n     * @param _voters                   Collection of addresses which votes and delegation should be synced\n     *\n     */\n    function syncVotes(uint64 chain, bytes memory _receiver, address[] calldata _voters, bytes memory _extraArgs) public payable {\n        SyncMessage memory syncMessage = _buildSyncMessage(_voters);\n        Client.EVM2AnyMessage memory message = _constructMessage(_receiver, abi.encode(syncMessage), new Client.EVMTokenAmount[](0), _extraArgs);\n        _send(chain, message);\n        emit VotesSynced(chain, _receiver, _voters);\n    }\n\n    function getSyncFee(uint64 chain, address _receiver, address[] calldata _voters, bool useNativeToken) external view returns (uint256) {\n        return getSyncFee(chain, _toReceiver(_receiver), _voters, useNativeToken, \"\");\n    }\n\n    function getSyncFee(uint64 chain, address _receiver, address[] calldata _voters, bool useNativeToken, Client.EVMExtraArgsV2 calldata extraArgs) external view returns (uint256) {\n        return getSyncFee(chain, _toReceiver(_receiver), _voters, useNativeToken, Client._argsToBytes(extraArgs));\n    }\n\n    /**\n     * @notice Get the fee required to send a CCIP message.\n     * @param chain The selector of the destination chain.\n     * @param _voters                   Collection of addresses which votes and delegation should be synced\n     *\n     * @return uint256 The fee required to send the CCIP message.\n     */\n    function getSyncFee(uint64 chain, bytes memory _receiver, address[] calldata _voters, bool nativeToken, bytes memory extraArgs) public view returns (uint256) {\n        SyncMessage memory syncMessage = _buildSyncMessage(_voters);\n        Client.EVM2AnyMessage memory message = _constructMessage(_receiver, abi.encode(syncMessage), new Client.EVMTokenAmount[](0), nativeToken, extraArgs);\n        return _calculateFee(chain, message);\n    }\n\n    /**\n     * @notice Builds the CCIP payload to be sent\n     * @dev Gets the necessary information for voters from governance\n     * @param _voters           Voters to be synced\n     *\n     * @return SyncMessage The payload to be sent\n     */\n    function _buildSyncMessage(address[] calldata _voters) private view returns (SyncMessage memory) {\n        SyncVote[] memory _syncVotes = new SyncVote[](_voters.length);\n\n        // omitted unchecked optimization for readability\n        for (uint256 i = 0; i < _voters.length; i++) {\n            _syncVotes[i] = SyncVote({voter: _voters[i], votes: GOVERNANCE.votes(_voters[i]), delegatee: GOVERNANCE.delegates(_voters[i])});\n        }\n\n        return SyncMessage({votes: _syncVotes, totalVotes: GOVERNANCE.totalVotes()});\n    }\n}\n"
    },
    "contracts/equity/IGovernance.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IGovernance {\n   function checkQualified(address sender, address[] calldata helpers) external view;\n}\n\nstruct SyncVote {\n    address voter;\n    uint256 votes;\n    address delegatee;\n}\n\nstruct SyncMessage {\n    SyncVote[] votes;\n    uint256 totalVotes;\n}\n"
    },
    "contracts/erc20/CrossChainERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\n\nabstract contract CrossChainERC20 is ERC20, CCIPSender {\n    event Transfer(address indexed from, uint64 toChain, bytes indexed to, uint256 value);\n\n    constructor(address router, address linkToken) CCIPSender(IRouterClient(router), linkToken) {}\n\n    function transfer(uint64 targetChain, address target, uint256 amount) external payable {\n        transfer(targetChain, _toReceiver(target), amount, \"\");\n    }\n\n    function transfer(uint64 targetChain, address target, uint256 amount, Client.EVMExtraArgsV2 calldata extraArgs) external payable {\n        transfer(targetChain, _toReceiver(target), amount, Client._argsToBytes(extraArgs));\n    }\n\n    function transfer(uint64 targetChain, bytes memory target, uint256 amount, bytes memory extraArgs) public payable {\n        _transfer(msg.sender, address(this), amount);\n        _approve(address(this), address(ROUTER), amount);\n        _send(targetChain, constructTransferMessage(target, amount, extraArgs));\n        emit Transfer(msg.sender, targetChain, target, amount);\n    }\n\n    /// @notice Construct a CCIP message.\n    /// @dev This function will create an EVM2AnyMessage struct with all the necessary information for tokens transfer.\n    /// @param receiver The address of the receiver.\n    /// @param amount The amount of the token to be transferred.\n    /// @return Client.EVM2AnyMessage Returns an EVM2AnyMessage struct which contains information for sending a CCIP message.\n    function constructTransferMessage(bytes memory receiver, uint256 amount, bytes memory extraArgs) private view returns (Client.EVM2AnyMessage memory) {\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        tokenAmounts[0] = Client.EVMTokenAmount(address(this), amount);\n        return _constructMessage(receiver, \"\", tokenAmounts, extraArgs);\n    }\n}\n"
    },
    "contracts/erc20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied and adjusted from OpenZeppelin\n// Adjustments:\n// - modifications to support ERC-677\n// - removed require messages to save space\n// - removed unnecessary require statements\n// - removed GSN Context\n// - upgraded to 0.8 to drop SafeMath\n// - let name() and symbol() be implemented by subclass\n// - infinite allowance support, with 2^255 and above considered infinite\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC677Receiver.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n */\n\nabstract contract ERC20 is IERC20 {\n    mapping(address account => uint256 balance) private _balances;\n\n    mapping(address account => mapping(address spender => uint256 allowance)) private _allowances;\n\n    uint256 internal constant INFINITY = (1 << 255);\n\n    uint256 private _totalSupply;\n\n    uint8 public immutable override decimals;\n\n    // Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4139/files#diff-fa792f7d08644eebc519dac2c29b00a54afc4c6a76b9ef3bba56c8401fe674f6\n    // Indicates an error related to the current balance of a sender. Used in transfers.\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n    // Indicates a failure with the spender’s allowance. Used in transfers.\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    constructor(uint8 _decimals) {\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowance(owner, spender);\n    }\n\n    function _allowance(address owner, address spender) internal view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _useAllowance(sender, msg.sender, amount);\n        return true;\n    }\n\n    function _useAllowance(address owner, address spender, uint256 amount) internal {\n        uint256 currentAllowance = _allowance(owner, spender);\n        if (currentAllowance < INFINITY) {\n            // Only decrease the allowance if it was not set to 'infinite'\n            // Documented in github.com/aktionariat/contracts/blob/master/doc/infiniteallowance.md\n            if (currentAllowance < amount) revert ERC20InsufficientAllowance(owner, currentAllowance, amount);\n            _approve(owner, spender, currentAllowance - amount);\n        }\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(sender, recipient, amount);\n        if (_balances[sender] < amount) revert ERC20InsufficientBalance(sender, _balances[sender], amount);\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(address(0), recipient, amount);\n\n        _totalSupply += amount;\n        _balances[recipient] += amount;\n        emit Transfer(address(0), recipient, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _totalSupply -= amount;\n        _balances[account] -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "contracts/erc20/ERC20PermitLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract ERC20PermitLight is ERC20 {\n    /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address account => uint256 nonce) public nonces;\n\n    /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        unchecked {\n            // unchecked to save a little gas with the nonce increment...\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n                                bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    //keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n                    bytes32(0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n}\n"
    },
    "contracts/erc20/IERC20.sol": {
      "content": "/**\n * SPDX-License-Identifier: MIT\n *\n * Copyright (c) 2016-2019 zOS Global Limited\n *\n */\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value can change when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns always true. Throws error on failure.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/erc20/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677Receiver {\n    \n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}"
    },
    "contracts/minting/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\n\ninterface IPosition {\n\n    function initialize(address parent, uint40 _expiration) external;\n\n    function hub() external view returns(address);\n\n    function original() external view returns (address);\n\n    function collateral() external view returns (IERC20);\n\n    function minimumCollateral() external view returns (uint256);\n\n    function challengePeriod() external view returns (uint40);\n\n    function expiration() external view returns (uint40);\n\n    function price() external view returns (uint256);\n\n    function deny(address[] calldata helpers, string calldata message) external;\n\n    function mint(address target, uint256 amount) external;\n\n    function repay(uint256 amount) external returns (uint256);\n\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) external;\n\n    function minted() external view returns (uint256);\n\n    function availableForMinting() external view returns (uint256);\n\n    function reserveContribution() external view returns (uint24);\n\n    function withdrawCollateral(address target, uint256 amount) external;\n\n    function getUsableMint(uint256 totalMint, bool beforeFees) external view returns (uint256);\n\n    function getMintAmount(uint256 usableMint) external view returns (uint256);\n\n    function challengeData() external view returns (uint256 liqPrice, uint40 phase);\n\n    function notifyChallengeStarted(uint256 size) external;\n\n    function notifyChallengeAverted(uint256 size) external;\n\n    function notifyChallengeSucceeded(address _bidder, uint256 _size) external returns (address, uint256, uint256, uint32);\n\n    function forceSale(address buyer, uint256 collAmount, uint256 proceeds) external;\n\n}"
    },
    "contracts/rate/AbstractLeadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\n\n/**\n * @title Leadrate (attempt at translating the nicely concise German term 'Leitzins')\n *\n * A module that can provide other modules with the lead interest rate for the system.\n * \n * This is an abstract module that is agnostic about the way the lead rate is updated.\n *\n **/\nabstract contract AbstractLeadrate {\n\n    // the following five variables are less than 256 bit so they should be stored\n    // in the same slot, making them cheap to access together, right?\n\n    uint24 public currentRatePPM; // 24 bit allows rates of up to 1670% per year\n\n    uint40 private anchorTime; // 40 bits for time in seconds spans up to 1000 human generations\n    uint64 private ticksAnchor; // in bips * seconds, uint88 allows up to\n\n    event RateChanged(uint24 newRate);\n\n    constructor(uint24 initialRatePPM) {\n        currentRatePPM = initialRatePPM;\n        anchorTime = uint40(block.timestamp);\n        ticksAnchor = 0;\n        emit RateChanged(initialRatePPM); // emit for init indexing, if wanted\n    }\n\n    /**\n     * Setting a previously proposed interest rate change into force.\n     */\n    function updateRate(uint24 rate) internal {\n        uint40 timeNow = uint40(block.timestamp);\n        ticksAnchor += (timeNow - anchorTime) * currentRatePPM;\n        anchorTime = timeNow;\n        currentRatePPM = rate;\n        emit RateChanged(rate);\n    }\n\n    /**\n     * Total accumulated 'interest ticks' since this contract was deployed.\n     * One 'tick' is a ppm-second, so one months of 12% annual interest is\n     *   120000*30*24*3600 = 311040000000 ticks.\n     * Two months of 6% annual interest would result in the same number of\n     * ticks. For simplicity, this is linear, so there is no \"interest on interest\".\n     */\n    function currentTicks() public view returns (uint64) {\n        return ticks(block.timestamp);\n    }\n\n    function ticks(uint256 timestamp) public view returns (uint64) {\n        return ticksAnchor + (uint64(timestamp) - anchorTime) * currentRatePPM;\n    }\n\n}\n"
    },
    "contracts/rate/Leadrate.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../stablecoin/IFrankencoin.sol\";\nimport \"../minting/IPosition.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"./AbstractLeadrate.sol\";\n\n/**\n * @title Leadrate (attempt at translating the nicely concise German term 'Leitzins')\n *\n * A module that can provide other modules with the lead interest rate for the system.\n *\n **/\ncontract Leadrate is AbstractLeadrate {\n\n    IGovernance public immutable equity;\n\n    // the following five variables are less than 256 bit so they should be stored\n    // in the same slot, making them cheap to access together, right?\n\n    uint24 public nextRatePPM;\n    uint40 public nextChange;\n\n    event RateProposed(address who, uint24 nextRate, uint40 nextChange);\n    error NoPendingChange();\n    error ChangeNotReady();\n\n    constructor(IGovernance equity_, uint24 initialRatePPM) AbstractLeadrate(initialRatePPM) {\n        equity = equity_;\n        nextRatePPM = initialRatePPM;\n        nextChange = uint40(block.timestamp);\n    }\n\n    /**\n     * Proposes a new interest rate that will automatically be applied after seven days.\n     * To cancel a proposal, just overwrite it with a new one proposing the current rate.\n     */\n    function proposeChange(uint24 newRatePPM_, address[] calldata helpers) external {\n        equity.checkQualified(msg.sender, helpers);\n        nextRatePPM = newRatePPM_;\n        nextChange = uint40(block.timestamp + 7 days);\n        emit RateProposed(msg.sender, nextRatePPM, nextChange);\n    }\n\n    /**\n     * Setting a previously proposed interest rate change into force.\n     */\n    function applyChange() external {\n        if (currentRatePPM == nextRatePPM) revert NoPendingChange();\n        uint40 timeNow = uint40(block.timestamp);\n        if (timeNow < nextChange) revert ChangeNotReady();\n        super.updateRate(nextRatePPM);\n    }\n\n}\n"
    },
    "contracts/rate/LeadrateSender.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {Leadrate} from \"./Leadrate.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\n\ncontract LeadrateSender is CCIPSender {\n    Leadrate public immutable LEADRATE;\n\n    event Pushed(uint64 chain, bytes indexed bridgedLeadrate, uint24 newRatePPM);\n\n    error LengthMismatch(uint256 expected, uint256 given);\n\n    constructor(Leadrate _leadrate, IRouterClient _router, address _linkToken) CCIPSender(_router, _linkToken) {\n        LEADRATE = _leadrate;\n    }\n\n    function pushLeadrate(uint64[] calldata chains, bytes[] calldata targets) external payable {\n        pushLeadrate(chains, targets, new bytes[](chains.length));\n    }\n\n    function pushLeadrate(uint64[] calldata chains, bytes[] calldata targets, bytes[] memory extraArgs) public payable {\n        if (chains.length != targets.length) revert LengthMismatch(chains.length, targets.length);\n        if (chains.length != extraArgs.length) revert LengthMismatch(chains.length, extraArgs.length);\n        _applyPendingChanges();\n        uint24 currentRate = LEADRATE.currentRatePPM();\n        for (uint256 i; i < chains.length; i++) {\n            _sendLeadrate(chains[i], targets[i], currentRate, extraArgs[i]);\n        }\n    }\n\n    function pushLeadrate(uint64 chain, address target) external payable {\n        pushLeadrate(chain, _toReceiver(target), \"\");\n    }\n\n    function pushLeadrate(uint64 chain, address target, Client.EVMExtraArgsV2 calldata extraArgs) external payable {\n        pushLeadrate(chain, _toReceiver(target), Client._argsToBytes(extraArgs));\n    }\n\n    function pushLeadrate(uint64 chain, bytes memory target, bytes memory extraArgs) public payable {\n        _applyPendingChanges();\n        _sendLeadrate(chain, target, LEADRATE.currentRatePPM(), extraArgs);\n    }\n\n    function _sendLeadrate(uint64 chain, bytes memory target, uint24 newRatePPM, bytes memory extraArgs) internal {\n        _send(chain, _constructMessage(target, abi.encode(newRatePPM), new Client.EVMTokenAmount[](0), extraArgs));\n        emit Pushed(chain, target, newRatePPM);\n    }\n\n    function _applyPendingChanges() internal {\n        if (LEADRATE.currentRatePPM() != LEADRATE.nextRatePPM() && LEADRATE.nextChange() < block.timestamp) {\n            LEADRATE.applyChange(); // there is a pending change to apply\n        }\n    }\n}\n"
    },
    "contracts/stablecoin/BridgedFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../equity/BridgedGovernance.sol\";\nimport \"../erc20/ERC20PermitLight.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"../equity/Equity.sol\";\nimport \"./IBasicFrankencoin.sol\";\nimport \"../erc20/CrossChainERC20.sol\";\nimport \"../bridge/CCIPSender.sol\";\n\n/**\n * @title Bridged Frankencoin ERC-20 Token\n *\n * Like its mainnet counterpart, it has the capapbility to add minting modules. This allows to\n * potentially add similar collateralized minting methods as in the mainnet Frankencoin.\n *\n * However, there is only one FPS, the one on mainnet and voting power has to be projected onto the\n * side chains.\n */\ncontract BridgedFrankencoin is CrossChainERC20, ERC20PermitLight, IBasicFrankencoin {\n    /**\n     * @notice Minimal fee and application period when suggesting a new minter.\n     */\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n    address public immutable BRIDGE_ACCOUNTING;\n    uint64 public immutable MAINNET_CHAIN_SELECTOR;\n    address public immutable CCIP_ADMIN;\n\n    /**\n     * @notice The contract that holds the reserve.\n     */\n    IGovernance public immutable override reserve;\n\n    /**\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n     * to mint Frankencoins.\n     */\n    mapping(address minter => uint256 validityStart) public minters;\n\n    /**\n     * @notice List of positions that are allowed to mint and the minter that registered them.\n     */\n    mapping(address position => address registeringMinter) public positions;\n\n    uint256 public accruedLoss;\n    bool public initialized;\n\n    event AccountingSynchronized(uint256 profit, uint256 losses);\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n    event MinterDenied(address indexed minter, string message);\n    event Loss(address indexed reportingMinter, uint256 amount);\n    event Profit(address indexed reportingMinter, uint256 amount);\n\n    error PeriodTooShort();\n    error FeeTooLow();\n    error AlreadyRegistered();\n    error NotMinter();\n    error TooLate();\n    error AlreadyInitialized();\n\n    modifier minterOnly() {\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n        _;\n    }\n\n    /**\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n     */\n    constructor(IGovernance reserve_, address router_, uint256 _minApplicationPeriod, address _linkToken, uint64 _mainnetChainSelector, address _bridgeAccounting, address _ccipAdmin) ERC20(18) CrossChainERC20(router_, _linkToken) {\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n        reserve = reserve_;\n        MAINNET_CHAIN_SELECTOR = _mainnetChainSelector;\n        BRIDGE_ACCOUNTING = _bridgeAccounting;\n        CCIP_ADMIN = _ccipAdmin;\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Frankencoin\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"ZCHF\";\n    }\n\n    function initialize(address _minter, string calldata _message) external {\n        if (initialized) revert AlreadyInitialized();\n        minters[_minter] = block.timestamp;\n        initialized = true;\n        emit MinterApplied(_minter, 0, 0, _message);\n    }\n\n    /**\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\n     * the proposed minter.\n     *\n     * @param _minter              An address that is given the permission to mint Frankencoins\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\n     * @param _message             An optional human readable message to everyone watching this contract\n     */\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) external override {\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\n        if (minters[_minter] != 0) revert AlreadyRegistered();\n        _collectProfits(address(this), msg.sender, _applicationFee);\n        minters[_minter] = block.timestamp + _applicationPeriod;\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n    }\n\n    /**\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\n     * giving them arbitrary allowances does not pose an additional risk.\n     */\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\n        uint256 explicit = super._allowance(owner, spender);\n        if (explicit > 0) {\n            return explicit; // don't waste gas checking minter\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\n            return INFINITY;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n     */\n    function registerPosition(address _position) external override {\n        if (!isMinter(msg.sender)) revert NotMinter();\n        positions[_position] = msg.sender;\n    }\n\n    /**\n     * @notice Qualified pool share holders can deny minters during the application period.\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\n     */\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\n        if (block.timestamp > minters[_minter]) revert TooLate();\n        reserve.checkQualified(msg.sender, _helpers);\n        delete minters[_minter];\n        emit MinterDenied(_minter, _message);\n    }\n\n    function mint(address _target, uint256 _amount) external override minterOnly {\n        _mint(_target, _amount);\n    }\n\n    /**\n     * Anyone is allowed to burn their ZCHF.\n     */\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Burn someone elses ZCHF.\n     */\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\n        _burn(_owner, _amount);\n    }\n\n    function canMint(address _minterOrPosition) public view returns (bool) {\n        return isMinter(_minterOrPosition) || isMinter(positions[_minterOrPosition]);\n    }\n\n    /**\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\n     *\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\n     * by the reserve.\n     */\n    function coverLoss(address source, uint256 _amount) external minterOnly {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        if (_amount > reserveLeft) {\n            accruedLoss += (_amount - reserveLeft);\n            _mint(address(reserve), _amount - reserveLeft);\n        }\n        _transfer(address(reserve), source, _amount);\n        emit Loss(source, _amount);\n    }\n\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\n        _collectProfits(msg.sender, source, _amount);\n    }\n\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\n        _transfer(source, address(reserve), _amount);\n        if (accruedLoss > _amount) {\n            accruedLoss -= _amount;\n            _burn(address(reserve), _amount);\n        } else if (accruedLoss > 0) {\n            _burn(address(reserve), accruedLoss);\n            accruedLoss = 0;\n        }\n        emit Profit(minter, _amount);\n    }\n\n    function synchronizeAccounting() public payable {\n        synchronizeAccounting(\"\");\n    }\n\n    function synchronizeAccounting(Client.EVMExtraArgsV2 calldata extraArgs) public payable {\n        synchronizeAccounting(Client._argsToBytes(extraArgs));\n    }\n\n    /**\n     * Uses a multichain call to send home all accrued profits, if any\n     */\n    function synchronizeAccounting(bytes memory extraArgs) public payable {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        uint256 _accuredLoss = accruedLoss;\n        accruedLoss = 0;\n\n        if (reserveLeft > 0) {\n            _transfer(address(reserve), address(this), reserveLeft);\n            _approve(address(this), address(ROUTER), reserveLeft);\n        }\n\n        Client.EVMTokenAmount[] memory tokenAmounts = new Client.EVMTokenAmount[](1);\n        tokenAmounts[0] = Client.EVMTokenAmount({token: address(this), amount: reserveLeft});\n        Client.EVM2AnyMessage memory message = _constructMessage(_toReceiver(BRIDGE_ACCOUNTING), abi.encode(reserveLeft, _accuredLoss), tokenAmounts, extraArgs);\n        _send(MAINNET_CHAIN_SELECTOR, message);\n        emit AccountingSynchronized(reserveLeft, _accuredLoss);\n    }\n\n    /**\n     * @notice Returns true if the address is an approved minter.\n     */\n    function isMinter(address _minter) public view returns (bool) {\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n    }\n\n    /**\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\n     */\n    function getPositionParent(address _position) public view returns (address) {\n        return positions[_position];\n    }\n\n    /*\n     * @notice Used to register the token initialially in the CCIP environment\n     */\n    function getCCIPAdmin() external view returns(address) {\n        return CCIP_ADMIN;\n    }\n}\n"
    },
    "contracts/stablecoin/Frankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/ERC20PermitLight.sol\";\nimport \"../equity/IGovernance.sol\";\nimport \"../equity/Equity.sol\";\nimport \"./IBasicFrankencoin.sol\";\nimport \"./IFrankencoin.sol\";\n\n/**\n * @title FrankenCoin\n * @notice The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\n */\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\n    /**\n     * @notice Minimal fee and application period when suggesting a new minter.\n     */\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\n\n    /**\n     * @notice The contract that holds the reserve.\n     */\n    IGovernance public immutable override reserve;\n\n    /**\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\n     * million (ppm) in reserve calculations.\n     */\n    uint256 private minterReserveE6;\n\n    /**\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\n     * to mint Frankencoins.\n     */\n    mapping(address minter => uint256 validityStart) public minters;\n\n    /**\n     * @notice List of positions that are allowed to mint and the minter that registered them.\n     */\n    mapping(address position => address registeringMinter) public positions;\n\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n    event MinterDenied(address indexed minter, string message);\n    event Loss(address indexed reportingMinter, uint256 amount);\n    event Profit(address indexed reportingMinter, uint256 amount);\n\n    error PeriodTooShort();\n    error FeeTooLow();\n    error AlreadyRegistered();\n    error NotMinter();\n    error TooLate();\n\n    modifier minterOnly() {\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\n        _;\n    }\n\n    /**\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\n     */\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n        reserve = new Equity(this);\n    }\n\n    function name() external pure override returns (string memory) {\n        return \"Frankencoin\";\n    }\n\n    function symbol() external pure override returns (string memory) {\n        return \"ZCHF\";\n    }\n\n    function initialize(address _minter, string calldata _message) external {\n        require(totalSupply() == 0 && (Equity(address(reserve)).totalSupply() == 0));\n        minters[_minter] = block.timestamp;\n        emit MinterApplied(_minter, 0, 0, _message);\n    }\n\n    /**\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\n     * the proposed minter.\n     *\n     * @param _minter              An address that is given the permission to mint Frankencoins\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\n     * @param _message             An optional human readable message to everyone watching this contract\n     */\n    function suggestMinter(\n        address _minter,\n        uint256 _applicationPeriod,\n        uint256 _applicationFee,\n        string calldata _message\n    ) external override {\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\n        if (minters[_minter] != 0) revert AlreadyRegistered();\n        _collectProfits(address(this), msg.sender, _applicationFee);\n        minters[_minter] = block.timestamp + _applicationPeriod;\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n    }\n\n    /**\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\n     * giving them arbitrary allowances does not pose an additional risk.\n     */\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\n        uint256 explicit = super._allowance(owner, spender);\n        if (explicit > 0) {\n            return explicit; // don't waste gas checking minter\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\n            return INFINITY;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * @notice The reserve provided by the owners of collateralized positions.\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\n     */\n    function minterReserve() public view returns (uint256) {\n        return minterReserveE6 / 1000000;\n    }\n\n    /**\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\n     */\n    function registerPosition(address _position) external override {\n        if (!isMinter(msg.sender)) revert NotMinter();\n        positions[_position] = msg.sender;\n    }\n\n    /**\n     * @notice The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\n     * constitutes profits attributable to the pool share holders.\n     */\n    function equity() public view returns (uint256) {\n        uint256 balance = balanceOf(address(reserve));\n        uint256 minReserve = minterReserve();\n        if (balance <= minReserve) {\n            return 0;\n        } else {\n            return balance - minReserve;\n        }\n    }\n\n    /**\n     * @notice Qualified pool share holders can deny minters during the application period.\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\n     */\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\n        if (block.timestamp > minters[_minter]) revert TooLate();\n        reserve.checkQualified(msg.sender, _helpers);\n        delete minters[_minter];\n        emit MinterDenied(_minter, _message);\n    }\n\n    /**\n     * @notice Mints the provided amount of ZCHF to the target address, automatically forwarding\n     * the minting fee and the reserve to the right place.\n     */\n    function mintWithReserve(\n        address _target,\n        uint256 _amount,\n        uint32 _reservePPM,\n        uint32 _feesPPM\n    ) external override minterOnly {\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\n        _mint(_target, usableMint);\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\n        minterReserveE6 += _amount * _reservePPM;\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\n    }\n\n    function mint(address _target, uint256 _amount) external override minterOnly {\n        _mint(_target, _amount);\n    }\n\n    /**\n     * Anyone is allowed to burn their ZCHF.\n     */\n    function burn(uint256 _amount) external {\n        _burn(msg.sender, _amount);\n    }\n\n    /**\n     * @notice Burn someone elses ZCHF.\n     */\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\n        _burn(_owner, _amount);\n    }\n\n    /**\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\n     *\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\n     * the same _reservePPM amount.\n     *\n     * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF\n     * and paid 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this\n     * method, 50 ZCHF get burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are\n     * reassigned to the pool share holders.\n     *\n     * CS-ZCHF2-009: the Profit event can overstate profits in case there is no equity capital left.\n     */\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\n        _burn(msg.sender, amount);\n        uint256 reserveReduction = amount * reservePPM;\n        if (reserveReduction > minterReserveE6) {\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\n        } else {\n            minterReserveE6 -= reserveReduction;\n            emit Profit(msg.sender, reserveReduction / 1000_000);\n        }\n    }\n\n    /**\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\n     * same _reservePPM amount.\n     *\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\n     * Now they have 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\n     * 'debt' of the caller by 50 ZCHF in total. This total is returned by the method so the caller knows how much less\n     * they owe.\n     */\n    function burnWithReserve(\n        uint256 _amountExcludingReserve,\n        uint32 _reservePPM\n    ) external override minterOnly returns (uint256) {\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\n        return freedAmount;\n    }\n\n    /**\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\n     *\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves\n     * are only 90% covered, this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while\n     * reducing the minter reserve by 10.\n     */\n    function burnFromWithReserve(\n        address payer,\n        uint256 targetTotalBurnAmount,\n        uint32 reservePPM\n    ) external override minterOnly returns (uint256) {\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\n        return assigned;\n    }\n\n    /**\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\n     * Under normal circumstances, this is just the reserve requirement multiplied by the amount. However, after a\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\n     */\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\n        uint256 currentReserve = balanceOf(address(reserve));\n        uint256 minterReserve_ = minterReserve();\n        if (currentReserve < minterReserve_) {\n            // not enough reserves, owner has to take a loss\n            return (theoreticalReserve * currentReserve) / minterReserve_;\n        } else {\n            return theoreticalReserve;\n        }\n    }\n\n    /**\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\n     * taking into account potential losses. Example values in the comments.\n     */\n    function calculateFreedAmount(\n        uint256 amountExcludingReserve /* 41 */,\n        uint32 reservePPM /* 20% */\n    ) public view returns (uint256) {\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\n        uint256 minterReserve_ = minterReserve(); // 20\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\n            ? (reservePPM * currentReserve) / minterReserve_\n            : reservePPM; // 18%\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\n    }\n\n    /**\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\n     *\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\n     * by the reserve.\n     */\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\n        uint256 reserveLeft = balanceOf(address(reserve));\n        if (reserveLeft >= _amount) {\n            _transfer(address(reserve), source, _amount);\n        } else {\n            _transfer(address(reserve), source, reserveLeft);\n            _mint(source, _amount - reserveLeft);\n        }\n        emit Loss(source, _amount);\n    }\n\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\n        _collectProfits(msg.sender, source, _amount);\n    }\n\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\n        _transfer(source, address(reserve), _amount);\n        emit Profit(minter, _amount);\n    }\n\n    /**\n     * @notice Returns true if the address is an approved minter.\n     */\n    function isMinter(address _minter) public view override returns (bool) {\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\n    }\n\n    /**\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\n     */\n    function getPositionParent(address _position) public view override returns (address) {\n        return positions[_position];\n    }\n}\n"
    },
    "contracts/stablecoin/IBasicFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../erc20/IERC20.sol\";\nimport \"../equity/IGovernance.sol\";\n\ninterface IBasicFrankencoin is IERC20 {\n\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) external;\n\n    function registerPosition(address position) external;\n\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\n\n    function reserve() external view returns (IGovernance);\n\n    function isMinter(address minter) external view returns (bool);\n\n    function getPositionParent(address position) external view returns (address);\n\n    function mint(address target, uint256 amount) external;\n\n    function burnFrom(address target, uint256 amount) external;\n\n    function burn(uint256 amount) external;\n\n    function coverLoss(address source, uint256 amount) external;\n\n    function collectProfits(address source, uint256 _amount) external;\n}\n"
    },
    "contracts/stablecoin/IFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../equity/IGovernance.sol\";\nimport \"./IBasicFrankencoin.sol\";\n\ninterface IFrankencoin is IBasicFrankencoin {\n\n    function minterReserve() external view returns (uint256);\n\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) external view returns (uint256);\n\n    function calculateFreedAmount(uint256 amountExcludingReserve, uint32 reservePPM) external view returns (uint256);\n\n    function equity() external view returns (uint256);\n\n    function mintWithReserve(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\n\n    function burnWithoutReserve(uint256 amountIncludingReserve, uint32 reservePPM) external;\n\n    function burnFromWithReserve(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external returns (uint256);\n\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\n\n}\n"
    },
    "contracts/test/CCIPSenderTest.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\nimport {CCIPSender} from \"../bridge/CCIPSender.sol\";\nimport {Client} from \"@chainlink/contracts-ccip/src/v0.8/ccip/libraries/Client.sol\";\nimport {IRouterClient} from \"@chainlink/contracts-ccip/src/v0.8/ccip/interfaces/IRouterClient.sol\";\n\ncontract CCIPSenderTest is CCIPSender {\n    constructor(IRouterClient _router, address _link) CCIPSender(_router, _link) {}\n\n    function toReceiver(address target) public pure returns (bytes memory) {\n        return _toReceiver(target);\n    }\n\n    function constructMessage(\n        bytes memory _receiver,\n        bytes memory _payload,\n        Client.EVMTokenAmount[] memory _tokenAmounts,\n        bytes memory _extraArgs\n    ) public view returns (Client.EVM2AnyMessage memory) {\n        return _constructMessage(_receiver, _payload, _tokenAmounts, _extraArgs);\n    }\n\n    function constructMessage(\n        bytes memory _receiver,\n        bytes memory _payload,\n        Client.EVMTokenAmount[] memory _tokenAmounts,\n        bool nativeToken,\n        bytes memory _extraArgs\n    ) public view returns (Client.EVM2AnyMessage memory) {\n        return _constructMessage(_receiver, _payload, _tokenAmounts, nativeToken, _extraArgs);\n    }\n\n    function calculateFee(uint64 chain, Client.EVM2AnyMessage memory message) public view returns (uint256) {\n        return _calculateFee(chain, message);\n    }\n\n    function send(uint64 chain, Client.EVM2AnyMessage memory _message) public payable returns (bytes32, uint256) {\n        return _send(chain, _message);\n    }\n\n    function guessFeeToken() public view returns (address) {\n        return _guessFeeToken();\n    }\n}\n"
    },
    "contracts/utils/MathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @title Functions for share valuation\n */\ncontract MathUtil {\n    uint256 internal constant ONE_DEC18 = 10 ** 18;\n\n    // Let's go for 12 digits of precision (18-6)\n    uint256 internal constant THRESH_DEC18 = 10 ** 6;\n\n    /**\n     * @notice Cubic root with Halley approximation\n     *         Number 1e18 decimal\n     * @param _v     number for which we calculate x**(1/3)\n     * @return returns _v**(1/3)\n     */\n    function _cubicRoot(uint256 _v) internal pure returns (uint256) {\n        // Good first guess for _v slightly above 1.0, which is often the case in the Frankencoin system\n        uint256 x = _v > ONE_DEC18 && _v < 10 ** 19 ? (_v - ONE_DEC18) / 3 + ONE_DEC18 : ONE_DEC18;\n        uint256 diff;\n        do {\n            uint256 powX3 = _mulD18(_mulD18(x, x), x);\n            uint256 xnew = x * (powX3 + 2 * _v) / (2 * powX3 + _v);\n            diff = xnew > x ? xnew - x : x - xnew;\n            x = xnew;\n        } while (diff > THRESH_DEC18);\n        return x;\n    }\n\n    function _mulD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * _b) / ONE_DEC18;\n    }\n\n    function _divD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\n        return (_a * ONE_DEC18) / _b;\n    }\n\n    function _power3(uint256 _x) internal pure returns (uint256) {\n        return _mulD18(_mulD18(_x, _x), _x);\n    }\n\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}