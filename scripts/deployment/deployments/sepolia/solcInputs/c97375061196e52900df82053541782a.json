{
  "language": "Solidity",
  "sources": {
    "contracts/CloneFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n}"
    },
    "contracts/Equity.sol": {
      "content": "\n// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\nimport \"./Frankencoin.sol\";\nimport \"./IERC677Receiver.sol\";\nimport \"./ERC20PermitLight.sol\";\nimport \"./MathUtil.sol\";\nimport \"./IReserve.sol\";\n\n/** \n * @title Reserve pool for the Frankencoin\n */\ncontract Equity is ERC20PermitLight, MathUtil, IReserve {\n\n    uint32 public constant VALUATION_FACTOR = 3;\n    uint256 public constant MIN_HOLDING_DURATION = 90 days;\n    uint32 private constant QUORUM = 300;\n\n    Frankencoin immutable public zchf;\n\n    // should hopefully be grouped into one storage slot\n    uint64 private totalVotesAnchorTime;\n    uint192 private totalVotesAtAnchor;\n\n\n    mapping (address => address) public delegates;\n    mapping (address => uint64) private voteAnchor;\n\n    event Delegation(address indexed from, address indexed to);\n\n    constructor(Frankencoin zchf_) ERC20(18) {\n        zchf = zchf_;\n    }\n\n    function name() override external pure returns (string memory) {\n        return \"Frankencoin Pool Share\";\n    }\n\n    function symbol() override external pure returns (string memory) {\n        return \"FPS\";\n    }\n\n    function price() public view returns (uint256){\n        return VALUATION_FACTOR * zchf.equity() * ONE_DEC18 / totalSupply();\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 amount) override internal {\n        super._beforeTokenTransfer(from, to, amount);\n        if (amount > 0){\n            uint256 roundingLoss = adjustRecipientVoteAnchor(to, amount);\n            adjustTotalVotes(from, amount, roundingLoss);\n        }\n    }\n\n    function canRedeem() external view returns (bool){\n        return canRedeem(msg.sender);\n    }\n\n    function canRedeem(address owner) public view returns (bool) {\n        return block.number - voteAnchor[owner] >= MIN_HOLDING_DURATION;\n    }\n\n     /**\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\n     * @param from      sender\n     * @param amount    amount to be sent\n     */\n    function adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\n        uint256 lostVotes = from == address(0x0) ? 0 : (block.number - voteAnchor[from]) * amount;\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\n        totalVotesAnchorTime = uint64(block.number);\n    }\n\n    /**\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\n     * votes does not change despite the higher balance.\n     * @param to        receiver address\n     * @param amount    amount to be received\n     * @return the number of votes lost due to rounding errors\n     */\n    function adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256){\n        if (to != address(0x0)) {\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 blocks\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\n            voteAnchor[to] = uint64(block.number - recipientVotes / newbalance); // new example anchor is only 21 / 11 = 1 block in the past\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\n        } else {\n            // optimization for burn, vote anchor of null address does not matter\n            return 0;\n        }\n    }\n\n    function votes(address holder) public view returns (uint256) {\n        return balanceOf(holder) * (block.number - voteAnchor[holder]);\n    }\n\n    function totalVotes() public view returns (uint256) {\n        return totalVotesAtAnchor + totalSupply() * (block.number - totalVotesAnchorTime);\n    }\n\n    function isQualified(address sender, address[] calldata helpers) external override view returns (bool) {\n        uint256 _votes = votes(sender);\n        for (uint i=0; i<helpers.length; i++){\n            address current = helpers[i];\n            require(current != sender);\n            require(canVoteFor(sender, current));\n            for (uint j=i+1; j<helpers.length; j++){\n                require(current != helpers[j]);\n            }\n            _votes += votes(current);\n        }\n        return _votes * 10000 >= QUORUM * totalVotes();\n    }\n\n    function delegateVoteTo(address delegate) external {\n        delegates[msg.sender] = delegate;\n        emit Delegation(msg.sender, delegate);\n    }\n\n    function canVoteFor(address delegate, address owner) public view returns (bool) {\n        if (owner == delegate){\n            return true;\n        } else if (owner == address(0x0)){\n            return false;\n        } else {\n            return canVoteFor(delegate, delegates[owner]);\n        }\n    }\n\n    function onTokenTransfer(address from, uint256 amount, bytes calldata) external returns (bool) {\n        require(msg.sender == address(zchf), \"caller must be zchf\");\n        if (totalSupply() == 0){\n            require(amount >= ONE_DEC18, \"initial deposit must >= 1\");\n            // initialize with 1000 shares for 1 ZCHF\n            _mint(from, 1000 * 10**18);\n            amount -= ONE_DEC18;\n        } \n        _mint(from, calculateSharesInternal(zchf.equity() - amount, amount));\n        require(totalSupply() < 2**90, \"total supply exceeded\");\n        return true;\n    }\n\n    /**\n     * @notice Calculate shares received when depositing ZCHF\n     * @dev this function is called after the transfer of ZCHF happens\n     * @param investment ZCHF invested, in dec18 format\n     * @return amount of shares received for the ZCHF invested\n     */\n    function calculateShares(uint256 investment) public view returns (uint256) {\n        return calculateSharesInternal(zchf.equity(), investment);\n    }\n\n    function calculateSharesInternal(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 newTotalShares = _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\n        return newTotalShares - totalShares;\n    }\n\n    function redeem(address target, uint256 shares) public returns (uint256) {\n        require(canRedeem(msg.sender));\n        uint256 proceeds = calculateProceeds(shares);\n        _burn(msg.sender, shares);\n        zchf.transfer(target, proceeds);\n        return proceeds;\n    }\n\n    /**\n     * @notice Calculate ZCHF received when depositing shares\n     * @dev this function is called before any transfer happens\n     * @param shares number of shares we want to exchange for ZCHF,\n     *               in dec18 format\n     * @return amount of ZCHF received for the shares\n     */\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\n        uint256 totalShares = totalSupply();\n        uint256 capital = zchf.equity();\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\n        uint256 newTotalShares = totalShares - shares;\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(newTotalShares, totalShares)));\n        return capital - newCapital;\n    }\n\n}"
    },
    "contracts/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied and adjusted from OpenZeppelin\n// Adjustments:\n// - modifications to support ERC-677\n// - removed require messages to save space\n// - removed unnecessary require statements\n// - removed GSN Context\n// - upgraded to 0.8 to drop SafeMath\n// - let name() and symbol() be implemented by subclass\n// - infinite allowance support, with 2^255 and above considered infinite\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IERC677Receiver.sol\";\n\n/**\n * @dev Implementation of the `IERC20` interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using `_mint`.\n * For a generic mechanism see `ERC20Mintable`.\n *\n * *For a detailed writeup see our guide [How to implement supply\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard `decreaseAllowance` and `increaseAllowance`\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See `IERC20.approve`.\n */\n\nabstract contract ERC20 is IERC20 {\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    uint8 public immutable override decimals;\n\n    constructor(uint8 _decimals) {\n        decimals = _decimals;\n    }\n\n    /**\n     * @dev See `IERC20.totalSupply`.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See `IERC20.balanceOf`.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See `IERC20.transfer`.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.allowance`.\n     */\n    function allowance(address owner, address spender) external view override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See `IERC20.approve`.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) external override returns (bool) {\n        _approve(msg.sender, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See `IERC20.transferFrom`.\n     *\n     * Emits an `Approval` event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of `ERC20`;\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `value`.\n     * - the caller must have allowance for `sender`'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\n        _transfer(sender, recipient, amount);\n        uint256 currentAllowance = _allowances[sender][msg.sender];\n        if (currentAllowance < (1 << 255)){\n            // Only decrease the allowance if it was not set to 'infinite'\n            // Documented in /doc/infiniteallowance.md\n            require(currentAllowance >= amount, \"approval not enough\");\n            _approve(sender, msg.sender, currentAllowance - amount);\n        }\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to `transfer`, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a `Transfer` event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n        \n        _beforeTokenTransfer(sender, recipient, amount);\n        require(_balances[sender]>=amount, \"balance not enough\");\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n\n    // ERC-677 functionality, can be useful for swapping and wrapping tokens\n    function transferAndCall(address recipient, uint256 amount, bytes calldata data) external override returns (bool) {\n        bool success = transfer(recipient, amount);\n        if (success){\n            success = IERC677Receiver(recipient).onTokenTransfer(msg.sender, amount, data);\n        }\n        return success;\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a `Transfer` event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address recipient, uint256 amount) internal virtual {\n        require(recipient != address(0));\n\n        _beforeTokenTransfer(address(0), recipient, amount);\n\n        _totalSupply += amount;\n        _balances[recipient] += amount;\n        emit Transfer(address(0), recipient, amount);\n    }\n\n     /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a `Transfer` event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _totalSupply -= amount;\n        _balances[account] -= amount;\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an `Approval` event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _allowances[owner][spender] = value;\n        emit Approval(owner, spender, value);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) virtual internal {\n    }\n}"
    },
    "contracts/ERC20PermitLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\n// and modified it.\n\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\n\nabstract contract ERC20PermitLight is ERC20 {\n   \n   /*//////////////////////////////////////////////////////////////\n                            EIP-2612 STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(address => uint256) public nonces;\n\n  /*//////////////////////////////////////////////////////////////\n                             EIP-2612 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\n\n        unchecked { // unchecked to save a little gas with the nonce increment...\n            address recoveredAddress = ecrecover(\n                keccak256(\n                    abi.encodePacked(\n                        \"\\x19\\x01\",\n                        DOMAIN_SEPARATOR(),\n                        keccak256(\n                            abi.encode(\n                                // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\n                                bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9),\n                                owner,\n                                spender,\n                                value,\n                                nonces[owner]++,\n                                deadline\n                            )\n                        )\n                    )\n                ),\n                v,\n                r,\n                s\n            );\n\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\n            _approve(recoveredAddress, spender, value);\n        }\n    }\n\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\n        return\n            keccak256(\n                abi.encode(\n                    //keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\n                    bytes32(0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218),\n                    block.chainid,\n                    address(this)\n                )\n            );\n    }\n\n}"
    },
    "contracts/Frankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./ERC20PermitLight.sol\";\nimport \"./Equity.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\n\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\n\n   uint256 public constant MIN_FEE = 1000 * (10**18);\n   uint256 public immutable MIN_APPLICATION_PERIOD; //10 days;\n\n   IReserve override public immutable reserve;\n   uint256 private minterReserveE6;\n\n   mapping (address => uint256) public minters;\n   mapping (address => address) public positions;\n\n   event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\n   event MinterDenied(address indexed minter, string message);\n\n   constructor(uint256 _minApplicationPeriod) ERC20(18){\n      MIN_APPLICATION_PERIOD = _minApplicationPeriod;\n      reserve = new Equity(this);\n   }\n\n   function name() override external pure returns (string memory){\n      return \"Frankencoin V1\";\n   }\n\n   function symbol() override external pure returns (string memory){\n      return \"ZCHF\";\n   }\n\n   /**\n    * @notice Minting is suggested either by (1) person applying for a new original position,\n    * or (2) by the minting hub when cloning a position. The minting hub has the priviledge\n    * to call with zero application fee and period.\n    * @param _minter             address of the position want to add to the minters\n    * @param _applicationPeriod  application period in seconds\n    * @param _applicationFee     application fee in parts per million\n    * @param _message            message string\n    */\n   function suggestMinter(address _minter, uint256 _applicationPeriod, \n      uint256 _applicationFee, string calldata _message) override external \n   {\n      require(_applicationPeriod >= MIN_APPLICATION_PERIOD || totalSupply() == 0, \"period too short\");\n      require(_applicationFee >= MIN_FEE || totalSupply() == 0, \"fee too low\");\n      require(minters[_minter] == 0, \"already registered\");\n      _transfer(msg.sender, address(reserve), _applicationFee);\n      minters[_minter] = block.timestamp + _applicationPeriod;\n      emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\n   }\n\n   function minterReserve() public view returns (uint256) {\n      return minterReserveE6 / 1000000;\n   }\n\n   function registerPosition(address _position) override external {\n      require(isMinter(msg.sender), \"not minter\");\n      positions[_position] = msg.sender;\n   }\n\n   /**\n    * @notice Get reserve balance (amount of ZCHF)\n    * @return ZCHF in dec18 format\n    */\n   function equity() public view returns (uint256) {\n      uint256 balance = balanceOf(address(reserve));\n      uint256 minReserve = minterReserve();\n      if (balance <= minReserve){\n        return 0;\n      } else {\n        return balance - minReserve;\n      }\n    }\n\n   function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) override external {\n      require(block.timestamp <= minters[_minter], \"too late\");\n      require(reserve.isQualified(msg.sender, _helpers), \"not qualified\");\n      delete minters[_minter];\n      emit MinterDenied(_minter, _message);\n   }\n\n   /**\n * @notice Mint amount of ZCHF for address _target\n * @param _target       address that receives ZCHF if it's a minter\n * @param _amount       amount ZCHF before fees and pool contribution requested\n *                      number in dec18 format\n * @param _reservePPM   reserve requirement in parts per million\n * @param _feesPPM      fees in parts per million\n */\n   function mint(address _target, uint256 _amount, uint32 _reservePPM, uint32 _feesPPM) \n      override external minterOnly \n   {\n      uint256 _minterReserveE6 = _amount * _reservePPM;\n      uint256 reserveMint = (_minterReserveE6 + 999_999) / 1000_000; // make sure rounded up\n      uint256 fees = (_amount * _feesPPM + 999_999) / 1000_000; // make sure rounded up\n      _mint(_target, _amount - reserveMint - fees);\n      _mint(address(reserve), reserveMint + fees);\n      minterReserveE6 += reserveMint * 1000_000;\n   }\n\n   /**\n    * @notice Mint amount of ZCHF for address _target\n    * @param _target   address that receives ZCHF if it's a minter\n    * @param _amount   amount in dec18 format\n    */\n   function mint(address _target, uint256 _amount) override external minterOnly {\n      _mint(_target, _amount);\n   }\n\n   function burn(uint256 _amount) external {\n      _burn(msg.sender, _amount);\n   }\n\n   function burn(uint256 amount, uint32 reservePPM) external override minterOnly {\n      _burn(msg.sender, amount);\n      minterReserveE6 -= amount * reservePPM;\n   }\n\n   function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\n      uint256 theoreticalReserve = _reservePPM * mintedAmount / 1000000;\n      uint256 currentReserve = balanceOf(address(reserve));\n      if (currentReserve < minterReserve()){\n         // not enough reserves, owner has to take a loss\n         return theoreticalReserve * currentReserve / minterReserve();\n      } else {\n         return theoreticalReserve;\n      }\n   }\n\n   function burnFrom(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external override minterOnly returns (uint256) {\n      uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, _reservePPM);\n      _transfer(address(reserve), payer, assigned); \n      _burn(payer, targetTotalBurnAmount); // and burn everything\n      minterReserveE6 -= targetTotalBurnAmount * _reservePPM; // reduce reserve requirements by original ratio\n      return assigned;\n   }\n\n   function burnWithReserve(uint256 _amountExcludingReserve /* 41 */, uint32 _reservePPM /* 20% */) \n      external override minterOnly returns (uint256) \n   {\n      uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\n      uint256 minterReserve_ = minterReserve(); // 20\n      uint256 adjustedReservePPM = currentReserve < minterReserve_ ? _reservePPM * currentReserve / minterReserve_ : _reservePPM; // 18%\n      uint256 freedAmount = _amountExcludingReserve / (1000000 - adjustedReservePPM); // 0.18 * 41 /0.82 = 50\n      minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio, here 10\n      _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect 9 assigned reserve, maybe less than original reserve\n      _burn(msg.sender, freedAmount); // 41\n      return freedAmount;\n   }\n\n   function burn(address _owner, uint256 _amount) override external minterOnly {\n      _burn(_owner, _amount);\n   }\n\n   modifier minterOnly() {\n      require(isMinter(msg.sender) || isMinter(positions[msg.sender]), \"not approved minter\");\n      _;\n   }\n\n   function notifyLoss(uint256 _amount) override external minterOnly {\n      uint256 reserveLeft = balanceOf(address(reserve));\n      if (reserveLeft >= _amount){\n         _transfer(address(reserve), msg.sender, _amount);\n      } else {\n         _transfer(address(reserve), msg.sender, reserveLeft);\n         _mint(msg.sender, _amount - reserveLeft);\n      }\n   }\n   function isMinter(address _minter) override public view returns (bool){\n      return minters[_minter]!=0 && block.timestamp >= minters[_minter];\n   }\n\n   function isPosition(address _position) override public view returns (address){\n      return positions[_position];\n   }\n\n}\n\n"
    },
    "contracts/IERC20.sol": {
      "content": "/**\n* SPDX-License-Identifier: MIT\n*\n* Copyright (c) 2016-2019 zOS Global Limited\n*\n*/\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    // Optional functions\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferAndCall(address recipient, uint256 amount, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "contracts/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677Receiver {\n    \n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}"
    },
    "contracts/IFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\n\ninterface IFrankencoin is IERC20 {\n\n    function suggestMinter(address _minter, uint256 _applicationPeriod, \n      uint256 _applicationFee, string calldata _message) external;\n\n    function registerPosition(address position) external;\n\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\n\n    function reserve() external view returns (IReserve);\n\n    function isMinter(address minter) external view returns (bool);\n\n    function isPosition(address position) external view returns (address);\n    \n    function mint(address target, uint256 amount) external;\n\n    function mint(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\n\n    function burn(uint256 amountIncludingReserve, uint32 reservePPM) external;\n\n    function burnFrom(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external returns (uint256);\n\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\n\n    function burn(address target, uint256 amount) external;\n\n    function notifyLoss(uint256 amount) external;\n\n}"
    },
    "contracts/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\n\ninterface IPosition {\n\n    function collateral() external returns (IERC20);\n\n    function minimumCollateral() external returns (uint256);\n\n    function challengePeriod() external returns (uint256);\n\n    function price() external returns (uint256);\n\n    function reduceLimitForClone(uint256 amount) external returns (uint256);\n\n    function initializeClone(address owner, uint256 _price, uint256 _limit, uint256 _coll, uint256 _mint) external;\n\n    function deny(address[] calldata helpers, string calldata message) external;\n\n    function notifyChallengeStarted(uint256 size) external;\n\n    function tryAvertChallenge(uint256 size, uint256 bid) external returns (bool);\n\n    function notifyChallengeSucceeded(address bidder, uint256 bid, uint256 size) external returns (address, uint256, uint256, uint256, uint32);\n\n}"
    },
    "contracts/IReserve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IReserve {\n   function isQualified(address sender, address[] calldata helpers) external view returns (bool);\n}"
    },
    "contracts/MathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\n/** \n * @title Functions for share valuation\n */\ncontract MathUtil {\n\n    uint256 internal constant ONE_DEC18 = 10**18;\n    uint256 internal constant THRESH_DEC18 =  10000000000000000;//0.01\n    /**\n     * @notice Cubic root with Halley approximation\n     *         Number 1e18 decimal\n     * @param _v     number for which we calculate x**(1/3)\n     * @return returns _v**(1/3)\n     */\n    function _cubicRoot(uint256 _v) internal pure returns (uint256) {\n        uint256 x = ONE_DEC18;\n        uint256 xOld;\n        bool cond;\n        do {\n            xOld = x;\n            uint256 powX3 = _mulD18(_mulD18(x, x), x);\n            x = _mulD18(x, _divD18( (powX3 + 2 * _v) , (2 * powX3 + _v)));\n            cond = xOld > x ? xOld - x > THRESH_DEC18 : x - xOld > THRESH_DEC18;\n        } while ( cond );\n        return x;\n    }\n\n    function _mulD18(uint256 _a, uint256 _b) internal pure returns(uint256) {\n        return _a * _b / ONE_DEC18;\n    }\n\n    function _divD18(uint256 _a, uint256 _b) internal pure returns(uint256) {\n        return (_a * ONE_DEC18) / _b ;\n    }\n\n    function _power3(uint256 _x) internal pure returns(uint256) {\n        return _mulD18(_mulD18(_x, _x), _x);\n    }\n\n}"
    },
    "contracts/MintingHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./IPosition.sol\";\n\n/**\n * A hub for creating collateralized minting positions for a given collateral.\n */\ncontract MintingHub {\n    uint256 public constant OPENING_FEE = 1000 * 10**18;\n\n    uint32 public constant BASE = 1000_000;\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\n\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\n\n    IFrankencoin public immutable zchf; // currency\n    Challenge[] public challenges;\n\n    struct Challenge {\n        address challenger;\n        IPosition position;\n        uint256 size;\n        uint256 end;\n        address bidder;\n        uint256 bid;\n    }\n\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\n    event ChallengeAverted(address indexed position, uint256 number);\n    event ChallengeSucceeded(address indexed position, uint256 bid, uint256 number);\n    event NewBid(uint256 challengedId, uint256 bidAmount, address bidder);\n\n    constructor(address _zchf, address factory) {\n        zchf = IFrankencoin(_zchf);\n        POSITION_FACTORY = IPositionFactory(factory);\n    }\n\n    /**\n     * @notice open a collateralized loan position\n     * @param _collateralAddress        address of collateral token\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\n     * @param _initialCollateral amount of initial collateral to be deposited\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\n     * @param _mintingFeePPM     percentage minting fee that will be added to reserve,\n     *                           basis 1000_000\n     * @param _liqPriceE18       Liquidation price (dec18) that together with the reserve and\n     *                           fees determines the minimal collateralization ratio\n     * @param _reservePPM        percentage reserve amount that is added as the\n     *                           borrower's stake into reserve, basis 1000_000\n     * @return address of resulting position\n     */\n    function openPosition(\n        address _collateralAddress, uint256 _minCollateral, uint256 _initialCollateral,\n        uint256 _mintingMaximum, uint256 _expirationSeconds, uint256 _challengeSeconds,\n        uint32 _mintingFeePPM, uint256 _liqPriceE18, uint32 _reservePPM) public returns (address) {\n        IPosition pos = IPosition(\n            POSITION_FACTORY.createNewPosition(\n                msg.sender,\n                address(zchf),\n                _collateralAddress,\n                _minCollateral,\n                _initialCollateral,\n                _mintingMaximum,\n                _expirationSeconds,\n                _challengeSeconds,\n                _mintingFeePPM,\n                _liqPriceE18,\n                _reservePPM\n            )\n        );\n        zchf.registerPosition(address(pos));\n        zchf.transferFrom(msg.sender, address(zchf.reserve()), OPENING_FEE);\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\n\n        return address(pos);\n    }\n\n    function clonePosition(address position, uint256 _initialCollateral, uint256 _initialMint) public returns (address) {\n        require(zchf.isPosition(position) == address(this), \"not our pos\");\n        IPosition existing = IPosition(position);\n        uint256 limit = existing.reduceLimitForClone(_initialMint);\n        address pos = POSITION_FACTORY.clonePosition(position);\n        zchf.registerPosition(pos);\n        existing.collateral().transferFrom(msg.sender, address(pos), _initialCollateral);\n        IPosition(pos).initializeClone(msg.sender, existing.price(), limit, _initialCollateral, _initialMint);\n        return address(pos);\n    }\n\n    function reserve() external view returns (IReserve) {\n        return IReserve(zchf.reserve());\n    }\n\n    /**\n     * @notice Launch a challenge on a position\n     * @param _positionAddr      address of the position we want to challenge\n     * @param _collateralAmount  size of the collateral we want to challenge (dec 18)\n     * @return index of the challenge in challenge-array\n     */\n    function launchChallenge(address _positionAddr, uint256 _collateralAmount) external returns (uint256) {\n        IPosition position = IPosition(_positionAddr);\n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\n        uint256 pos = challenges.length;\n        /*\n        struct Challenge {address challenger;IPosition position;uint256 size;uint256 end;address bidder;uint256 bid;\n        */\n        challenges.push(Challenge(msg.sender, position, _collateralAmount, block.timestamp + position.challengePeriod(), address(0x0), 0));\n        position.notifyChallengeStarted(_collateralAmount);\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\n        return pos;\n    }\n\n    function splitChallenge(uint256 _challengeNumber, uint256 splitOffAmount) external returns (uint256) {\n        Challenge storage challenge = challenges[_challengeNumber];\n        require(challenge.challenger != address(0x0));\n        Challenge memory copy = Challenge(\n            challenge.challenger,\n            challenge.position,\n            splitOffAmount,\n            challenge.end,\n            challenge.bidder,\n            (challenge.bid * splitOffAmount) / challenge.size\n        );\n        challenge.bid -= copy.bid;\n        challenge.size -= copy.size;\n\n        uint256 min = IPosition(challenge.position).minimumCollateral();\n        require(challenge.size >= min);\n        require(copy.size >= min);\n\n        uint256 pos = challenges.length;\n        challenges.push(copy);\n        emit ChallengeStarted(challenge.challenger, address(challenge.position), challenge.size, _challengeNumber);\n        emit ChallengeStarted(copy.challenger, address(copy.position), copy.size, pos);\n        return pos;\n    }\n\n    function minBid(uint256 challenge) public view returns (uint256) {\n        return minBid(challenges[challenge]);\n    }\n\n    function minBid(Challenge storage challenge) internal view returns (uint256) {\n        return (challenge.bid * 1005) / 1000; // should be at least 0.5% higher\n    }\n\n    /**\n     * @notice Post a bid (ZCHF amount) for an existing challenge (given collateral amount)\n     * @param _challengeNumber   index of the challenge in the challenges array\n     * @param _bidAmountZCHF     how much to bid for the collateral of this challenge (dec 18)\n     */\n    function bid(uint256 _challengeNumber, uint256 _bidAmountZCHF, uint256 expectedSize) external {\n        Challenge storage challenge = challenges[_challengeNumber];\n        if (block.timestamp >= challenge.end) {\n            // if bid is too late, the transaction ends the challenge\n            _end(_challengeNumber);\n        } else {\n            require(expectedSize == challenge.size, \"s\");\n            if (challenge.bid > 0) {\n                zchf.transfer(challenge.bidder, challenge.bid); // return old bid\n            }\n            emit NewBid(_challengeNumber, _bidAmountZCHF, msg.sender);\n            if (challenge.position.tryAvertChallenge(challenge.size, _bidAmountZCHF)) {\n                // bid above Z_B/C_C >= (1+h)Z_M/C_M, challenge averted, end immediately by selling challenger collateral to bidder\n                zchf.transferFrom(msg.sender, challenge.challenger, _bidAmountZCHF);\n                IERC20(challenge.position.collateral()).transfer(msg.sender, challenge.size);\n                emit ChallengeAverted(address(challenge.position), _challengeNumber);\n                delete challenges[_challengeNumber];\n            } else {\n                require(_bidAmountZCHF >= minBid(challenge), \"below min bid\");\n                uint256 earliestEnd = block.timestamp + 30 minutes;\n                if (earliestEnd >= challenge.end) {\n                    // bump remaining time to 10 minutes if we are near the end of the challenge\n                    challenge.end = earliestEnd;\n                }\n                require(challenge.size * challenge.position.price() > _bidAmountZCHF * 10**18, \"whot\");\n                zchf.transferFrom(msg.sender, address(this), _bidAmountZCHF);\n                challenge.bid = _bidAmountZCHF;\n                challenge.bidder = msg.sender;\n            }\n        }\n    }\n\n    /**\n     * @notice\n     * Ends a challenge successfully after the auction period ended.\n     *\n     * Example: A challenged position had 1000 ABC tokens as collateral with a minting limit of 200,000 ZCHF, out\n     * of which 60,000 have been minted and thereof 15,000 used to buy reserve tokens. The challenger auctioned off\n     * 400 ABC tokens, challenging 40% of the position. The highest bid was 75,000 ZCHF, below the\n     * 40% * 200,000 = 80,000 ZCHF needed to avert the challenge. The reserve ratio of the position is 25%.\n     *\n     * Now, the following happens when calling this method:\n     * - 400 ABC from the position owner are transferred to the bidder\n     * - The challenger's 400 ABC are returned to the challenger\n     * - 40% of the reserve bought with the 15,000 ZCHF is sold off (approximately), yielding e.g. 5,600 ZCHF\n     * - 40% * 60,000 = 24,000 ZCHF are burned\n     * - 80,000 * 2% = 1600 ZCHF are given to the challenger as a reward\n     * - 40% * (100%-25%) * (200,000 - 60,000) = 42,000 are given to the position owner for selling off unused collateral\n     * - The remaining 75,000 + 5,600 - 1,600 - 24,000 - 42,000 = 13,000 ZCHF are sent to the reserve pool\n     *\n     * If the highest bid was only 60,000 ZCHF, then we would have had a shortfall of 2,000 ZCHF that would in the\n     * first priority be covered by the reserve and in the second priority by minting unbacked ZCHF, triggering a\n     * balance alert.\n     * @param _challengeNumber  number of the challenge in challenge-array\n     */\n    function end(uint256 _challengeNumber) external {\n        _end(_challengeNumber);\n    }\n\n    function isChallengeOpen(uint256 _challengeNumber) external view returns (bool) {\n        return challenges[_challengeNumber].end > block.timestamp;\n    }\n\n    /**\n     * @dev internal end function\n     * @param _challengeNumber  number of the challenge in challenge-array\n     */\n    function _end(uint256 _challengeNumber) internal {\n        Challenge storage challenge = challenges[_challengeNumber];\n        IERC20 collateral = challenge.position.collateral();\n        require(block.timestamp >= challenge.end, \"period has not ended\");\n        // challenge must have been successful, because otherwise it would have immediately ended on placing the winning bid\n        collateral.transfer(challenge.challenger, challenge.size); // return the challenger's collateral\n        // notify the position that will send the collateral to the bidder. If there is no bid, send the collateral to msg.sender\n        address recipient = challenge.bidder == address(0x0) ? msg.sender : challenge.bidder;\n        (address owner, uint256 effectiveBid, uint256 volume, uint256 repayment, uint32 reservePPM) = challenge.position.notifyChallengeSucceeded(recipient, challenge.bid, challenge.size);\n        if (effectiveBid < challenge.bid) {\n            // overbid, return excess amount\n            IERC20(zchf).transfer(challenge.bidder, challenge.bid - effectiveBid);\n        }\n        uint256 reward = (volume * CHALLENGER_REWARD) / BASE;\n        uint256 fundsNeeded = reward + repayment;\n        if (effectiveBid > fundsNeeded){\n            zchf.transfer(owner, effectiveBid - fundsNeeded);\n        } else if (effectiveBid < fundsNeeded){\n            zchf.notifyLoss(fundsNeeded - effectiveBid); // ensure we have enough to pay everything\n        }\n        zchf.transfer(challenge.challenger, reward); // pay out the challenger reward\n        zchf.burn(repayment, reservePPM); // Repay the challenged part\n        emit ChallengeSucceeded(address(challenge.position), challenge.bid, _challengeNumber);\n        delete challenges[_challengeNumber];\n    }\n}\n\ninterface IPositionFactory {\n    function createNewPosition(\n        address _owner,\n        address _zchf,\n        address _collateral,\n        uint256 _minCollateral,\n        uint256 _initialCollateral,\n        uint256 _initialLimit,\n        uint256 _duration,\n        uint256 _challengePeriod,\n        uint32 _mintingFeePPM,\n        uint256 _liqPrice,\n        uint32 _reserve\n    ) external returns (address);\n\n    function clonePosition(address _existing) external returns (address);\n}\n"
    },
    "contracts/mocks/MockMintingHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../MintingHub.sol\";\n\n// this minting hub stores the address of\n// the last position created. Otherwise cumbersome to\n// access through hardhat/ethers\ncontract MockMintingHub is MintingHub {\n\n    address public lastPositionAddress;\n    constructor(address _zchf, address _factory) MintingHub (_zchf, _factory){}\n\n    function openPositionMock(address _collateral, uint256 _minCollateral, \n        uint256 _initialCollateral, uint256 _initialLimit, \n        uint256 _duration, uint256 _challengePeriod, uint32 _fees, uint256 _liqPrice, uint32 _reserve) \n        public returns (address) \n    {\n        lastPositionAddress = openPosition(_collateral, _minCollateral,_initialCollateral,\n            _initialLimit, _duration, _challengePeriod, _fees, _liqPrice, _reserve);\n        return lastPositionAddress;\n    }\n\n    function clonePositionMock(address position, uint256 _initialCollateral, \n        uint256 _initialMint) public returns (address)\n    {\n        lastPositionAddress = clonePosition(position, _initialCollateral, \n            _initialMint);\n        return lastPositionAddress;\n    }\n\n}"
    },
    "contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n// - Extracted interface\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address initialOwner) {\n        require(initialOwner != address(0), \"0x0\");\n        owner = initialOwner;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) virtual public onlyOwner {\n        require(newOwner != address(0), \"0x0\");\n        owner = newOwner;\n        emit OwnershipTransferred(owner, newOwner);\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender || owner == address(0x0), \"not owner\");\n        _;\n    }\n}"
    },
    "contracts/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IPosition.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./IERC677Receiver.sol\";\nimport \"./MathUtil.sol\";\n\n/**\n * A collateralized minting position.\n */\ncontract Position is Ownable, IERC677Receiver, IPosition, MathUtil {\n\n    uint256 public constant INITIALIZATION_PERIOD = 7 days;\n    uint256 public constant PRICE_ADJUSTMENT_COOLDOWN = 3 days;\n\n    uint256 public price; // the zchf price per unit of the collateral below which challenges succeed, 18 digits\n    uint256 public minted; // how much has been minted so far, including reserve\n    uint256 public challengedAmount; // amount of the collateral that is currently under a challenge\n    uint256 public immutable challengePeriod; //challenge period in timestamp units (seconds) for liquidation\n\n    uint256 public cooldown;\n    uint256 public limit; // how many zchf can be minted at most, including reserve\n    uint256 public immutable expiration;\n\n    address public immutable original; // originals point to themselves, clone to their origin\n    address public immutable hub;\n    IFrankencoin public immutable zchf; // currency\n    IERC20 public override immutable collateral; // collateral\n    uint256 public override immutable minimumCollateral; // prevent dust amounts\n\n    uint32 public immutable mintingFeePPM;\n    uint32 public immutable reserveContribution; // in ppm\n\n    event PositionDenied(address indexed sender, string message);\n    event MintingUpdate(uint256 collateral, uint256 price, uint256 minted, uint256 limit);\n    event PositionOpened(address indexed owner, address original, address zchf, address collateral, uint256 price);\n\n    /**\n    * @param _owner             position owner address\n    * @param _hub               address of minting hub\n    * @param _zchf              ZCHF address\n    * @param _collateral        collateral address\n    * @param _minCollateral     minimum collateral required to prevent dust amounts\n    * @param _initialCollateral amount of initial collateral to be deposited\n    * @param _initialLimit      maximal amount of ZCHF that can be minted by the position owner (includes reserve)\n    * @param _duration          position tenor in unit of timestamp (seconds) from 'now'\n    * @param _challengePeriod   challenge period. Longer for less liquid collateral.\n    * @param _mintingFeePPM     fee to enter position in parts per million of ZCHF amount\n    * @param _liqPrice          Liquidation price (dec18) that together with the reserve and\n    *                           fees determines the minimal collateralization ratio\n    * @param _reservePPM        ZCHF pool reserve requirement in parts per million of ZCHF amount\n    */\n    constructor(address _owner, address _hub, address _zchf, address _collateral, \n        uint256 _minCollateral, uint256 _initialCollateral, \n        uint256 _initialLimit, uint256 _duration, uint256 _challengePeriod, uint32 _mintingFeePPM, \n        uint256 _liqPrice, uint32 _reservePPM) Ownable(_owner) {\n        original = address(this);\n        hub = _hub;\n        price = _liqPrice;\n        zchf = IFrankencoin(_zchf);\n        collateral = IERC20(_collateral);\n        mintingFeePPM = _mintingFeePPM;\n        reserveContribution = _reservePPM;\n        require(_initialCollateral >= _minCollateral);\n        minimumCollateral = _minCollateral;\n        expiration = block.timestamp + _duration;\n        challengePeriod = _challengePeriod;\n        restrictMinting(INITIALIZATION_PERIOD);\n        limit = _initialLimit;\n        \n        emit PositionOpened(_owner, original, _zchf, address(collateral), _liqPrice);\n    }\n\n    function initializeClone(address owner, uint256 _price, uint256 _limit, uint256 _coll, uint256 _mint) external onlyHub {\n        require(_coll >= minimumCollateral, \"coll not enough\");\n        transferOwnership(owner);\n        \n        price = _mint * ONE_DEC18 / _coll;\n        require(price <= _price, \"can only reduce price on clone\");\n        limit = _limit;\n        mintInternal(owner, _mint, _coll);\n\n        emit PositionOpened(owner, original, address(zchf), address(collateral), _price);\n    }\n\n    /**\n     * @notice adjust this position's limit to give away some limit to the clone\n     *         invariant: global limit stays constant\n     * @param _minimum  amount that clone wants to mint initially\n     * @return limit for the clone\n     */\n    function reduceLimitForClone(uint256 _minimum) external noMintRestriction onlyHub returns (uint256) {\n        require(minted + _minimum <= limit, \"limit exceeded\");\n        uint256 reduction = (limit - minted - _minimum)/2;\n        limit -= reduction + _minimum;\n        return reduction + _minimum;\n    }\n\n    function deny(address[] calldata helpers, string calldata message) public {\n        require(minted == 0, \"minted\"); // must deny before any tokens are minted\n        require(IReserve(zchf.reserve()).isQualified(msg.sender, helpers), \"not qualified\");\n        cooldown = expiration;\n        emit PositionDenied(msg.sender, message);\n    }\n\n    /**\n     * This is how much the minter can actually use when minting ZCHF, with the rest being used\n     * to buy reserve pool shares.\n     */\n    function getUsableMint(uint256 totalMint, bool beforeFees) public view returns (uint256){\n        uint256 usable = totalMint * (1000_000 - reserveContribution) / 1000_000;\n        if (beforeFees){\n            return usable;\n        } else {\n            return totalMint * (1000_000 - mintingFeePPM) / 1000_000;\n        }\n    }\n\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) public {\n        if (newPrice != price){\n            adjustPrice(newPrice);\n        }\n        uint256 colbal = collateralBalance();\n        if (newCollateral > colbal){\n            collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\n        }\n        if (newMinted < minted){\n            zchf.burnFrom(msg.sender, minted - newMinted, reserveContribution);\n            minted = newMinted;\n        }\n        if (newCollateral < colbal){\n            withdrawCollateral(msg.sender, colbal - newCollateral);\n        }\n        if (newMinted > minted){\n            mint(msg.sender, newMinted - minted);\n        }\n    }\n\n    function adjustPrice(uint256 newPrice) public onlyOwner noChallenge {\n        if (newPrice > price) {\n            restrictMinting(PRICE_ADJUSTMENT_COOLDOWN);\n        } else {\n            require(isWellCollateralized(collateralBalance(), newPrice));\n        }\n        price = newPrice;\n        emitUpdate();\n    }\n\n    function collateralBalance() internal view returns (uint256){\n        return IERC20(collateral).balanceOf(address(this));\n    }\n\n    function mint(address target, uint256 amount) public onlyOwner noChallenge noMintRestriction {\n        mintInternal(target, amount, collateralBalance());\n    }\n\n    function mintInternal(address target, uint256 amount, uint256 collateral_) internal {\n        require(minted + amount <= limit, \"limit exceeded\");\n        zchf.mint(target, amount, reserveContribution, mintingFeePPM);\n        minted += amount;\n\n        require(isWellCollateralized(collateral_, price), \"not well collateralized\");\n        emitUpdate();\n    }\n\n    function restrictMinting(uint256 period) internal {\n        uint256 horizon = block.timestamp + period;\n        if (horizon > cooldown){\n            cooldown = horizon;\n        }\n    }\n    \n    function onTokenTransfer(address, uint256 amount, bytes calldata) override external returns (bool) {\n        if (msg.sender == address(zchf)){\n            repayInternal(amount);\n        } else {\n            require(false);\n        }\n        return true;\n    }\n\n    function repay(uint256 amount) public onlyOwner {\n        IERC20(zchf).transferFrom(msg.sender, address(this), amount);\n        repayInternal(amount);\n    }\n\n    function repayInternal(uint256 burnable) internal noChallenge {\n        uint256 actuallyBurned = IFrankencoin(zchf).burnWithReserve(burnable, reserveContribution);\n        notifyRepaidInternal(actuallyBurned);\n    }\n\n    function notifyRepaidInternal(uint256 amount) internal {\n        require(amount <= minted);\n        minted -= amount;\n        emitUpdate();\n    }\n\n    /**\n     * Withdraw any token that might have ended up on this address, except for collateral\n     * and reserve tokens, which also serve as a collateral.\n     */\n    function withdraw(address token, address target, uint256 amount) external onlyOwner {\n        if (token == address(collateral)){\n            withdrawCollateral(target, amount);\n        } else {\n            IERC20(token).transfer(target, amount);\n        }\n    }\n\n    function withdrawCollateral(address target, uint256 amount) public onlyOwner noChallenge {\n        IERC20(collateral).transfer(target, amount);\n        uint256 balance = collateralBalance();\n        require(isWellCollateralized(balance, price));\n        if (balance == 0){\n            // Close\n            cooldown = expiration;\n        } else {\n            require(balance >= minimumCollateral);\n        }\n        emitUpdate();\n    }\n\n    function isWellCollateralized(uint256 collateralReserve, uint256 atPrice) internal view returns (bool) {\n        return collateralReserve * atPrice >= minted * ONE_DEC18;\n    }\n\n    function emitUpdate() internal {\n        emit MintingUpdate(collateralBalance(), price, minted, limit);\n    }\n\n    function notifyChallengeStarted(uint256 size) external onlyHub {\n        uint256 colbal = collateralBalance();\n        // require minimum size, note that collateral balance can be below minimum if it was partially challenged before\n        require(size >= minimumCollateral || size == colbal, \"challenge too small\");\n        require(size <= colbal, \"challenge too large\");\n        challengedAmount += size;\n    }\n\n    /**\n     * @notice check whether challenge can be averted\n     * @param _collateralAmount   amount of collateral challenged (dec18)\n     * @param _bidAmountZCHF      bid amount in ZCHF (dec18)\n     * @return true if challenge can be averted\n     */\n    function tryAvertChallenge(uint256 _collateralAmount, uint256 _bidAmountZCHF) external onlyHub returns (bool) {\n        if (block.timestamp >= expiration){\n            return false; // position expired, let every challenge succeed\n        } else if (_bidAmountZCHF * ONE_DEC18 >= price * _collateralAmount){\n            // challenge averted, bid is high enough\n            challengedAmount -= _collateralAmount;\n            // don't allow minter to close the position immediately so challenge can be repeated\n            restrictMinting(1 days);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Notifies the position that a challenge was successful.\n     * Triggers the payout of the challenged part of the collateral.\n     * Returns three important numbers:\n     *  - repay: the amount that is needed to repay for the actually minted zchf wit the challenged collateral\n     *  - minted: the number of zchf that where actually minted and used using the challenged collateral\n     *  - mintmax: the maximum number of zchf that could have been minted and used using the challenged collateral \n     * @param _bidder   address of the bidder that receives the collateral\n     * @param _bid      bid amount in ZCHF (dec18)\n     * @param _size     size of the collateral bid for (dec 18)\n     * @return adjusted bid size, repaied xchf, reserve contribution ppm\n     */\n    function notifyChallengeSucceeded(address _bidder, uint256 _bid, uint256 _size) \n        external onlyHub returns (address, uint256, uint256, uint256, uint32) {\n        challengedAmount -= _size;\n        uint256 colBal = collateralBalance();\n        uint256 volumeZCHF = _mulD18(price, _size);\n        uint256 mintable = _mulD18(price, colBal);\n        if (volumeZCHF > mintable){\n            _bid = _divD18(_mulD18(_bid, mintable), volumeZCHF);\n            volumeZCHF = mintable;\n            _size = colBal;\n        }\n        // transfer collateral to the bidder\n        IERC20(collateral).transfer(_bidder, _size);\n        uint256 repayment = minted >= volumeZCHF ? volumeZCHF : minted;\n        notifyRepaidInternal(repayment); // we assume the caller takes care of the actual repayment\n        return (owner, _bid, volumeZCHF, repayment, reserveContribution);\n    }\n\n    modifier noMintRestriction() {\n       require(cooldown < block.timestamp, \"cooldown\");\n       require(block.timestamp <= expiration, \"expired\");\n        _;\n    }\n\n    modifier noChallenge() {\n        require(challengedAmount == 0, \"challenges pending\");\n        _;\n    }\n\n    modifier onlyHub() {\n        require(msg.sender == address(hub), \"not hub\");\n        _;\n    }\n\n}"
    },
    "contracts/PositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CloneFactory.sol\";\nimport \"./Position.sol\";\nimport \"./IFrankencoin.sol\";\n\ncontract PositionFactory is CloneFactory {\n\n    function createNewPosition(address _owner, address _zchf, address _collateral, \n        uint256 _minCollateral, uint256 _initialCollateral, \n        uint256 _initialLimit, uint256 _duration, uint256 _challengePeriod, \n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reserve) \n        external returns (address) \n    {\n        return address(new Position(_owner, msg.sender, _zchf, _collateral, \n            _minCollateral, _initialCollateral, _initialLimit, _duration, \n            _challengePeriod, _mintingFeePPM, _liqPrice, _reserve));\n    }\n\n    /**\n    * @notice clone an existing position. This can be a clone of another clone,\n    * or an origin position. If it's another clone, then the liquidation price\n    * is taken from the clone and the rest from the origin. Limit is \"inherited\"\n    * (and adjusted) from the origin.\n    * @param _existing     address of the position we want to clone\n    * @return address of the newly created clone position\n    */\n    function clonePosition(address _existing) external returns (address) {\n        Position existing = Position(_existing);\n        Position clone = Position(createClone(existing.original()));\n        return address(clone);\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}