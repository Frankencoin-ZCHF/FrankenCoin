{
  "language": "Solidity",
  "sources": {
    "contracts/PositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./CloneFactory.sol\";\nimport \"./Position.sol\";\nimport \"./IFrankencoin.sol\";\n\ncontract PositionFactory is CloneFactory {\n\n    function createNewPosition(address _owner, address _zchf, address _collateral, \n        uint256 _minCollateral, uint256 _initialCollateral, \n        uint256 _initialLimit, uint256 _duration, uint256 _challengePeriod, \n        uint32 _mintingFeePPM, uint256 _liqPrice, uint32 _reserve) \n        external returns (address) \n    {\n        return address(new Position(_owner, msg.sender, _zchf, _collateral, \n            _minCollateral, _initialCollateral, _initialLimit, _duration, \n            _challengePeriod, _mintingFeePPM, _liqPrice, _reserve));\n    }\n\n    /**\n    * @notice clone an existing position. This can be a clone of another clone,\n    * or an origin position. If it's another clone, then the liquidation price\n    * is taken from the clone and the rest from the origin. Limit is \"inherited\"\n    * (and adjusted) from the origin.\n    * @param _existing     address of the position we want to clone\n    * @param _zchf         ZCHF address\n    * @param _owner        owner address of the new clone\n    * @param _initialCol   initial collateral to be posted by owner (dec 18)\n    * @param _initialMint  initial amount to mint before fees/reserve by owner\n    * @return address of the newly created clone position\n    */\n    function clonePosition(address _existing, address _zchf, address _owner, \n        uint256 _initialCol, uint256 _initialMint) \n        external returns (address) \n    {\n        Position existing = Position(_existing);\n        uint256 limit = existing.reduceLimitForClone(_initialMint);\n        Position clone = Position(createClone(existing.original()));\n        // suggest minter\n        IFrankencoin(_zchf).suggestMinter(address(clone), 0, 0, \"clone\");\n        // initialize and mint\n        clone.initializeClone(_owner, existing.price(), limit, _initialCol, _initialMint);\n        return address(clone);\n    }\n\n}"
    },
    "contracts/CloneFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract CloneFactory {\n\n  function createClone(address target) internal returns (address result) {\n    bytes20 targetBytes = bytes20(target);\n    assembly {\n      let clone := mload(0x40)\n      mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\n      mstore(add(clone, 0x14), targetBytes)\n      mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\n      result := create(0, clone, 0x37)\n    }\n  }\n\n}"
    },
    "contracts/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IPosition.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\nimport \"./Ownable.sol\";\nimport \"./IERC677Receiver.sol\";\nimport \"./MathUtil.sol\";\n\n/**\n * A collateralized minting position.\n */\ncontract Position is Ownable, IERC677Receiver, IPosition, MathUtil {\n\n    uint256 public price; // the zchf price per unit of the collateral below which challenges succeed\n    uint256 public minted; // how much has been minted so far, including reserve\n    uint256 public challengedAmount; // amount of the collateral that is currently under a challenge\n    uint256 public immutable challengePeriod; //challenge period in timestamp units (seconds) for liquidation\n\n    uint256 public cooldown;\n    uint256 public limit; // how many zchf can be minted at most, including reserve\n    uint256 public immutable expiration;\n\n    address public immutable original; // originals point to themselves, clone to their origin\n    address public immutable factory;\n    address public immutable hub;\n    IFrankencoin public immutable zchf; // currency\n    IERC20 public override immutable collateral; // collateral\n    uint256 public immutable minimumCollateral; // prevent dust amounts\n\n    uint32 public immutable mintingFeePPM;\n    uint32 public immutable reserveContribution; // in ppm\n\n    event PositionOpened(address indexed hub, address indexed owner, \n        address collateral, uint256 initialCollateral, uint256 initialLimit, \n        uint256 duration, uint256 challengePeriod, uint32 fees, uint32 reserve, address positionAddr);\n    event PositionDenied(address indexed sender, string message);\n    event MintingUpdate(uint256 collateral, uint256 price, uint256 minted, uint256 limit);\n\n    /**\n    * @param _owner             position owner address\n    * @param _hub               address of minting hub\n    * @param _zchf              ZCHF address\n    * @param _collateral        collateral address\n    * @param _minCollateral     minimum collateral required to prevent dust amounts\n    * @param _initialCollateral amount of initial collateral to be deposited\n    * @param _initialLimit      maximal amount of ZCHF that can be minted by the position owner (includes reserve)\n    * @param _duration          position tenor in unit of timestamp (seconds) from 'now'\n    * @param _challengePeriod   challenge period. Longer for less liquid collateral.\n    * @param _mintingFeePPM     fee to enter position in parts per million of ZCHF amount\n    * @param _liqPrice          Liquidation price (dec18) that together with the reserve and\n    *                           fees determines the minimal collateralization ratio\n    * @param _reservePPM        ZCHF pool reserve requirement in parts per million of ZCHF amount\n    */\n    constructor(address _owner, address _hub, address _zchf, address _collateral, \n        uint256 _minCollateral, uint256 _initialCollateral, \n        uint256 _initialLimit, uint256 _duration, uint256 _challengePeriod, uint32 _mintingFeePPM, \n        uint256 _liqPrice, uint32 _reservePPM) Ownable(_owner) \n    {\n        factory = msg.sender;\n        original = address(this);\n        hub = _hub;\n        price = _liqPrice;\n        zchf = IFrankencoin(_zchf);\n        collateral = IERC20(_collateral);\n        mintingFeePPM = _mintingFeePPM;\n        reserveContribution = _reservePPM;\n        require(_initialCollateral >= _minCollateral);\n        minimumCollateral = _minCollateral;\n        expiration = block.timestamp + _duration;\n        challengePeriod = _challengePeriod;\n        restrictMinting(7 days);\n        limit = _initialLimit;\n        emit PositionOpened(_hub, owner, _collateral, _initialCollateral, \n            _initialLimit, _duration, _challengePeriod, _mintingFeePPM, _reservePPM, address(this));\n    }\n\n    function initializeClone(address owner, uint256 _price, uint256 _limit, uint256 _coll, uint256 _mint) external {\n        require(msg.sender == address(factory), \"factory only\");\n        require(_coll >= minimumCollateral, \"coll not enough\");\n        transferOwnership(owner);\n        \n        price = _price;\n        limit = _limit;\n        mintInternal(owner, _mint, _coll);\n    }\n\n    /**\n     * @notice adjust this position's limit to give away some limit to the clone\n     *         invariant: global limit stays constant\n     * @param _minimum  amount that clone wants to mint initially\n     * @return limit for the clone\n     */\n    function reduceLimitForClone(uint256 _minimum) external noMintRestriction returns (uint256) {\n        require(msg.sender == address(factory), \"only factory\");\n        require(minted + _minimum <= limit, \"limit exceeded\");\n        uint256 reduction = (limit - minted - _minimum)/2;\n        limit -= reduction + _minimum;\n        return reduction + _minimum;\n    }\n\n    function deny(address[] calldata helpers, string calldata message) public {\n        require(minted == 0, \"minted\"); // must deny before any tokens are minted\n        require(IReserve(zchf.reserve()).isQualified(msg.sender, helpers), \"not qualified\");\n        collateral.transfer(owner, collateral.balanceOf(address(this)));\n        zchf.transfer(owner, zchf.balanceOf(address(this)));\n        cooldown = expiration;\n        emit PositionDenied(msg.sender, message);\n    }\n\n    /**\n     * This is how much the minter can actually use when minting ZCHF, with the rest being used\n     * to buy reserve pool shares.\n     */\n    function getUsableMint(uint256 totalMint, bool beforeFees) public view returns (uint256){\n        uint256 usable = totalMint * (1000_000 - reserveContribution) / 1000_000;\n        if (beforeFees){\n            return usable;\n        } else {\n            return totalMint * (1000_000 - mintingFeePPM) / 1000_000;\n        }\n    }\n\n    // TODO Add function to push limit?\n\n    function adjustPrice(uint256 newPrice) public onlyOwner noChallenge {\n        if (newPrice > price) {\n            restrictMinting(3 days);\n        } else {\n            require(isWellCollateralized(collateralBalance(), newPrice));\n        }\n        price = newPrice;\n        emitUpdate();\n    }\n\n    function collateralBalance() internal view returns (uint256){\n        return IERC20(collateral).balanceOf(address(this));\n    }\n\n    function mint(address target, uint256 amount) public onlyOwner noChallenge noMintRestriction {\n        mintInternal(target, amount, collateralBalance());\n    }\n\n    function mintInternal(address target, uint256 amount, uint256 collateral_) internal {\n        require(minted + amount <= limit, \"limit exceeded\");\n        zchf.mint(target, amount, reserveContribution, mintingFeePPM);\n        minted += amount;\n\n        require(isWellCollateralized(collateral_, price), \"not well collateralized\");\n        emitUpdate();\n    }\n\n    function restrictMinting(uint256 period) internal {\n        uint256 horizon = block.timestamp + period;\n        if (horizon > cooldown){\n            cooldown = horizon;\n        }\n    }\n    \n    function onTokenTransfer(address, uint256 amount, bytes calldata) override external returns (bool) {\n        if (msg.sender == address(zchf)){\n            repayInternal(amount);\n        } else {\n            require(false);\n        }\n        return true;\n    }\n\n    function repay(uint256 amount) public onlyOwner {\n        IERC20(zchf).transferFrom(msg.sender, address(this), amount);\n        repayInternal(amount);\n    }\n\n    function repay() public onlyOwner {\n        repayInternal(IERC20(zchf).balanceOf(address(this)));\n    }\n\n    function repayInternal(uint256 burnable) internal noChallenge {\n        uint256 actuallyBurned = IFrankencoin(zchf).burnWithReserve(burnable, reserveContribution);\n        notifyRepaidInternal(actuallyBurned);\n    }\n\n    function notifyRepaidInternal(uint256 amount) internal {\n        require(amount <= minted);\n        minted -= amount;\n        emitUpdate();\n    }\n\n    /**\n     * Withdraw any token that might have ended up on this address, except for collateral\n     * and reserve tokens, which also serve as a collateral.\n     */\n    function withdraw(address token, address target, uint256 amount) external onlyOwner {\n        if (token == address(collateral)){\n            withdrawCollateral(target, amount);\n        } else {\n            IERC20(token).transfer(target, amount);\n        }\n    }\n\n    function withdrawCollateral(address target, uint256 amount) public onlyOwner noChallenge {\n        IERC20(collateral).transfer(target, amount);\n        uint256 balance = collateralBalance();\n        require(isWellCollateralized(balance, price));\n        if (balance == 0){\n            // Close\n            cooldown = expiration;\n        } else {\n            require(balance >= minimumCollateral);\n        }\n        emitUpdate();\n    }\n\n    function isWellCollateralized(uint256 collateralReserve, uint256 atPrice) internal view returns (bool) {\n        return collateralReserve * atPrice >= minted;\n    }\n\n    function emitUpdate() internal {\n        emit MintingUpdate(collateralBalance(), price, minted, limit);\n    }\n\n    function notifyChallengeStarted(uint256 size) external onlyHub {\n        uint256 colbal = collateralBalance();\n        require(size <= colbal, \"size exeeds collateral\");\n        require(colbal > 0, \"no collateral\"); // nothing to challenge\n        require(size >= colbal / 20, \"size too small\"); // must challenge at least 5% of the position\n        challengedAmount += size;\n    }\n\n    /**\n     * @notice check whether challenge can be averted\n     * @param _collateralAmount   amount of collateral challenged (dec18)\n     * @param _bidAmountZCHF      bid amount in ZCHF (dec18)\n     * @return true if challenge can be averted\n     */\n    function tryAvertChallenge(uint256 _collateralAmount, uint256 _bidAmountZCHF) external onlyHub returns (bool) {\n        if (block.timestamp >= expiration){\n            return false; // position expired, let every challenge succeed\n        } else if (_bidAmountZCHF * ONE_DEC18 >= price * _collateralAmount){\n            // challenge averted, bid is high enough\n            challengedAmount -= _collateralAmount;\n            // don't allow minter to close the position immediately so challenge can be repeated\n            restrictMinting(1 days);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @notice Notifies the position that a challenge was successful.\n     * Triggers the payout of the challenged part of the collateral.\n     * Returns three important numbers:\n     *  - repay: the amount that is needed to repay for the actually minted zchf wit the challenged collateral\n     *  - minted: the number of zchf that where actually minted and used using the challenged collateral\n     *  - mintmax: the maximum number of zchf that could have been minted and used using the challenged collateral \n     * @param _bidder   address of the bidder that receives the collateral\n     * @param _bid      bid amount in ZCHF (dec18)\n     * @param _size     size of the collateral bid for (dec 18)\n     * @return adjusted bid size, repaied xchf, reserve contribution ppm\n     */\n    function notifyChallengeSucceeded(address _bidder, uint256 _bid, uint256 _size) \n        external onlyHub returns (uint256, uint256, uint32)\n    {\n        challengedAmount -= _size;\n        uint256 volumeZCHF = _mulD18(price, _size);\n        if (volumeZCHF > minted){\n            _size = _divD18(_mulD18(_size, minted), volumeZCHF);\n            _bid = _divD18(_mulD18(_bid, minted), volumeZCHF);\n            volumeZCHF = minted;\n        }\n        require(_bid < volumeZCHF, \"challenge not successful\");\n        // transfer collateral to the bidder\n        IERC20(collateral).transfer(_bidder, _size);\n        notifyRepaidInternal(volumeZCHF); // we assume the caller takes care of the actual repayment\n        return (_bid, volumeZCHF, reserveContribution);\n    }\n\n    modifier noMintRestriction() {\n       require(cooldown < block.timestamp, \"cooldown\");\n       require(block.timestamp <= expiration, \"expired\");\n        _;\n    }\n\n    modifier noChallenge() {\n        require(challengedAmount == 0, \"challenges pending\");\n        _;\n    }\n\n    modifier onlyHub() {\n        require(msg.sender == address(hub), \"not hub\");\n        _;\n    }\n\n}"
    },
    "contracts/IFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\n\ninterface IFrankencoin is IERC20 {\n\n    function suggestMinter(address _minter, uint256 _applicationPeriod, \n      uint256 _applicationFee, string calldata _message) external;\n\n    function registerPosition(address position) external;\n\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\n\n    function reserve() external view returns (IReserve);\n\n    function isMinter(address minter) external view returns (bool);\n\n    function isPosition(address position) external view returns (address);\n    \n    function mint(address target, uint256 amount) external;\n\n    function mint(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\n\n    function burn(uint256 amountIncludingReserve, uint32 reservePPM) external;\n\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\n\n    function burn(address target, uint256 amount) external;\n\n    function notifyLoss(uint256 amount) external;\n\n}"
    },
    "contracts/IERC20.sol": {
      "content": "/**\n* SPDX-License-Identifier: MIT\n*\n* Copyright (c) 2016-2019 zOS Global Limited\n*\n*/\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\n * the optional functions; to access them see `ERC20Detailed`.\n */\n\ninterface IERC20 {\n\n    // Optional functions\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    function transferAndCall(address recipient, uint256 amount, bytes calldata data) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\n     * zero by default.\n     *\n     * This value changes when `approve` or `transferFrom` are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * > Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an `Approval` event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a `Transfer` event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to `approve`. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n}"
    },
    "contracts/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./IReserve.sol\";\nimport \"./IFrankencoin.sol\";\n\ninterface IPosition {\n\n    function collateral() external returns (IERC20);\n\n    function challengePeriod() external returns (uint256);\n\n    function price() external returns (uint256);\n\n    function initializeClone(address owner, uint256 _price, uint256 _limit, uint256 _coll, uint256 _mint) external;\n\n    function deny(address[] calldata helpers, string calldata message) external;\n\n    function notifyChallengeStarted(uint256 size) external;\n\n    function tryAvertChallenge(uint256 size, uint256 bid) external returns (bool);\n\n    function notifyChallengeSucceeded(address bidder, uint256 bid, uint256 size) external returns (uint256, uint256, uint32);\n\n}"
    },
    "contracts/IReserve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IReserve {\n   function isQualified(address sender, address[] calldata helpers) external view returns (bool);\n}"
    },
    "contracts/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n//\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\n//\n// Modifications:\n// - Replaced Context._msgSender() with msg.sender\n// - Made leaner\n// - Extracted interface\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\ncontract Ownable {\n\n    address public owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor (address initialOwner) {\n        require(initialOwner != address(0), \"0x0\");\n        owner = initialOwner;\n        emit OwnershipTransferred(address(0), owner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) virtual public onlyOwner {\n        require(newOwner != address(0), \"0x0\");\n        owner = newOwner;\n        emit OwnershipTransferred(owner, newOwner);\n    }\n\n    modifier onlyOwner() {\n        require(owner == msg.sender || owner == address(0x0), \"not owner\");\n        _;\n    }\n}"
    },
    "contracts/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC677Receiver {\n    \n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\n\n}"
    },
    "contracts/MathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.0 <0.9.0;\n\n/** \n * @title Functions for share valuation\n */\ncontract MathUtil {\n\n    uint256 internal constant ONE_DEC18 = 10**18;\n    uint256 internal constant THRESH_DEC18 =  10000000000000000;//0.01\n    /**\n     * @notice Cubic root with Halley approximation\n     *         Number 1e18 decimal\n     * @param _v     number for which we calculate x**(1/3)\n     * @return returns _v**(1/3)\n     */\n    function _cubicRoot(uint256 _v) internal pure returns (uint256) {\n        uint256 x = ONE_DEC18;\n        uint256 xOld;\n        bool cond;\n        do {\n            xOld = x;\n            uint256 powX3 = _mulD18(_mulD18(x, x), x);\n            x = _mulD18(x, _divD18( (powX3 + 2 * _v) , (2 * powX3 + _v)));\n            cond = xOld > x ? xOld - x > THRESH_DEC18 : x - xOld > THRESH_DEC18;\n        } while ( cond );\n        return x;\n    }\n\n    function _mulD18(uint256 _a, uint256 _b) internal pure returns(uint256) {\n        return _a * _b / ONE_DEC18;\n    }\n\n    function _divD18(uint256 _a, uint256 _b) internal pure returns(uint256) {\n        return (_a * ONE_DEC18) / _b ;\n    }\n\n    function _power3(uint256 _x) internal pure returns(uint256) {\n        return _mulD18(_mulD18(_x, _x), _x);\n    }\n\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}