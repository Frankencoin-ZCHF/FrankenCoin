{
  "language": "Solidity",
  "sources": {
    "contracts/Equity.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Frankencoin.sol\";\r\nimport \"./utils/MathUtil.sol\";\r\nimport \"./interface/IReserve.sol\";\r\nimport \"./interface/IERC677Receiver.sol\";\r\n\r\n/**\r\n * @title Equity\r\n * @notice If the Frankencoin system was a bank, this contract would represent the equity on its balance sheet.\r\n * Like with a corporation, the owners of the equity capital are the shareholders, or in this case the holders\r\n * of Frankencoin Pool Shares (FPS) tokens. Anyone can mint additional FPS tokens by adding Frankencoins to the\r\n * reserve pool. Also, FPS tokens can be redeemed for Frankencoins again after a minimum holding period.\r\n * Furthermore, the FPS shares come with some voting power. Anyone that held at least 3% of the holding-period-\r\n * weighted reserve pool shares gains veto power and can veto new proposals.\r\n */\r\ncontract Equity is ERC20PermitLight, MathUtil, IReserve {\r\n    /**\r\n     * The VALUATION_FACTOR determines the market cap of the reserve pool shares relative to the equity reserves.\r\n     * The following always holds: Market Cap = Valuation Factor * Equity Reserve = Price * Supply\r\n     *\r\n     * In the absence of profits and losses, the variables grow as follows when FPS tokens are minted:\r\n     *\r\n     * |   Reserve     |   Market Cap  |     Price     |     Supply   |\r\n     * |          1000 |          3000 |             3 |         1000 |\r\n     * |       1000000 |       3000000 |           300 |        10000 |\r\n     * |    1000000000 |    3000000000 |         30000 |       100000 |\r\n     * | 1000000000000 | 3000000000000 |       3000000 |      1000000 |\r\n     *\r\n     * I.e., the supply is proporational to the cubic root of the reserve and the price is proportional to the\r\n     * squared cubic root. When profits accumulate or losses materialize, the reserve, the market cap,\r\n     * and the price are adjusted proportionally, with the supply staying constant. In the absence of an extreme\r\n     * inflation of the Swiss franc, it is unlikely that there will ever be more than ten million FPS.\r\n     */\r\n    uint32 public constant VALUATION_FACTOR = 3;\r\n\r\n    uint256 private constant MINIMUM_EQUITY = 1000 * ONE_DEC18;\r\n\r\n    /**\r\n     * @notice The quorum in basis points. 100 is 1%.\r\n     */\r\n    uint32 private constant QUORUM = 200;\r\n\r\n    /**\r\n     * @notice The number of digits to store the average holding time of share tokens.\r\n     */\r\n    uint8 private constant TIME_RESOLUTION_BITS = 20;\r\n\r\n    /**\r\n     * @notice The minimum holding duration. You are not allowed to redeem your pool shares if you held them\r\n     * for less than the minimum holding duration at average. For example, if you have two pool shares on your\r\n     * address, one acquired 5 days ago and one acquired 105 days ago, you cannot redeem them as the average\r\n     * holding duration of your shares is only 55 days < 90 days.\r\n     */\r\n    uint256 public constant MIN_HOLDING_DURATION = 90 days << TIME_RESOLUTION_BITS; // Set to 5 for local testing\r\n\r\n    Frankencoin public immutable zchf;\r\n\r\n    /**\r\n     * @dev To track the total number of votes we need to know the number of votes at the anchor time and when the\r\n     * anchor time was. This is (hopefully) stored in one 256 bit slot, with the anchor time taking 64 Bits and\r\n     * the total vote count 192 Bits. Given the sub-second resolution of 20 Bits, the implicit assumption is\r\n     * that the timestamp can always be stored in 44 Bits (i.e. it does not exceed half a million years). Further,\r\n     * given 18 decimals (about 60 Bits), this implies that the total supply cannot exceed\r\n     *   192 - 60 - 44 - 20 = 68 Bits\r\n     * Here, we are also save, as 68 Bits would imply more than a trillion outstanding shares. In fact,\r\n     * a limit of about 2**36 shares (that's about 2**96 Bits when taking into account the decimals) is imposed\r\n     * when minting. This means that the maximum supply is billions shares, which is could only be reached in\r\n     * a scenario with hyper inflation, in which case the stablecoin is worthless anyway.\r\n     */\r\n    uint192 private totalVotesAtAnchor; // Total number of votes at the anchor time, see comment on the um\r\n    uint64 private totalVotesAnchorTime; // 44 Bit for the time stamp, 20 Bit sub-second time resolution\r\n\r\n    /**\r\n     * @notice Keeping track on who delegated votes to whom.\r\n     * Note that delegation does not mean you cannot vote / veto any more, it just means that the delegate can\r\n     * benefit from your votes when invoking a veto. Circular delegations are valid, do not help when voting.\r\n     */\r\n    mapping(address owner => address delegate) public delegates;\r\n\r\n    /**\r\n     * @notice A time stamp in the past such that: votes = balance * (time passed since anchor was set)\r\n     */\r\n    mapping(address owner => uint64 timestamp) private voteAnchor; // 44 bits for time stamp, 20 subsecond resolution\r\n\r\n    event Delegation(address indexed from, address indexed to); // indicates a delegation\r\n    event Trade(address who, int amount, uint totPrice, uint newprice); // amount pos or neg for mint or redemption\r\n\r\n    constructor(Frankencoin zchf_) ERC20(18) {\r\n        zchf = zchf_;\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return \"Frankencoin Pool Share\";\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return \"FPS\";\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the price of one FPS in ZCHF with 18 decimals precision.\r\n     */\r\n    function price() public view returns (uint256) {\r\n        uint256 equity = zchf.equity();\r\n        if (equity == 0 || totalSupply() == 0) {\r\n            return ONE_DEC18; // initial price is 1000 ZCHF for the first 1000 FPS\r\n        } else {\r\n            return (VALUATION_FACTOR * zchf.equity() * ONE_DEC18) / totalSupply();\r\n        }\r\n    }\r\n\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal override {\r\n        super._beforeTokenTransfer(from, to, amount);\r\n        if (amount > 0) {\r\n            // No need to adjust the sender votes. When they send out 10% of their shares, they also lose 10% of\r\n            // their votes so everything falls nicely into place. Recipient votes should stay the same, but grow\r\n            // faster in the future, requiring an adjustment of the anchor.\r\n            uint256 roundingLoss = _adjustRecipientVoteAnchor(to, amount);\r\n            // The total also must be adjusted and kept accurate by taking into account the rounding error.\r\n            _adjustTotalVotes(from, amount, roundingLoss);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns whether the given address is allowed to redeem FPS, which is the\r\n     * case after their average holding duration is larger than the required minimum.\r\n     */\r\n    function canRedeem(address owner) public view returns (bool) {\r\n        return _anchorTime() - voteAnchor[owner] >= MIN_HOLDING_DURATION;\r\n    }\r\n\r\n    /**\r\n     * @notice Decrease the total votes anchor when tokens lose their voting power due to being moved\r\n     * @param from      sender\r\n     * @param amount    amount to be sent\r\n     */\r\n    function _adjustTotalVotes(address from, uint256 amount, uint256 roundingLoss) internal {\r\n        uint64 time = _anchorTime();\r\n        uint256 lostVotes = from == address(0x0) ? 0 : (time - voteAnchor[from]) * amount;\r\n        totalVotesAtAnchor = uint192(totalVotes() - roundingLoss - lostVotes);\r\n        totalVotesAnchorTime = time;\r\n    }\r\n\r\n    /**\r\n     * @notice the vote anchor of the recipient is moved forward such that the number of calculated\r\n     * votes does not change despite the higher balance.\r\n     * @param to        receiver address\r\n     * @param amount    amount to be received\r\n     * @return the number of votes lost due to rounding errors\r\n     */\r\n    function _adjustRecipientVoteAnchor(address to, uint256 amount) internal returns (uint256) {\r\n        if (to != address(0x0)) {\r\n            uint256 recipientVotes = votes(to); // for example 21 if 7 shares were held for 3 seconds\r\n            uint256 newbalance = balanceOf(to) + amount; // for example 11 if 4 shares are added\r\n            // new example anchor is only 21 / 11 = 1 second in the past\r\n            voteAnchor[to] = uint64(_anchorTime() - recipientVotes / newbalance);\r\n            return recipientVotes % newbalance; // we have lost 21 % 11 = 10 votes\r\n        } else {\r\n            // optimization for burn, vote anchor of null address does not matter\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Time stamp with some additional bits for higher resolution.\r\n     */\r\n    function _anchorTime() internal view returns (uint64) {\r\n        return uint64(block.timestamp << TIME_RESOLUTION_BITS);\r\n    }\r\n\r\n    /**\r\n     * @notice The relative voting power of the address.\r\n     * @return A percentage with 1e18 being 100%\r\n     */\r\n    function relativeVotes(address holder) external view returns (uint256) {\r\n        return (ONE_DEC18 * votes(holder)) / totalVotes();\r\n    }\r\n\r\n    /**\r\n     * @notice The votes of the holder, excluding votes from delegates.\r\n     */\r\n    function votes(address holder) public view returns (uint256) {\r\n        return balanceOf(holder) * (_anchorTime() - voteAnchor[holder]);\r\n    }\r\n\r\n    /**\r\n     * @notice How long the holder already held onto their average FPS in seconds.\r\n     */\r\n    function holdingDuration(address holder) public view returns (uint256) {\r\n        return (_anchorTime() - voteAnchor[holder]) >> TIME_RESOLUTION_BITS;\r\n    }\r\n\r\n    /**\r\n     * @notice Total number of votes in the system.\r\n     */\r\n    function totalVotes() public view returns (uint256) {\r\n        return totalVotesAtAnchor + totalSupply() * (_anchorTime() - totalVotesAnchorTime);\r\n    }\r\n\r\n    /**\r\n     * @notice The number of votes the sender commands when taking the support of the helpers into account.\r\n     * @param sender    The address whose total voting power is of interest\r\n     * @param helpers   An incrementally sorted list of helpers without duplicates and without the sender.\r\n     *                  The call fails if the list contains an address that does not delegate to sender.\r\n     *                  For indirect delegates, i.e. a -> b -> c, both a and b must be included for both to count.\r\n     * @return          The total number of votes of sender at the current point in time.\r\n     */\r\n    function votesDelegated(address sender, address[] calldata helpers) public view returns (uint256) {\r\n        uint256 _votes = votes(sender);\r\n        require(_checkDuplicatesAndSorted(helpers));\r\n        for (uint i = 0; i < helpers.length; i++) {\r\n            address current = helpers[i];\r\n            require(current != sender);\r\n            require(_canVoteFor(sender, current));\r\n            _votes += votes(current);\r\n        }\r\n        return _votes;\r\n    }\r\n\r\n    function _checkDuplicatesAndSorted(address[] calldata helpers) internal pure returns (bool ok) {\r\n        if (helpers.length <= 1) {\r\n            return true;\r\n        } else {\r\n            address prevAddress = helpers[0];\r\n            for (uint i = 1; i < helpers.length; i++) {\r\n                if (helpers[i] <= prevAddress) {\r\n                    return false;\r\n                }\r\n                prevAddress = helpers[i];\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Checks whether the sender address is qualified given a list of helpers that delegated their votes\r\n     * directly or indirectly to the sender. It is the responsiblity of the caller to figure out whether\r\n     * helpes are necessary and to identify them by scanning the blockchain for Delegation events.\r\n     */\r\n    function checkQualified(address sender, address[] calldata helpers) public view override {\r\n        uint256 _votes = votesDelegated(sender, helpers);\r\n        if (_votes * 10000 < QUORUM * totalVotes()) revert NotQualified();\r\n    }\r\n\r\n    error NotQualified();\r\n\r\n    /**\r\n     * @notice Increases the voting power of the delegate by your number of votes without taking away any voting power\r\n     * from the sender.\r\n     */\r\n    function delegateVoteTo(address delegate) external {\r\n        delegates[msg.sender] = delegate;\r\n        emit Delegation(msg.sender, delegate);\r\n    }\r\n\r\n    function _canVoteFor(address delegate, address owner) internal view returns (bool) {\r\n        if (owner == delegate) {\r\n            return true;\r\n        } else if (owner == address(0x0)) {\r\n            return false;\r\n        } else {\r\n            return _canVoteFor(delegate, delegates[owner]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Since quorum is rather low, it is important to have a way to prevent malicious minority holders\r\n     * from blocking the whole system. This method provides a way for the good guys to team up and destroy\r\n     * the bad guy's votes (at the cost of also reducing their own votes). This mechanism potentially\r\n     * gives full control over the system to whoever has 51% of the votes.\r\n     *\r\n     * Since this is a rather aggressive measure, delegation is not supported. Every holder must call this\r\n     * method on their own.\r\n     * @param targets   The target addresses to remove votes from\r\n     * @param votesToDestroy    The maximum number of votes the caller is willing to sacrifice\r\n     */\r\n    function kamikaze(address[] calldata targets, uint256 votesToDestroy) external {\r\n        uint256 budget = _reduceVotes(msg.sender, votesToDestroy);\r\n        uint256 destroyedVotes = 0;\r\n        for (uint256 i = 0; i < targets.length && destroyedVotes < budget; i++) {\r\n            destroyedVotes += _reduceVotes(targets[i], budget - destroyedVotes);\r\n        }\r\n        require(destroyedVotes > 0); // sanity check\r\n        totalVotesAtAnchor = uint192(totalVotes() - destroyedVotes - budget);\r\n        totalVotesAnchorTime = _anchorTime();\r\n    }\r\n\r\n    function _reduceVotes(address target, uint256 amount) internal returns (uint256) {\r\n        uint256 votesBefore = votes(target);\r\n        if (amount >= votesBefore) {\r\n            amount = votesBefore;\r\n            voteAnchor[target] = _anchorTime();\r\n            return votesBefore;\r\n        } else {\r\n            voteAnchor[target] = uint64(_anchorTime() - (votesBefore - amount) / balanceOf(target));\r\n            return votesBefore - votes(target);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Call this method to obtain newly minted pool shares in exchange for Frankencoins.\r\n     * No allowance required (i.e. it is hardcoded in the Frankencoin token contract).\r\n     * Make sure to invest at least 10e-12 * market cap to avoid rounding losses.\r\n     *\r\n     * @dev If equity is close to zero or negative, you need to send enough ZCHF to bring equity back to 1000 ZCHF.\r\n     *\r\n     * @param amount            Frankencoins to invest\r\n     * @param expectedShares    Minimum amount of expected shares for frontrunning protection\r\n     */\r\n    function invest(uint256 amount, uint256 expectedShares) external returns (uint256) {\r\n        zchf.transferFrom(msg.sender, address(this), amount);\r\n        uint256 equity = zchf.equity();\r\n        require(equity >= MINIMUM_EQUITY, \"insuf equity\"); // ensures that the initial deposit is at least 1000 ZCHF\r\n\r\n        uint256 shares = _calculateShares(equity <= amount ? 0 : equity - amount, amount);\r\n        require(shares >= expectedShares);\r\n        _mint(msg.sender, shares);\r\n        emit Trade(msg.sender, int(shares), amount, price());\r\n\r\n        // limit the total supply to a reasonable amount to guard against overflows with price and vote calculations\r\n        // the 36 bits are 68 bits for magnitude and 60 bits for precision, as calculated in an above comment\r\n        require(totalSupply() <= type(uint96).max, \"total supply exceeded\");\r\n        return shares;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate shares received when investing Frankencoins\r\n     * @param investment    ZCHF to be invested\r\n     * @return shares to be received in return\r\n     */\r\n    function calculateShares(uint256 investment) external view returns (uint256) {\r\n        return _calculateShares(zchf.equity(), investment);\r\n    }\r\n\r\n    function _calculateShares(uint256 capitalBefore, uint256 investment) internal view returns (uint256) {\r\n        uint256 totalShares = totalSupply();\r\n        uint256 investmentExFees = (investment * 997) / 1000; // remove 0.3% fee\r\n        // Assign 1000 FPS for the initial deposit, calculate the amount otherwise\r\n        uint256 newTotalShares = capitalBefore < MINIMUM_EQUITY || totalShares == 0\r\n            ? totalShares + 1000 * ONE_DEC18\r\n            : _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investmentExFees, capitalBefore)));\r\n        return newTotalShares - totalShares;\r\n    }\r\n\r\n    /**\r\n     * @notice Redeem the given amount of shares owned by the sender and transfer the proceeds to the target.\r\n     * @return The amount of ZCHF transferred to the target\r\n     */\r\n    function redeem(address target, uint256 shares) external returns (uint256) {\r\n        return _redeemFrom(msg.sender, target, shares);\r\n    }\r\n\r\n    /**\r\n     * @notice Like redeem(...), but with an extra parameter to protect against frontrunning.\r\n     * @param expectedProceeds  The minimum acceptable redemption proceeds.\r\n     */\r\n    function redeemExpected(address target, uint256 shares, uint256 expectedProceeds) external returns (uint256) {\r\n        uint256 proceeds = _redeemFrom(msg.sender, target, shares);\r\n        require(proceeds >= expectedProceeds);\r\n        return proceeds;\r\n    }\r\n\r\n    /**\r\n     * @notice Redeem FPS based on an allowance from the owner to the caller.\r\n     * See also redeemExpected(...).\r\n     */\r\n    function redeemFrom(\r\n        address owner,\r\n        address target,\r\n        uint256 shares,\r\n        uint256 expectedProceeds\r\n    ) external returns (uint256) {\r\n        _useAllowance(owner, msg.sender, shares);\r\n        uint256 proceeds = _redeemFrom(owner, target, shares);\r\n        require(proceeds >= expectedProceeds);\r\n        return proceeds;\r\n    }\r\n\r\n    function _redeemFrom(address owner, address target, uint256 shares) internal returns (uint256) {\r\n        require(canRedeem(owner));\r\n        uint256 proceeds = calculateProceeds(shares);\r\n        _burn(owner, shares);\r\n        zchf.transfer(target, proceeds);\r\n        emit Trade(owner, -int(shares), proceeds, price());\r\n        return proceeds;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate ZCHF received when depositing shares\r\n     * @param shares number of shares we want to exchange for ZCHF,\r\n     *               in dec18 format\r\n     * @return amount of ZCHF received for the shares\r\n     */\r\n    function calculateProceeds(uint256 shares) public view returns (uint256) {\r\n        uint256 totalShares = totalSupply();\r\n        require(shares + ONE_DEC18 < totalShares, \"too many shares\"); // make sure there is always at least one share\r\n        uint256 capital = zchf.equity();\r\n        uint256 reductionAfterFees = (shares * 997) / 1000;\r\n        uint256 newCapital = _mulD18(capital, _power3(_divD18(totalShares - reductionAfterFees, totalShares)));\r\n        return capital - newCapital;\r\n    }\r\n\r\n    /**\r\n     * @notice If there is less than 1000 ZCHF in equity left (maybe even negative), the system is at risk\r\n     * and we should allow qualified FPS holders to restructure the system.\r\n     *\r\n     * Example: there was a devastating loss and equity stands at -1'000'000. Most shareholders have lost hope in the\r\n     * Frankencoin system except for a group of small FPS holders who still believes in it and is willing to provide\r\n     * 2'000'000 ZCHF to save it. These brave souls are essentially donating 1'000'000 to the minter reserve and it\r\n     * would be wrong to force them to share the other million with the passive FPS holders. Instead, they will get\r\n     * the possibility to bootstrap the system again owning 100% of all FPS shares.\r\n     *\r\n     * @param helpers          A list of addresses that delegate to the caller in incremental order\r\n     * @param addressesToWipe  A list of addresses whose FPS will be burned to zero\r\n     */\r\n    function restructureCapTable(address[] calldata helpers, address[] calldata addressesToWipe) external {\r\n        require(zchf.equity() < MINIMUM_EQUITY);\r\n        checkQualified(msg.sender, helpers);\r\n        for (uint256 i = 0; i < addressesToWipe.length; i++) {\r\n            address current = addressesToWipe[i];\r\n            _burn(current, balanceOf(current));\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Frankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./utils/ERC20PermitLight.sol\";\r\nimport \"./Equity.sol\";\r\nimport \"./interface/IReserve.sol\";\r\nimport \"./interface/IFrankencoin.sol\";\r\n\r\n/**\r\n * @title FrankenCoin\r\n * @notice The Frankencoin (ZCHF) is an ERC-20 token that is designed to track the value of the Swiss franc.\r\n * It is not upgradable, but open to arbitrary minting plugins. These are automatically accepted if none of the\r\n * qualified pool share holders casts a veto, leading to a flexible but conservative governance.\r\n */\r\ncontract Frankencoin is ERC20PermitLight, IFrankencoin {\r\n    /**\r\n     * @notice Minimal fee and application period when suggesting a new minter.\r\n     */\r\n    uint256 public constant MIN_FEE = 1000 * (10 ** 18);\r\n    uint256 public immutable MIN_APPLICATION_PERIOD; // for example 10 days\r\n\r\n    /**\r\n     * @notice The contract that holds the reserve.\r\n     */\r\n    IReserve public immutable override reserve;\r\n\r\n    /**\r\n     * @notice How much of the reserve belongs to the minters. Everything else belongs to the pool share holders.\r\n     * Stored with 6 additional digits of accuracy so no rounding is necessary when dealing with parts per\r\n     * million (ppm) in reserve calculations.\r\n     */\r\n    uint256 private minterReserveE6;\r\n\r\n    /**\r\n     * @notice Map of minters to approval time stamps. If the time stamp is in the past, the minter contract is allowed\r\n     * to mint Frankencoins.\r\n     */\r\n    mapping(address minter => uint256 validityStart) public minters;\r\n\r\n    /**\r\n     * @notice List of positions that are allowed to mint and the minter that registered them.\r\n     */\r\n    mapping(address position => address registeringMinter) public positions;\r\n\r\n    event MinterApplied(address indexed minter, uint256 applicationPeriod, uint256 applicationFee, string message);\r\n    event MinterDenied(address indexed minter, string message);\r\n    event Loss(address indexed reportingMinter, uint256 amount);\r\n    event Profit(address indexed reportingMinter, uint256 amount);\r\n\r\n    error PeriodTooShort();\r\n    error FeeTooLow();\r\n    error AlreadyRegistered();\r\n    error NotMinter();\r\n    error TooLate();\r\n\r\n    modifier minterOnly() {\r\n        if (!isMinter(msg.sender) && !isMinter(positions[msg.sender])) revert NotMinter();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Initiates the Frankencoin with the provided minimum application period for new plugins\r\n     * in seconds, for example 10 days, i.e. 3600*24*10 = 864000\r\n     */\r\n    constructor(uint256 _minApplicationPeriod) ERC20(18) {\r\n        MIN_APPLICATION_PERIOD = _minApplicationPeriod;\r\n        reserve = new Equity(this);\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return \"Frankencoin\";\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return \"ZCHF\";\r\n    }\r\n\r\n    function initialize(address _minter, string calldata _message) external {\r\n        require(totalSupply() == 0 && reserve.totalSupply() == 0);\r\n        minters[_minter] = block.timestamp;\r\n        emit MinterApplied(_minter, 0, 0, _message);\r\n    }\r\n\r\n    /**\r\n     * @notice Publicly accessible method to suggest a new way of minting Frankencoin.\r\n     * @dev The caller has to pay an application fee that is irrevocably lost even if the new minter is vetoed.\r\n     * The caller must assume that someone will veto the new minter unless there is broad consensus that the new minter\r\n     * adds value to the Frankencoin system. Complex proposals should have application periods and applications fees\r\n     * above the minimum. It is assumed that over time, informal ways to coordinate on new minters emerge. The message\r\n     * parameter might be useful for initiating further communication. Maybe it contains a link to a website describing\r\n     * the proposed minter.\r\n     *\r\n     * @param _minter              An address that is given the permission to mint Frankencoins\r\n     * @param _applicationPeriod   The time others have to veto the suggestion, at least MIN_APPLICATION_PERIOD\r\n     * @param _applicationFee      The fee paid by the caller, at least MIN_FEE\r\n     * @param _message             An optional human readable message to everyone watching this contract\r\n     */\r\n    function suggestMinter(\r\n        address _minter,\r\n        uint256 _applicationPeriod,\r\n        uint256 _applicationFee,\r\n        string calldata _message\r\n    ) external override {\r\n        if (_applicationPeriod < MIN_APPLICATION_PERIOD) revert PeriodTooShort();\r\n        if (_applicationFee < MIN_FEE) revert FeeTooLow();\r\n        if (minters[_minter] != 0) revert AlreadyRegistered();\r\n        _collectProfits(address(this), msg.sender, _applicationFee);\r\n        minters[_minter] = block.timestamp + _applicationPeriod;\r\n        emit MinterApplied(_minter, _applicationPeriod, _applicationFee, _message);\r\n    }\r\n\r\n    /**\r\n     * @notice Make the system more user friendly by skipping the allowance in many cases.\r\n     * @dev We trust minters and the positions they have created to mint and burn as they please, so\r\n     * giving them arbitrary allowances does not pose an additional risk.\r\n     */\r\n    function _allowance(address owner, address spender) internal view override returns (uint256) {\r\n        uint256 explicit = super._allowance(owner, spender);\r\n        if (explicit > 0) {\r\n            return explicit; // don't waste gas checking minter\r\n        } else if (isMinter(spender) || isMinter(getPositionParent(spender)) || spender == address(reserve)) {\r\n            return INFINITY;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice The reserve provided by the owners of collateralized positions.\r\n     * @dev The minter reserve can be used to cover losses after the equity holders have been wiped out.\r\n     */\r\n    function minterReserve() public view returns (uint256) {\r\n        return minterReserveE6 / 1000000;\r\n    }\r\n\r\n    /**\r\n     * @notice Allows minters to register collateralized debt positions, thereby giving them the ability to mint Frankencoins.\r\n     * @dev It is assumed that the responsible minter that registers the position ensures that the position can be trusted.\r\n     */\r\n    function registerPosition(address _position) external override {\r\n        if (!isMinter(msg.sender)) revert NotMinter();\r\n        positions[_position] = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice The amount of equity of the Frankencoin system in ZCHF, owned by the holders of Frankencoin Pool Shares.\r\n     * @dev Note that the equity contract technically holds both the minter reserve as well as the equity, so the minter\r\n     * reserve must be subtracted. All fees and other kind of income is added to the Equity contract and essentially\r\n     * constitutes profits attributable to the pool share holders.\r\n     */\r\n    function equity() public view returns (uint256) {\r\n        uint256 balance = balanceOf(address(reserve));\r\n        uint256 minReserve = minterReserve();\r\n        if (balance <= minReserve) {\r\n            return 0;\r\n        } else {\r\n            return balance - minReserve;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Qualified pool share holders can deny minters during the application period.\r\n     * @dev Calling this function is relatively cheap thanks to the deletion of a storage slot.\r\n     */\r\n    function denyMinter(address _minter, address[] calldata _helpers, string calldata _message) external override {\r\n        if (block.timestamp > minters[_minter]) revert TooLate();\r\n        reserve.checkQualified(msg.sender, _helpers);\r\n        delete minters[_minter];\r\n        emit MinterDenied(_minter, _message);\r\n    }\r\n\r\n    /**\r\n     * @notice Mints the provided amount of ZCHF to the target address, automatically forwarding\r\n     * the minting fee and the reserve to the right place.\r\n     */\r\n    function mintWithReserve(\r\n        address _target,\r\n        uint256 _amount,\r\n        uint32 _reservePPM,\r\n        uint32 _feesPPM\r\n    ) external override minterOnly {\r\n        uint256 usableMint = (_amount * (1000_000 - _feesPPM - _reservePPM)) / 1000_000; // rounding down is fine\r\n        _mint(_target, usableMint);\r\n        _mint(address(reserve), _amount - usableMint); // rest goes to equity as reserves or as fees\r\n        minterReserveE6 += _amount * _reservePPM;\r\n        emit Profit(msg.sender, (_feesPPM * _amount) / 1000_000);\r\n    }\r\n\r\n    function mint(address _target, uint256 _amount) external override minterOnly {\r\n        _mint(_target, _amount);\r\n    }\r\n\r\n    /**\r\n     * Anyone is allowed to burn their ZCHF.\r\n     */\r\n    function burn(uint256 _amount) external {\r\n        _burn(msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn someone elses ZCHF.\r\n     */\r\n    function burnFrom(address _owner, uint256 _amount) external override minterOnly {\r\n        _burn(_owner, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn that amount without reclaiming the reserve, but freeing it up and thereby essentially donating it to the\r\n     * pool share holders. This can make sense in combination with 'coverLoss', i.e. when it is the pool share\r\n     * holders that bear the risk and depending on the outcome they make a profit or a loss.\r\n     *\r\n     * Design rule: Minters calling this method are only allowed to so for tokens amounts they previously minted with\r\n     * the same _reservePPM amount.\r\n     *\r\n     * For example, if someone minted 50 ZCHF earlier with a 20% reserve requirement (200000 ppm), they got 40 ZCHF\r\n     * and paid 10 ZCHF into the reserve. Now they want to repay the debt by burning 50 ZCHF. When doing so using this\r\n     * method, 50 ZCHF get burned and on top of that, 10 ZCHF previously assigned to the minter's reserved are\r\n     * reassigned to the pool share holders.\r\n     */\r\n    function burnWithoutReserve(uint256 amount, uint32 reservePPM) public override minterOnly {\r\n        _burn(msg.sender, amount);\r\n        uint256 reserveReduction = amount * reservePPM;\r\n        if (reserveReduction > minterReserveE6) {\r\n            emit Profit(msg.sender, minterReserveE6 / 1000_000);\r\n            minterReserveE6 = 0; // should never happen, but we want robust behavior in case it does\r\n        } else {\r\n            minterReserveE6 -= reserveReduction;\r\n            emit Profit(msg.sender, reserveReduction / 1000_000);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Burns the provided number of tokens plus whatever reserves are associated with that amount given the reserve\r\n     * requirement. The caller is only allowed to use this method for tokens also minted through the caller with the\r\n     * same _reservePPM amount.\r\n     *\r\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\r\n     * Now they have 41 ZCHF that they do not need so they decide to repay that amount. Assuming the reserves are\r\n     * only 90% covered, the call to burnWithReserve will burn the 41 plus 9 from the reserve, reducing the outstanding\r\n     * 'debt' of the caller by 50 ZCHF in total. This total is returned by the method so the caller knows how much less\r\n     * they owe.\r\n     */\r\n    function burnWithReserve(\r\n        uint256 _amountExcludingReserve,\r\n        uint32 _reservePPM\r\n    ) external override minterOnly returns (uint256) {\r\n        uint256 freedAmount = calculateFreedAmount(_amountExcludingReserve, _reservePPM); // 50 in the example\r\n        minterReserveE6 -= freedAmount * _reservePPM; // reduce reserve requirements by original ratio\r\n        _transfer(address(reserve), msg.sender, freedAmount - _amountExcludingReserve); // collect assigned reserve\r\n        _burn(msg.sender, freedAmount); // burn the rest of the freed amount\r\n        return freedAmount;\r\n    }\r\n\r\n    /**\r\n     * @notice Burns the target amount taking the tokens to be burned from the payer and the payer's reserve.\r\n     * Only use this method for tokens also minted by the caller with the same _reservePPM.\r\n     *\r\n     * Example: the calling contract has previously minted 100 ZCHF with a reserve ratio of 20% (i.e. 200000 ppm).\r\n     * To burn half of that again, the minter calls burnFrom with a target amount of 50 ZCHF. Assuming that reserves\r\n     * are only 90% covered, this call will deduct 41 ZCHF from the payer's balance and 9 from the reserve, while\r\n     * reducing the minter reserve by 10.\r\n     */\r\n    function burnFromWithReserve(\r\n        address payer,\r\n        uint256 targetTotalBurnAmount,\r\n        uint32 reservePPM\r\n    ) external override minterOnly returns (uint256) {\r\n        uint256 assigned = calculateAssignedReserve(targetTotalBurnAmount, reservePPM);\r\n        _transfer(address(reserve), payer, assigned); // send reserve to owner\r\n        _burn(payer, targetTotalBurnAmount); // and burn the full amount from the owner's address\r\n        minterReserveE6 -= targetTotalBurnAmount * reservePPM; // reduce reserve requirements by original ratio\r\n        return assigned;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the reserve attributable to someone who minted the given amount with the given reserve requirement.\r\n     * Under normal circumstances, this is just the reserver requirement multiplied by the amount. However, after a\r\n     * severe loss of capital that burned into the minter's reserve, this can also be less than that.\r\n     */\r\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) public view returns (uint256) {\r\n        uint256 theoreticalReserve = (_reservePPM * mintedAmount) / 1000000;\r\n        uint256 currentReserve = balanceOf(address(reserve));\r\n        uint256 minterReserve_ = minterReserve();\r\n        if (currentReserve < minterReserve_) {\r\n            // not enough reserves, owner has to take a loss\r\n            return (theoreticalReserve * currentReserve) / minterReserve_;\r\n        } else {\r\n            return theoreticalReserve;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the amount that is freed when returning amountExcludingReserve given a reserve ratio of reservePPM,\r\n     * taking into account potential losses. Example values in the comments.\r\n     */\r\n    function calculateFreedAmount(\r\n        uint256 amountExcludingReserve /* 41 */,\r\n        uint32 reservePPM /* 20% */\r\n    ) public view returns (uint256) {\r\n        uint256 currentReserve = balanceOf(address(reserve)); // 18, 10% below what we should have\r\n        uint256 minterReserve_ = minterReserve(); // 20\r\n        uint256 adjustedReservePPM = currentReserve < minterReserve_\r\n            ? (reservePPM * currentReserve) / minterReserve_\r\n            : reservePPM; // 18%\r\n        return (1000000 * amountExcludingReserve) / (1000000 - adjustedReservePPM); // 41 / (1-18%) = 50\r\n    }\r\n\r\n    /**\r\n     * @notice Notify the Frankencoin that a minter lost economic access to some coins. This does not mean that the coins are\r\n     * literally lost. It just means that some ZCHF will likely never be repaid and that in order to bring the system\r\n     * back into balance, the lost amount of ZCHF must be removed from the reserve instead.\r\n     *\r\n     * For example, if a minter printed 1 million ZCHF for a mortgage and the mortgage turned out to be unsound with\r\n     * the house only yielding 800'000 in the subsequent auction, there is a loss of 200'000 that needs to be covered\r\n     * by the reserve.\r\n     */\r\n    function coverLoss(address source, uint256 _amount) external override minterOnly {\r\n        uint256 reserveLeft = balanceOf(address(reserve));\r\n        if (reserveLeft >= _amount) {\r\n            _transfer(address(reserve), source, _amount);\r\n        } else {\r\n            _transfer(address(reserve), source, reserveLeft);\r\n            _mint(source, _amount - reserveLeft);\r\n        }\r\n        emit Loss(source, _amount);\r\n    }\r\n\r\n    function collectProfits(address source, uint256 _amount) external override minterOnly {\r\n        _collectProfits(msg.sender, source, _amount);\r\n    }\r\n\r\n    function _collectProfits(address minter, address source, uint256 _amount) internal {\r\n        _transfer(source, address(reserve), _amount);\r\n        emit Profit(minter, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Returns true if the address is an approved minter.\r\n     */\r\n    function isMinter(address _minter) public view override returns (bool) {\r\n        return minters[_minter] != 0 && block.timestamp >= minters[_minter];\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the address of the minter that created this position or null if the provided address is unknown.\r\n     */\r\n    function getPositionParent(address _position) public view override returns (address) {\r\n        return positions[_position];\r\n    }\r\n}\r\n"
    },
    "contracts/interface/IERC20.sol": {
      "content": "/**\r\n * SPDX-License-Identifier: MIT\r\n *\r\n * Copyright (c) 2016-2019 zOS Global Limited\r\n *\r\n */\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP. Does not include\r\n * the optional functions; to access them see `ERC20Detailed`.\r\n */\r\n\r\ninterface IERC20 {\r\n    function name() external view returns (string memory);\r\n\r\n    function symbol() external view returns (string memory);\r\n\r\n    function decimals() external view returns (uint8);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens in existence.\r\n     */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Returns the amount of tokens owned by `account`.\r\n     */\r\n    function balanceOf(address account) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n     *\r\n     * Returns always true. Throws error on failure.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Returns the remaining number of tokens that `spender` will be\r\n     * allowed to spend on behalf of `owner` through `transferFrom`. This is\r\n     * zero by default.\r\n     *\r\n     * This value can change when `approve` or `transferFrom` are called.\r\n     */\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n     *\r\n     * Returns a boolean value indicating whether the operation succeeded.\r\n     *\r\n     * > Beware that changing an allowance with this method brings the risk\r\n     * that someone may use both the old and the new allowance by unfortunate\r\n     * transaction ordering. One possible solution to mitigate this race\r\n     * condition is to first reduce the spender's allowance to 0 and set the\r\n     * desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n     * allowance mechanism. `amount` is then deducted from the caller's\r\n     * allowance.\r\n     *\r\n     * Returns always true. Throws error on failure.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\r\n\r\n    /**\r\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n     * another (`to`).\r\n     *\r\n     * Note that `value` may be zero.\r\n     */\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    /**\r\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n     * a call to `approve`. `value` is the new allowance.\r\n     */\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "contracts/interface/IERC677Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IERC677Receiver {\r\n    \r\n    function onTokenTransfer(address from, uint256 amount, bytes calldata data) external returns (bool);\r\n\r\n}"
    },
    "contracts/interface/IFrankencoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IReserve.sol\";\r\n\r\ninterface IFrankencoin is IERC20 {\r\n    function suggestMinter(address _minter, uint256 _applicationPeriod, uint256 _applicationFee, string calldata _message) external;\r\n\r\n    function registerPosition(address position) external;\r\n\r\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\r\n\r\n    function reserve() external view returns (IReserve);\r\n\r\n    function minterReserve() external view returns (uint256);\r\n\r\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) external view returns (uint256);\r\n\r\n    function equity() external view returns (uint256);\r\n\r\n    function isMinter(address minter) external view returns (bool);\r\n\r\n    function getPositionParent(address position) external view returns (address);\r\n\r\n    function mint(address target, uint256 amount) external;\r\n\r\n    function mintWithReserve(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\r\n\r\n    function burnFrom(address target, uint256 amount) external;\r\n\r\n    function burnWithoutReserve(uint256 amountIncludingReserve, uint32 reservePPM) external;\r\n\r\n    function burnFromWithReserve(address payer, uint256 targetTotalBurnAmount, uint32 _reservePPM) external returns (uint256);\r\n\r\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\r\n\r\n    function coverLoss(address source, uint256 amount) external;\r\n\r\n    function collectProfits(address source, uint256 _amount) external;\r\n}\r\n"
    },
    "contracts/interface/IPosition.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IReserve.sol\";\r\nimport \"./IFrankencoin.sol\";\r\n\r\ninterface IPosition {\r\n\r\n    function original() external returns (address);\r\n\r\n    function collateral() external returns (IERC20);\r\n\r\n    function minimumCollateral() external returns (uint256);\r\n\r\n    function challengePeriod() external returns (uint64);\r\n\r\n    function expiration() external returns (uint256);\r\n\r\n    function price() external returns (uint256);\r\n\r\n    function reduceLimitForClone(uint256 amount) external;\r\n\r\n    function initializeClone(address owner, uint256 _price, uint256 _coll, uint256 _mint, uint256 expiration) external;\r\n\r\n    function deny(address[] calldata helpers, string calldata message) external;\r\n\r\n    function mint(address target, uint256 amount) external;\r\n\r\n    function minted() external returns (uint256);\r\n\r\n    function reserveContribution() external returns (uint32);\r\n\r\n    function getUsableMint(uint256 totalMint, bool beforeFees) external view returns (uint256);\r\n\r\n    function challengeData(uint256 challengeStart) external view returns (uint256 liqPrice, uint64 phase1, uint64 phase2);\r\n\r\n    function notifyChallengeStarted(uint256 size) external;\r\n\r\n    function notifyChallengeAverted(uint256 size) external;\r\n\r\n    function notifyChallengeSucceeded(address _bidder, uint256 _size) external returns (address, uint256, uint256, uint32);\r\n\r\n}"
    },
    "contracts/interface/IPositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IPositionFactory {\r\n    function createNewPosition(\r\n        address _owner,\r\n        address _zchf,\r\n        address _collateral,\r\n        uint256 _minCollateral,\r\n        uint256 _initialLimit,\r\n        uint256 _initPeriodSeconds,\r\n        uint256 _duration,\r\n        uint64 _challengePeriod,\r\n        uint32 _annualInterestPPM,\r\n        uint256 _liqPrice,\r\n        uint32 _reserve\r\n    ) external returns (address);\r\n\r\n    function clonePosition(address _existing) external returns (address);\r\n}\r\n"
    },
    "contracts/interface/IReserve.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\ninterface IReserve is IERC20 {\r\n   function invest(uint256 amount, uint256 expected) external returns (uint256);\r\n   function checkQualified(address sender, address[] calldata helpers) external view;\r\n}"
    },
    "contracts/MintingHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interface/IERC20.sol\";\r\nimport \"./interface/IReserve.sol\";\r\nimport \"./interface/IFrankencoin.sol\";\r\nimport \"./interface/IPosition.sol\";\r\nimport \"./interface/IPositionFactory.sol\";\r\n\r\n/**\r\n * @title Minting Hub\r\n * @notice The central hub for creating, cloning and challenging collateralized Frankencoin positions.\r\n * @dev Only one instance of this contract is required, whereas every new position comes with a new position\r\n * contract. Pending challenges are stored as structs in an array.\r\n */\r\ncontract MintingHub {\r\n    /**\r\n     * @notice Irrevocable fee in ZCHF when proposing a new position (but not when cloning an existing one).\r\n     */\r\n    uint256 public constant OPENING_FEE = 1000 * 10 ** 18;\r\n\r\n    /**\r\n     * @notice The challenger reward in parts per million (ppm) relative to the challenged amount, whereas\r\n     * challenged amount if defined as the challenged collateral amount times the liquidation price.\r\n     */\r\n    uint32 public constant CHALLENGER_REWARD = 20000; // 2%\r\n\r\n    IPositionFactory private immutable POSITION_FACTORY; // position contract to clone\r\n\r\n    IFrankencoin public immutable zchf; // currency\r\n    Challenge[] public challenges; // list of open challenges\r\n\r\n    /**\r\n     * @notice Map to remember pending postponed collateral returns.\r\n     * @dev It maps collateral => beneficiary => amount.\r\n     */\r\n    mapping(address collateral => mapping(address owner => uint256 amount)) public pendingReturns;\r\n\r\n    struct Challenge {\r\n        address challenger; // the address from which the challenge was initiated\r\n        uint64 start; // the start of the challenge\r\n        IPosition position; // the position that was challenged\r\n        uint256 size; // how much collateral the challenger provided\r\n    }\r\n\r\n    event PositionOpened(\r\n        address indexed owner,\r\n        address indexed position,\r\n        address zchf,\r\n        address collateral,\r\n        uint256 price\r\n    );\r\n    event ChallengeStarted(address indexed challenger, address indexed position, uint256 size, uint256 number);\r\n    event ChallengeAverted(address indexed position, uint256 number, uint256 size);\r\n    event ChallengeSucceeded(\r\n        address indexed position,\r\n        uint256 number,\r\n        uint256 bid,\r\n        uint256 acquiredCollateral,\r\n        uint256 challengeSize\r\n    );\r\n    event PostPonedReturn(address collateral, address indexed beneficiary, uint256 amount);\r\n\r\n    error UnexpectedPrice();\r\n    error InvalidPos();\r\n\r\n    modifier validPos(address position) {\r\n        if (zchf.getPositionParent(position) != address(this)) revert InvalidPos();\r\n        _;\r\n    }\r\n\r\n    constructor(address _zchf, address _factory) {\r\n        zchf = IFrankencoin(_zchf);\r\n        POSITION_FACTORY = IPositionFactory(_factory);\r\n    }\r\n\r\n    function openPositionOneWeek(\r\n        address _collateralAddress,\r\n        uint256 _minCollateral,\r\n        uint256 _initialCollateral,\r\n        uint256 _mintingMaximum,\r\n        uint256 _expirationSeconds,\r\n        uint64 _challengeSeconds,\r\n        uint32 _annualInterestPPM,\r\n        uint256 _liqPrice,\r\n        uint32 _reservePPM\r\n    ) public returns (address) {\r\n        return\r\n            openPosition(\r\n                _collateralAddress,\r\n                _minCollateral,\r\n                _initialCollateral,\r\n                _mintingMaximum,\r\n                7 days,\r\n                _expirationSeconds,\r\n                _challengeSeconds,\r\n                _annualInterestPPM,\r\n                _liqPrice,\r\n                _reservePPM\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice Open a collateralized loan position. See also https://docs.frankencoin.com/positions/open .\r\n     * @dev For a successful call, you must set an allowance for the collateral token, allowing\r\n     * the minting hub to transfer the initial collateral amount to the newly created position and to\r\n     * withdraw the fees.\r\n     *\r\n     * @param _collateralAddress        address of collateral token\r\n     * @param _minCollateral     minimum collateral required to prevent dust amounts\r\n     * @param _initialCollateral amount of initial collateral to be deposited\r\n     * @param _mintingMaximum    maximal amount of ZCHF that can be minted by the position owner\r\n     * @param _expirationSeconds position tenor in unit of timestamp (seconds) from 'now'\r\n     * @param _challengeSeconds  challenge period. Longer for less liquid collateral.\r\n     * @param _annualInterestPPM ppm of minted amount that is paid as fee for each year of duration\r\n     * @param _liqPrice          Liquidation price with (36 - token decimals) decimals,\r\n     *                           e.g. 18 decimals for an 18 dec collateral, 36 decs for a 0 dec collateral.\r\n     * @param _reservePPM        ppm of minted amount that is locked as borrower's reserve, e.g. 20%\r\n     * @return address           address of created position\r\n     */\r\n    function openPosition(\r\n        address _collateralAddress,\r\n        uint256 _minCollateral,\r\n        uint256 _initialCollateral,\r\n        uint256 _mintingMaximum,\r\n        uint256 _initPeriodSeconds,\r\n        uint256 _expirationSeconds,\r\n        uint64 _challengeSeconds,\r\n        uint32 _annualInterestPPM,\r\n        uint256 _liqPrice,\r\n        uint32 _reservePPM\r\n    ) public returns (address) {\r\n        require(_annualInterestPPM <= 1000000);\r\n        require(CHALLENGER_REWARD <= _reservePPM && _reservePPM <= 1000000);\r\n        require(IERC20(_collateralAddress).decimals() <= 24); // leaves 12 digits for price\r\n        require(_initialCollateral >= _minCollateral, \"must start with min col\");\r\n        require(_minCollateral * _liqPrice >= 5000 ether * 10 ** 18); // must start with at least 5000 ZCHF worth of collateral\r\n        IPosition pos = IPosition(\r\n            POSITION_FACTORY.createNewPosition(\r\n                msg.sender,\r\n                address(zchf),\r\n                _collateralAddress,\r\n                _minCollateral,\r\n                _mintingMaximum,\r\n                _initPeriodSeconds,\r\n                _expirationSeconds,\r\n                _challengeSeconds,\r\n                _annualInterestPPM,\r\n                _liqPrice,\r\n                _reservePPM\r\n            )\r\n        );\r\n        zchf.registerPosition(address(pos));\r\n        zchf.collectProfits(msg.sender, OPENING_FEE);\r\n        IERC20(_collateralAddress).transferFrom(msg.sender, address(pos), _initialCollateral);\r\n\r\n        emit PositionOpened(msg.sender, address(pos), address(zchf), _collateralAddress, _liqPrice);\r\n        return address(pos);\r\n    }\r\n\r\n    /**\r\n     * @notice Clones an existing position and immediately tries to mint the specified amount using the given collateral.\r\n     * @dev This needs an allowance to be set on the collateral contract such that the minting hub can get the collateral.\r\n     */\r\n    function clone(\r\n        address position,\r\n        uint256 _initialCollateral,\r\n        uint256 _initialMint,\r\n        uint256 expiration\r\n    ) public validPos(position) returns (address) {\r\n        IPosition existing = IPosition(position);\r\n        require(expiration <= IPosition(existing.original()).expiration());\r\n        existing.reduceLimitForClone(_initialMint);\r\n        address pos = POSITION_FACTORY.clonePosition(position);\r\n        zchf.registerPosition(pos);\r\n        IPosition(pos).initializeClone(msg.sender, existing.price(), _initialCollateral, _initialMint, expiration);\r\n        existing.collateral().transferFrom(msg.sender, pos, _initialCollateral);\r\n\r\n        emit PositionOpened(\r\n            msg.sender,\r\n            address(pos),\r\n            address(zchf),\r\n            address(IPosition(pos).collateral()),\r\n            IPosition(pos).price()\r\n        );\r\n        return address(pos);\r\n    }\r\n\r\n    /**\r\n     * @notice Launch a challenge (Dutch auction) on a position\r\n     * @param _positionAddr      address of the position we want to challenge\r\n     * @param _collateralAmount  amount of the collateral we want to challenge\r\n     * @param expectedPrice      position.price() to guard against the minter fruntrunning with a price change\r\n     * @return index of the challenge in challenge-array\r\n     */\r\n    function challenge(\r\n        address _positionAddr,\r\n        uint256 _collateralAmount,\r\n        uint256 expectedPrice\r\n    ) external validPos(_positionAddr) returns (uint256) {\r\n        IPosition position = IPosition(_positionAddr);\r\n        if (position.price() != expectedPrice) revert UnexpectedPrice();\r\n        IERC20(position.collateral()).transferFrom(msg.sender, address(this), _collateralAmount);\r\n        uint256 pos = challenges.length;\r\n        challenges.push(Challenge(msg.sender, uint64(block.timestamp), position, _collateralAmount));\r\n        position.notifyChallengeStarted(_collateralAmount);\r\n        emit ChallengeStarted(msg.sender, address(position), _collateralAmount, pos);\r\n        return pos;\r\n    }\r\n\r\n    /**\r\n     * @notice Post a bid in ZCHF given an open challenge.\r\n     *\r\n     * @dev In case that the collateral cannot be transfered back to the challenger (i.e. because the collateral token\r\n     * has a blacklist and the challenger is on it), it is possible to postpone the return of the collateral.\r\n     *\r\n     * @param _challengeNumber  index of the challenge as broadcast in the event\r\n     * @param size              how much of the collateral the caller wants to bid for at most\r\n     *                          (automatically reduced to the available amount)\r\n     * @param postponeCollateralReturn To postpone the return of the collateral to the challenger. Usually false.\r\n     */\r\n    function bid(uint32 _challengeNumber, uint256 size, bool postponeCollateralReturn) external {\r\n        Challenge memory _challenge = challenges[_challengeNumber];\r\n        (uint256 liqPrice, uint64 phase1, uint64 phase2) = _challenge.position.challengeData(_challenge.start);\r\n        size = _challenge.size < size ? _challenge.size : size; // cannot bid for more than the size of the challenge\r\n\r\n        if (block.timestamp <= _challenge.start + phase1) {\r\n            _avertChallenge(_challenge, _challengeNumber, liqPrice, size);\r\n            emit ChallengeAverted(address(_challenge.position), _challengeNumber, size);\r\n        } else {\r\n            _returnChallengerCollateral(_challenge, _challengeNumber, size, postponeCollateralReturn);\r\n            (uint256 transferredCollateral, uint256 offer) = _finishChallenge(\r\n                _challenge,\r\n                liqPrice,\r\n                phase1,\r\n                phase2,\r\n                size\r\n            );\r\n            emit ChallengeSucceeded(address(_challenge.position), _challengeNumber, offer, transferredCollateral, size);\r\n        }\r\n    }\r\n\r\n    function _finishChallenge(\r\n        Challenge memory _challenge,\r\n        uint256 liqPrice,\r\n        uint64 phase1,\r\n        uint64 phase2,\r\n        uint256 size\r\n    ) internal returns (uint256, uint256) {\r\n        // Repayments depend on what was actually minted, whereas bids depend on the available collateral\r\n        (address owner, uint256 collateral, uint256 repayment, uint32 reservePPM) = _challenge\r\n            .position\r\n            .notifyChallengeSucceeded(msg.sender, size);\r\n\r\n        // No overflow possible thanks to invariant (col * price <= limit * 10**18)\r\n        // enforced in Position.setPrice and knowing that collateral <= col.\r\n        uint256 offer = (_calculatePrice(_challenge.start + phase1, phase2, liqPrice) * collateral) / 10 ** 18;\r\n        zchf.transferFrom(msg.sender, address(this), offer); // get money from bidder\r\n        uint256 reward = (offer * CHALLENGER_REWARD) / 1000_000;\r\n        zchf.transfer(_challenge.challenger, reward); // pay out the challenger reward\r\n        uint256 fundsAvailable = offer - reward; // funds available after reward\r\n\r\n        // Example: available funds are 90, repayment is 50, reserve 20%. Then 20%*(90-50)=16 are collected as profits\r\n        // and the remaining 34 are sent to the position owner. If the position owner maxed out debt before the challenge\r\n        // started and the liquidation price was 100, they would be slightly better off as they would get away with 80\r\n        // instead of 40+36 = 76 in this example.\r\n        if (fundsAvailable > repayment) {\r\n            // The excess amount is distributed between the system and the owner using the reserve ratio\r\n            // At this point, we cannot rely on the liquidation price because the challenge might have been started as a\r\n            // response to an unreasonable increase of the liquidation price, such that we have to use this heuristic\r\n            // for excess fund distribution, which make position owners that maxed out their positions slightly better\r\n            // off in comparison to those who did not.\r\n            uint256 profits = reservePPM * (fundsAvailable - repayment) / 1000_000;\r\n            zchf.collectProfits(address(this), profits);\r\n            zchf.transfer(owner, fundsAvailable - repayment - profits);\r\n        } else if (fundsAvailable < repayment) {\r\n            zchf.coverLoss(address(this), repayment - fundsAvailable); // ensure we have enough to pay everything\r\n        }\r\n        zchf.burnWithoutReserve(repayment, reservePPM); // Repay the challenged part, example: 50 ZCHF leading to 10 ZCHf in implicit profits\r\n        return (collateral, offer);\r\n    }\r\n\r\n    function _avertChallenge(Challenge memory _challenge, uint32 number, uint256 liqPrice, uint256 size) internal {\r\n        require(block.timestamp != _challenge.start); // do not allow to avert the challenge in the same transaction, see CS-ZCHF-037\r\n        if (msg.sender == _challenge.challenger) {\r\n            // allow challenger to cancel challenge without paying themselves\r\n        } else {\r\n            zchf.transferFrom(msg.sender, _challenge.challenger, (size * liqPrice) / (10 ** 18));\r\n        }\r\n\r\n        _challenge.position.notifyChallengeAverted(size);\r\n        _challenge.position.collateral().transfer(msg.sender, size);\r\n        if (size < _challenge.size) {\r\n            challenges[number].size = _challenge.size - size;\r\n        } else {\r\n            require(size == _challenge.size);\r\n            delete challenges[number];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Returns 'amount' of the collateral to the challenger and reduces or deletes the relevant challenge.\r\n     */\r\n    function _returnChallengerCollateral(\r\n        Challenge memory _challenge,\r\n        uint32 number,\r\n        uint256 amount,\r\n        bool postpone\r\n    ) internal {\r\n        _returnCollateral(_challenge.position.collateral(), _challenge.challenger, amount, postpone);\r\n        if (_challenge.size == amount) {\r\n            // bid on full amount\r\n            delete challenges[number];\r\n        } else {\r\n            // bid on partial amount\r\n            challenges[number].size -= amount;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates the current Dutch auction price.\r\n     * @dev Starts at the full price at time 'start' and linearly goes to 0 as 'phase2' passes.\r\n     */\r\n    function _calculatePrice(uint64 start, uint64 phase2, uint256 liqPrice) internal view returns (uint256) {\r\n        uint64 timeNow = uint64(block.timestamp);\r\n        if (timeNow <= start) {\r\n            return liqPrice;\r\n        } else if (timeNow >= start + phase2) {\r\n            return 0;\r\n        } else {\r\n            uint256 timeLeft = phase2 - (timeNow - start);\r\n            return (liqPrice / phase2) * timeLeft;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Get the price per unit of the collateral for the given challenge.\r\n     * @dev The price comes with (36-collateral.decimals()) digits, such that multiplying it with the\r\n     * raw collateral amount always yields a price with 36 digits, or 18 digits after dividing by 10**18 again.\r\n     */\r\n    function price(uint32 challengeNumber) public view returns (uint256) {\r\n        Challenge memory _challenge = challenges[challengeNumber];\r\n        if (_challenge.challenger == address(0x0)) {\r\n            return 0;\r\n        } else {\r\n            (uint256 liqPrice, uint64 phase1, uint64 phase2) = _challenge.position.challengeData(_challenge.start);\r\n            return _calculatePrice(_challenge.start + phase1, phase2, liqPrice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Challengers can call this method to withdraw collateral whose return was postponed.\r\n     */\r\n    function returnPostponedCollateral(address collateral, address target) external {\r\n        uint256 amount = pendingReturns[collateral][msg.sender];\r\n        delete pendingReturns[collateral][msg.sender];\r\n        IERC20(collateral).transfer(target, amount);\r\n    }\r\n\r\n    function _returnCollateral(IERC20 collateral, address recipient, uint256 amount, bool postpone) internal {\r\n        if (postpone) {\r\n            // Postponing helps in case the challenger was blacklisted or otherwise cannot receive at the moment.\r\n            pendingReturns[address(collateral)][recipient] += amount;\r\n            emit PostPonedReturn(address(collateral), recipient, amount);\r\n        } else {\r\n            collateral.transfer(recipient, amount); // return the challenger's collateral\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Position.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./utils/Ownable.sol\";\r\nimport \"./utils/MathUtil.sol\";\r\n\r\nimport \"./interface/IERC20.sol\";\r\nimport \"./interface/IPosition.sol\";\r\nimport \"./interface/IReserve.sol\";\r\nimport \"./interface/IFrankencoin.sol\";\r\n\r\n/**\r\n * @title Position\r\n * @notice A collateralized minting position.\r\n */\r\ncontract Position is Ownable, IPosition, MathUtil {\r\n    /**\r\n     * @notice Note that this contract is intended to be cloned. All clones will share the same values for\r\n     * the constant and immutable fields, but have their own values for the other fields.\r\n     */\r\n\r\n    /**\r\n     * @notice The zchf price per unit of the collateral below which challenges succeed, (36 - collateral.decimals) decimals\r\n     */\r\n    uint256 public price;\r\n\r\n    /**\r\n     * @notice Net minted amount, including reserve.\r\n     */\r\n    uint256 public minted;\r\n\r\n    /**\r\n     * @notice Amount of the collateral that is currently under a challenge.\r\n     * Used to figure out whether there are pending challenges.\r\n     */\r\n    uint256 public challengedAmount;\r\n\r\n    /**\r\n     * @notice Challenge period in seconds.\r\n     */\r\n    uint64 public immutable challengePeriod;\r\n\r\n    /**\r\n     * @notice End of the latest cooldown. If this is in the future, minting is suspended.\r\n     */\r\n    uint256 public cooldown;\r\n\r\n    /**\r\n     * @notice How much can be minted at most.\r\n     */\r\n    uint256 public limit;\r\n\r\n    /**\r\n     * @notice Timestamp when minting can start and the position no longer denied.\r\n     */\r\n    uint256 public immutable start;\r\n\r\n    /**\r\n     * @notice Timestamp of the expiration of the position. After expiration, challenges cannot be averted\r\n     * any more. This is also the basis for fee calculations.\r\n     */\r\n    uint256 public expiration;\r\n\r\n    /**\r\n     * @notice The original position to help identifying clones.\r\n     */\r\n    address public immutable original;\r\n\r\n    /**\r\n     * @notice Pointer to the minting hub.\r\n     */\r\n    address public immutable hub;\r\n\r\n    /**\r\n     * @notice The Frankencoin contract.\r\n     */\r\n    IFrankencoin public immutable zchf;\r\n\r\n    /**\r\n     * @notice The collateral token.\r\n     */\r\n    IERC20 public immutable override collateral;\r\n\r\n    /**\r\n     * @notice Minimum acceptable collateral amount to prevent dust.\r\n     */\r\n    uint256 public immutable override minimumCollateral;\r\n\r\n    /**\r\n     * @notice Always pay interest for at least four weeks.\r\n     */\r\n    uint256 private constant MIN_INTEREST_DURATION = 4 weeks;\r\n\r\n    /**\r\n     * @notice The interest in parts per million per year that is deducted when minting Frankencoins.\r\n     * To be paid upfront.\r\n     */\r\n    uint32 public immutable annualInterestPPM;\r\n\r\n    /**\r\n     * @notice The reserve contribution in parts per million of the minted amount.\r\n     */\r\n    uint32 public immutable reserveContribution;\r\n\r\n    event MintingUpdate(uint256 collateral, uint256 price, uint256 minted, uint256 limit);\r\n    event PositionDenied(address indexed sender, string message); // emitted if closed by governance\r\n\r\n    error InsufficientCollateral();\r\n    error TooLate();\r\n    error RepaidTooMuch(uint256 excess);\r\n    error LimitExceeded();\r\n    error ChallengeTooSmall();\r\n    error Expired();\r\n    error Hot();\r\n    error Challenged();\r\n    error NotHub();\r\n\r\n    modifier alive() {\r\n        if (block.timestamp >= expiration) revert Expired();\r\n        _;\r\n    }\r\n\r\n    modifier noCooldown() {\r\n        if (block.timestamp <= cooldown) revert Hot();\r\n        _;\r\n    }\r\n\r\n    modifier noChallenge() {\r\n        if (challengedAmount > 0) revert Challenged();\r\n        _;\r\n    }\r\n\r\n    modifier onlyHub() {\r\n        if (msg.sender != address(hub)) revert NotHub();\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev See MintingHub.openPosition\r\n     */\r\n    constructor(\r\n        address _owner,\r\n        address _hub,\r\n        address _zchf,\r\n        address _collateral,\r\n        uint256 _minCollateral,\r\n        uint256 _initialLimit,\r\n        uint256 _initPeriod,\r\n        uint256 _duration,\r\n        uint64 _challengePeriod,\r\n        uint32 _annualInterestPPM,\r\n        uint256 _liqPrice,\r\n        uint32 _reservePPM\r\n    ) {\r\n        require(_initPeriod >= 3 days); // must be at least three days, recommended to use higher values\r\n        _setOwner(_owner);\r\n        original = address(this);\r\n        hub = _hub;\r\n        zchf = IFrankencoin(_zchf);\r\n        collateral = IERC20(_collateral);\r\n        annualInterestPPM = _annualInterestPPM;\r\n        reserveContribution = _reservePPM;\r\n        minimumCollateral = _minCollateral;\r\n        challengePeriod = _challengePeriod;\r\n        start = block.timestamp + _initPeriod; // at least three days time to deny the position\r\n        cooldown = start;\r\n        expiration = start + _duration;\r\n        limit = _initialLimit;\r\n        _setPrice(_liqPrice);\r\n    }\r\n\r\n    /**\r\n     * @notice Method to initialize a freshly created clone. It is the responsibility of the creator to make sure this is only\r\n     * called once and to call reduceLimitForClone on the original position before initializing the clone.\r\n     */\r\n    function initializeClone(\r\n        address owner,\r\n        uint256 _price,\r\n        uint256 _coll,\r\n        uint256 _initialMint,\r\n        uint256 expirationTime\r\n    ) external onlyHub {\r\n        if (_coll < minimumCollateral) revert InsufficientCollateral();\r\n        uint256 impliedPrice = (_initialMint * ONE_DEC18) / _coll;\r\n        _initialMint = (impliedPrice * _coll) / ONE_DEC18; // to cancel potential rounding errors\r\n        if (impliedPrice > _price) revert InsufficientCollateral();\r\n        _setOwner(owner);\r\n        limit = _initialMint;\r\n        expiration = expirationTime;\r\n        _setPrice(impliedPrice);\r\n        _mint(owner, _initialMint, _coll);\r\n    }\r\n\r\n    function limitForClones() public view returns (uint256) {\r\n        uint256 backedLimit = (_collateralBalance() * price) / ONE_DEC18;\r\n        if (backedLimit >= limit) {\r\n            return 0;\r\n        } else {\r\n            // due to invariants, this is always below (limit - minted)\r\n            return limit - backedLimit;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Adjust this position's limit to allow a clone to mint its own Frankencoins.\r\n     * Invariant: global limit stays the same.\r\n     *\r\n     * Cloning a position is only allowed if the position is not challenged, not expired and not in cooldown.\r\n     */\r\n    function reduceLimitForClone(uint256 mint_) external noChallenge noCooldown alive onlyHub {\r\n        if (mint_ > limitForClones()) revert LimitExceeded();\r\n        limit -= mint_;\r\n    }\r\n\r\n    /**\r\n     * @notice Qualified pool share holders can call this method to immediately expire a freshly proposed position.\r\n     */\r\n    function deny(address[] calldata helpers, string calldata message) external {\r\n        if (block.timestamp >= start) revert TooLate();\r\n        IReserve(zchf.reserve()).checkQualified(msg.sender, helpers);\r\n        _close(); // since expiration is immutable, we put it under eternal cooldown\r\n        emit PositionDenied(msg.sender, message);\r\n    }\r\n\r\n    function _close() internal {\r\n        cooldown = type(uint256).max;\r\n    }\r\n\r\n    function isClosed() public view returns (bool) {\r\n        return cooldown == type(uint256).max;\r\n    }\r\n\r\n    /**\r\n     * @notice This is how much the minter can actually use when minting ZCHF, with the rest being used\r\n     * assigned to the minter reserve or (if applicable) fees.\r\n     */\r\n    function getUsableMint(uint256 totalMint, bool afterFees) external view returns (uint256) {\r\n        if (afterFees) {\r\n            return (totalMint * (1000_000 - reserveContribution - calculateCurrentFee())) / 1000_000;\r\n        } else {\r\n            return (totalMint * (1000_000 - reserveContribution)) / 1000_000;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice \"All in one\" function to adjust the outstanding amount of ZCHF, the collateral amount,\r\n     * and the price in one transaction.\r\n     */\r\n    function adjust(uint256 newMinted, uint256 newCollateral, uint256 newPrice) external onlyOwner {\r\n        uint256 colbal = _collateralBalance();\r\n        if (newCollateral > colbal) {\r\n            collateral.transferFrom(msg.sender, address(this), newCollateral - colbal);\r\n        }\r\n        // Must be called after collateral deposit, but before withdrawal\r\n        if (newMinted < minted) {\r\n            zchf.burnFromWithReserve(msg.sender, minted - newMinted, reserveContribution);\r\n            minted = newMinted;\r\n        }\r\n        if (newCollateral < colbal) {\r\n            withdrawCollateral(msg.sender, colbal - newCollateral);\r\n        }\r\n        // Must be called after collateral withdrawal\r\n        if (newMinted > minted) {\r\n            mint(msg.sender, newMinted - minted);\r\n        }\r\n        if (newPrice != price) {\r\n            adjustPrice(newPrice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allows the position owner to adjust the liquidation price as long as there is no pending challenge.\r\n     * Lowering the liquidation price can be done with immediate effect, given that there is enough collateral.\r\n     * Increasing the liquidation price triggers a cooldown period of 3 days, during which minting is suspended.\r\n     */\r\n    function adjustPrice(uint256 newPrice) public onlyOwner noChallenge {\r\n        if (newPrice > price) {\r\n            _restrictMinting(3 days);\r\n        } else {\r\n            _checkCollateral(_collateralBalance(), newPrice);\r\n        }\r\n        _setPrice(newPrice);\r\n        emit MintingUpdate(_collateralBalance(), price, minted, limit);\r\n    }\r\n\r\n    function _setPrice(uint256 newPrice) internal {\r\n        require(newPrice * minimumCollateral <= limit * ONE_DEC18); // sanity check\r\n        price = newPrice;\r\n    }\r\n\r\n    function _collateralBalance() internal view returns (uint256) {\r\n        return IERC20(collateral).balanceOf(address(this));\r\n    }\r\n\r\n    /**\r\n     * @notice Mint ZCHF as long as there is no open challenge, the position is not subject to a cooldown,\r\n     * and there is sufficient collateral.\r\n     */\r\n    function mint(address target, uint256 amount) public onlyOwner noChallenge noCooldown alive {\r\n        _mint(target, amount, _collateralBalance());\r\n    }\r\n\r\n    function calculateCurrentFee() public view returns (uint32) {\r\n        uint256 exp = expiration;\r\n        uint256 time = block.timestamp < start ? start : block.timestamp;\r\n        uint256 timePassed = time >= exp - MIN_INTEREST_DURATION ? MIN_INTEREST_DURATION : exp - time;\r\n        // Time resolution is in the range of minutes for typical interest rates.\r\n        return uint32((timePassed * annualInterestPPM) / 365 days);\r\n    }\r\n\r\n    function _mint(address target, uint256 amount, uint256 collateral_) internal {\r\n        if (minted + amount > limit) revert LimitExceeded();\r\n        zchf.mintWithReserve(target, amount, reserveContribution, calculateCurrentFee());\r\n        minted += amount;\r\n\r\n        _checkCollateral(collateral_, price);\r\n        emit MintingUpdate(_collateralBalance(), price, minted, limit);\r\n    }\r\n\r\n    function _restrictMinting(uint256 period) internal {\r\n        uint256 horizon = block.timestamp + period;\r\n        if (horizon > cooldown) {\r\n            cooldown = horizon;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Repay some ZCHF. If too much is repaid, the call fails.\r\n     * It is possible to repay while there are challenges, but the collateral is locked until all is clear again.\r\n     *\r\n     * The repaid amount should fulfill the following equation in order to close the position,\r\n     * i.e. bring the minted amount to 0:\r\n     * minted = amount + zchf.calculateAssignedReserve(amount, reservePPM)\r\n     *\r\n     * Under normal circumstances, this implies:\r\n     * amount = minted * (1000000 - reservePPM)\r\n     *\r\n     * E.g. if minted is 50 and reservePPM is 200000, it is necessary to repay 40 to be able to close the position.\r\n     */\r\n    function repay(uint256 amount) public {\r\n        IERC20(zchf).transferFrom(msg.sender, address(this), amount);\r\n        uint256 actuallyRepaid = IFrankencoin(zchf).burnWithReserve(amount, reserveContribution);\r\n        _notifyRepaid(actuallyRepaid);\r\n        emit MintingUpdate(_collateralBalance(), price, minted, limit);\r\n    }\r\n\r\n    function _notifyRepaid(uint256 amount) internal {\r\n        if (amount > minted) revert RepaidTooMuch(amount - minted);\r\n        minted -= amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw any ERC20 token that might have ended up on this address.\r\n     * Withdrawing collateral is subject to the same restrictions as withdrawCollateral(...).\r\n     */\r\n    function withdraw(address token, address target, uint256 amount) external onlyOwner {\r\n        if (token == address(collateral)) {\r\n            withdrawCollateral(target, amount);\r\n        } else {\r\n            uint256 balance = _collateralBalance();\r\n            IERC20(token).transfer(target, amount);\r\n            require(balance == _collateralBalance()); // guard against double-entry-point tokens\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw collateral from the position up to the extent that it is still well collateralized afterwards.\r\n     * Not possible as long as there is an open challenge or the contract is subject to a cooldown.\r\n     *\r\n     * Withdrawing collateral below the minimum collateral amount formally closes the position.\r\n     */\r\n    function withdrawCollateral(address target, uint256 amount) public onlyOwner noChallenge {\r\n        if (block.timestamp <= cooldown && !isClosed()) revert Hot();\r\n        uint256 balance = _withdrawCollateral(target, amount);\r\n        _checkCollateral(balance, price);\r\n        if (balance < minimumCollateral && balance > 0) revert InsufficientCollateral(); // Prevent dust amounts\r\n    }\r\n\r\n    function _withdrawCollateral(address target, uint256 amount) internal returns (uint256) {\r\n        if (amount > 0) {\r\n            // Some weird tokens fail when trying to transfer 0 amounts\r\n            IERC20(collateral).transfer(target, amount);\r\n        }\r\n        uint256 balance = _collateralBalance();\r\n        _considerClose(balance);\r\n        emit MintingUpdate(balance, price, minted, limit);\r\n        return balance;\r\n    }\r\n\r\n    function _considerClose(uint256 collateralBalance) internal {\r\n        if (collateralBalance < minimumCollateral && challengedAmount == 0) {\r\n            // This leaves a slightly unsatisfying possibility open: if the withdrawal happens due to a successful\r\n            // challenge, there might be a small amount of collateral left that is not withheld in case there are no\r\n            // other pending challenges. The only way to cleanly solve this would be to have two distinct cooldowns,\r\n            // one for minting and one for withdrawals.\r\n            _close();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice This invariant must always hold and must always be checked when any of the three\r\n     * variables change in an adverse way.\r\n     */\r\n    function _checkCollateral(uint256 collateralReserve, uint256 atPrice) internal view {\r\n        if (collateralReserve * atPrice < minted * ONE_DEC18) revert InsufficientCollateral();\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the liquidation price and the durations for phase1 and phase2 of the challenge.\r\n     * Both phases are usually of equal duration, but near expiration, phase one is adjusted such that\r\n     * it cannot last beyond the expiration date of the position.\r\n     */\r\n    function challengeData(uint256 challengeStart) external view returns (uint256 liqPrice, uint64 phase1, uint64 phase2) {\r\n        uint256 timeToExpiration = challengeStart >= expiration ? 0 : expiration - challengeStart;\r\n        return (price, uint64(_min(timeToExpiration, challengePeriod)), challengePeriod);\r\n    }\r\n\r\n    function notifyChallengeStarted(uint256 size) external onlyHub {\r\n        // Require minimum size. Collateral balance can be below minimum if it was partially challenged before.\r\n        if (size < minimumCollateral && size < _collateralBalance()) revert ChallengeTooSmall();\r\n        if (size == 0) revert ChallengeTooSmall();\r\n        challengedAmount += size;\r\n    }\r\n\r\n    /**\r\n     * @param size   amount of collateral challenged (dec18)\r\n     */\r\n    function notifyChallengeAverted(uint256 size) external onlyHub {\r\n        challengedAmount -= size;\r\n\r\n        // Don't allow minter to close the position immediately so challenge can be repeated before\r\n        // the owner has a chance to mint more on an undercollateralized position\r\n        _restrictMinting(1 days);\r\n\r\n        // If this was the last open challenge and there is only a dust amount of collateral left, the position should be closed\r\n        _considerClose(_collateralBalance());\r\n    }\r\n\r\n    /**\r\n     * @notice Notifies the position that a challenge was successful.\r\n     * Triggers the payout of the challenged part of the collateral.\r\n     * Everything else is assumed to be handled by the hub.\r\n     *\r\n     * @param _bidder   address of the bidder that receives the collateral\r\n     * @param _size     amount of the collateral bid for\r\n     * @return (position owner, effective challenge size in ZCHF, amount to be repaid, reserve ppm)\r\n     */\r\n    function notifyChallengeSucceeded(\r\n        address _bidder,\r\n        uint256 _size\r\n    ) external onlyHub returns (address, uint256, uint256, uint32) {\r\n        challengedAmount -= _size;\r\n        uint256 colBal = _collateralBalance();\r\n        if (colBal < _size) {\r\n            _size = colBal;\r\n        }\r\n        uint256 repayment = colBal == 0 ? 0 : minted * _size / colBal; // for enormous colBal, this could be rounded to 0, which is ok\r\n        _notifyRepaid(repayment); // we assume the caller takes care of the actual repayment\r\n\r\n        // Give time for additional challenges before the owner can mint again. In particular,\r\n        // the owner might have added collateral only seconds before the challenge ended, preventing a close.\r\n        _restrictMinting(3 days);\r\n        \r\n        _withdrawCollateral(_bidder, _size); // transfer collateral to the bidder and emit update\r\n\r\n        return (owner, _size, repayment, reserveContribution);\r\n    }\r\n}\r\n"
    },
    "contracts/PositionFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Position.sol\";\r\nimport \"./interface/IFrankencoin.sol\";\r\n\r\ncontract PositionFactory {\r\n    /**\r\n     * Create a completely new position in a newly deployed contract.\r\n     * Must be called through minting hub to be recognized as valid position.\r\n     */\r\n    function createNewPosition(\r\n        address _owner,\r\n        address _zchf,\r\n        address _collateral,\r\n        uint256 _minCollateral,\r\n        uint256 _initialLimit,\r\n        uint256 _initPeriod,\r\n        uint256 _duration,\r\n        uint64 _challengePeriod,\r\n        uint32 _annualInterestPPM,\r\n        uint256 _liqPrice,\r\n        uint32 _reserve\r\n    ) external returns (address) {\r\n        return\r\n            address(\r\n                new Position(\r\n                    _owner,\r\n                    msg.sender,\r\n                    _zchf,\r\n                    _collateral,\r\n                    _minCollateral,\r\n                    _initialLimit,\r\n                    _initPeriod,\r\n                    _duration,\r\n                    _challengePeriod,\r\n                    _annualInterestPPM,\r\n                    _liqPrice,\r\n                    _reserve\r\n                )\r\n            );\r\n    }\r\n\r\n    /**\r\n     * @notice clone an existing position. This can be a clone of another clone,\r\n     * or an original position.\r\n     * @param _existing address of the position we want to clone\r\n     * @return address of the newly created clone position\r\n     */\r\n    function clonePosition(address _existing) external returns (address) {\r\n        Position existing = Position(_existing);\r\n        Position clone = Position(_createClone(existing.original()));\r\n        return address(clone);\r\n    }\r\n\r\n    // github.com/optionality/clone-factory/blob/32782f82dfc5a00d103a7e61a17a5dedbd1e8e9d/contracts/CloneFactory.sol\r\n    function _createClone(address target) internal returns (address result) {\r\n        bytes20 targetBytes = bytes20(target);\r\n        assembly {\r\n            let clone := mload(0x40)\r\n            mstore(clone, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000000000000000000000)\r\n            mstore(add(clone, 0x14), targetBytes)\r\n            mstore(add(clone, 0x28), 0x5af43d82803e903d91602b57fd5bf30000000000000000000000000000000000)\r\n            result := create(0, clone, 0x37)\r\n        }\r\n        require(result != address(0), \"ERC1167: create failed\");\r\n    }\r\n}\r\n"
    },
    "contracts/StablecoinBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interface/IERC20.sol\";\r\nimport \"./interface/IERC677Receiver.sol\";\r\nimport \"./interface/IFrankencoin.sol\";\r\n\r\n/**\r\n * @title Stable Coin Bridge\r\n * @notice A minting contract for another Swiss franc stablecoin ('source stablecoin') that we trust.\r\n * @author Frankencoin\r\n */\r\ncontract StablecoinBridge {\r\n    IERC20 public immutable chf; // the source stablecoin\r\n    IFrankencoin public immutable zchf; // the Frankencoin\r\n\r\n    /**\r\n     * @notice The time horizon after which this bridge expires and needs to be replaced by a new contract.\r\n     */\r\n    uint256 public immutable horizon;\r\n\r\n    /**\r\n     * The maximum amount of outstanding converted source stablecoins.\r\n     */\r\n    uint256 public immutable limit;\r\n    uint256 public minted;\r\n\r\n    error Limit(uint256 amount, uint256 limit);\r\n    error Expired(uint256 time, uint256 expiration);\r\n    error UnsupportedToken(address token);\r\n\r\n    constructor(address other, address zchfAddress, uint256 limit_) {\r\n        chf = IERC20(other);\r\n        zchf = IFrankencoin(zchfAddress);\r\n        horizon = block.timestamp + 52 weeks;\r\n        limit = limit_;\r\n        minted = 0;\r\n    }\r\n\r\n    /**\r\n     * @notice Convenience method for mint(msg.sender, amount)\r\n     */\r\n    function mint(uint256 amount) external {\r\n        mintTo(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Mint the target amount of Frankencoins, taking the equal amount of source coins from the sender.\r\n     * @dev This only works if an allowance for the source coins has been set and the caller has enough of them.\r\n     */\r\n    function mintTo(address target, uint256 amount) public {\r\n        chf.transferFrom(msg.sender, address(this), amount);\r\n        _mint(target, amount);\r\n    }\r\n\r\n    function _mint(address target, uint256 amount) internal {\r\n        if (block.timestamp > horizon) revert Expired(block.timestamp, horizon);\r\n        zchf.mint(target, amount);\r\n        minted += amount;\r\n        if (minted > limit) revert Limit(amount, limit);\r\n    }\r\n\r\n    /**\r\n     * @notice Convenience method for burnAndSend(msg.sender, amount)\r\n     */\r\n    function burn(uint256 amount) external {\r\n        _burn(msg.sender, msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn the indicated amount of Frankencoin and send the same number of source coin to the caller.\r\n     */\r\n    function burnAndSend(address target, uint256 amount) external {\r\n        _burn(msg.sender, target, amount);\r\n    }\r\n\r\n    function _burn(address zchfHolder, address target, uint256 amount) internal {\r\n        zchf.burnFrom(zchfHolder, amount);\r\n        chf.transfer(target, amount);\r\n        minted -= amount;\r\n    }\r\n}\r\n"
    },
    "contracts/test/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard math utilities missing in the Solidity language.\r\n */\r\nlibrary Math {\r\n    enum Rounding {\r\n        Down, // Toward negative infinity\r\n        Up, // Toward infinity\r\n        Zero // Toward zero\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the largest of two numbers.\r\n     */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two numbers.\r\n     */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two numbers. The result is rounded towards\r\n     * zero.\r\n     */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow.\r\n        return (a & b) + (a ^ b) / 2;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the ceiling of the division of two numbers.\r\n     *\r\n     * This differs from standard division with `/` in that it rounds up instead\r\n     * of rounding down.\r\n     */\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b - 1) / b can overflow on addition, so we distribute.\r\n        return a == 0 ? 0 : (a - 1) / b + 1;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\r\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\r\n     * with further edits by Uniswap Labs also under MIT license.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\r\n        unchecked {\r\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\r\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\r\n            // variables such that product = prod1 * 2^256 + prod0.\r\n            uint256 prod0; // Least significant 256 bits of the product\r\n            uint256 prod1; // Most significant 256 bits of the product\r\n            assembly {\r\n                let mm := mulmod(x, y, not(0))\r\n                prod0 := mul(x, y)\r\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\r\n            }\r\n\r\n            // Handle non-overflow cases, 256 by 256 division.\r\n            if (prod1 == 0) {\r\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\r\n                // The surrounding unchecked block does not change this fact.\r\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\r\n                return prod0 / denominator;\r\n            }\r\n\r\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\r\n            require(denominator > prod1, \"Math: mulDiv overflow\");\r\n\r\n            ///////////////////////////////////////////////\r\n            // 512 by 256 division.\r\n            ///////////////////////////////////////////////\r\n\r\n            // Make division exact by subtracting the remainder from [prod1 prod0].\r\n            uint256 remainder;\r\n            assembly {\r\n                // Compute remainder using mulmod.\r\n                remainder := mulmod(x, y, denominator)\r\n\r\n                // Subtract 256 bit number from 512 bit number.\r\n                prod1 := sub(prod1, gt(remainder, prod0))\r\n                prod0 := sub(prod0, remainder)\r\n            }\r\n\r\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\r\n            // See https://cs.stackexchange.com/q/138556/92363.\r\n\r\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\r\n            uint256 twos = denominator & (~denominator + 1);\r\n            assembly {\r\n                // Divide denominator by twos.\r\n                denominator := div(denominator, twos)\r\n\r\n                // Divide [prod1 prod0] by twos.\r\n                prod0 := div(prod0, twos)\r\n\r\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\r\n                twos := add(div(sub(0, twos), twos), 1)\r\n            }\r\n\r\n            // Shift in bits from prod1 into prod0.\r\n            prod0 |= prod1 * twos;\r\n\r\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\r\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\r\n            // four bits. That is, denominator * inv = 1 mod 2^4.\r\n            uint256 inverse = (3 * denominator) ^ 2;\r\n\r\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\r\n            // in modular arithmetic, doubling the correct bits in each step.\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\r\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\r\n\r\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\r\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\r\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\r\n            // is no longer required.\r\n            result = prod0 * inverse;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\r\n     */\r\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\r\n        uint256 result = mulDiv(x, y, denominator);\r\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\r\n     *\r\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\r\n     */\r\n    function sqrt(uint256 a) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\r\n        //\r\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\r\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\r\n        //\r\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\r\n        //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\r\n        //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\r\n        //\r\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\r\n        uint256 result = 1 << (log2(a) >> 1);\r\n\r\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\r\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\r\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\r\n        // into the expected uint128 result.\r\n        unchecked {\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            result = (result + a / result) >> 1;\r\n            return min(result, a / result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Calculates sqrt(a), following the selected rounding direction.\r\n     */\r\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = sqrt(a);\r\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 128;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 64;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 32;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 16;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                value >>= 8;\r\n                result += 8;\r\n            }\r\n            if (value >> 4 > 0) {\r\n                value >>= 4;\r\n                result += 4;\r\n            }\r\n            if (value >> 2 > 0) {\r\n                value >>= 2;\r\n                result += 2;\r\n            }\r\n            if (value >> 1 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log2(value);\r\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >= 10 ** 64) {\r\n                value /= 10 ** 64;\r\n                result += 64;\r\n            }\r\n            if (value >= 10 ** 32) {\r\n                value /= 10 ** 32;\r\n                result += 32;\r\n            }\r\n            if (value >= 10 ** 16) {\r\n                value /= 10 ** 16;\r\n                result += 16;\r\n            }\r\n            if (value >= 10 ** 8) {\r\n                value /= 10 ** 8;\r\n                result += 8;\r\n            }\r\n            if (value >= 10 ** 4) {\r\n                value /= 10 ** 4;\r\n                result += 4;\r\n            }\r\n            if (value >= 10 ** 2) {\r\n                value /= 10 ** 2;\r\n                result += 2;\r\n            }\r\n            if (value >= 10 ** 1) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log10(value);\r\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, rounded down, of a positive value.\r\n     * Returns 0 if given 0.\r\n     *\r\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\r\n     */\r\n    function log256(uint256 value) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        unchecked {\r\n            if (value >> 128 > 0) {\r\n                value >>= 128;\r\n                result += 16;\r\n            }\r\n            if (value >> 64 > 0) {\r\n                value >>= 64;\r\n                result += 8;\r\n            }\r\n            if (value >> 32 > 0) {\r\n                value >>= 32;\r\n                result += 4;\r\n            }\r\n            if (value >> 16 > 0) {\r\n                value >>= 16;\r\n                result += 2;\r\n            }\r\n            if (value >> 8 > 0) {\r\n                result += 1;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\r\n     * Returns 0 if given 0.\r\n     */\r\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\r\n        unchecked {\r\n            uint256 result = log256(value);\r\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\r\n        }\r\n    }\r\n}"
    },
    "contracts/test/MintingHubTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Strings.sol\";\r\nimport \"./TestToken.sol\";\r\nimport \"../Equity.sol\";\r\nimport \"../utils/Ownable.sol\";\r\nimport \"../Position.sol\";\r\nimport \"../MintingHub.sol\";\r\nimport \"../StablecoinBridge.sol\";\r\nimport \"../interface/IPosition.sol\";\r\nimport \"../interface/IReserve.sol\";\r\nimport \"../interface/IFrankencoin.sol\";\r\nimport \"../interface/IERC20.sol\";\r\n\r\ncontract MintingHubTest {\r\n    MintingHub hub;\r\n    StablecoinBridge swap;\r\n\r\n    IERC20 xchf;\r\n    TestToken col;\r\n    IFrankencoin zchf;\r\n\r\n    User alice;\r\n    User bob;\r\n\r\n    address latestPosition;\r\n    uint256 latestChallenge;\r\n\r\n    constructor(address hub_, address swap_) {\r\n        hub = MintingHub(hub_);\r\n        swap = StablecoinBridge(swap_);\r\n        col = new TestToken(\"Some Collateral\", \"COL\", uint8(0));\r\n        xchf = swap.chf();\r\n        zchf = swap.zchf();\r\n        alice = new User(zchf);\r\n        bob = new User(zchf);\r\n        require(zchf.reserve().totalSupply() == 0, Strings.toString(zchf.reserve().totalSupply()));\r\n    }\r\n\r\n    function initiateEquity() public {\r\n        require(zchf.equity() == 1003849100000000000001, Strings.toString(zchf.equity()));\r\n        require(zchf.reserve().totalSupply() == 0, Strings.toString(zchf.reserve().totalSupply()));\r\n        // ensure there is at least 25'000 ZCHF in equity\r\n        bob.obtainFrankencoins(swap, 10000 ether);\r\n        bob.invest(1000 ether);\r\n        require(zchf.reserve().totalSupply() == 1000 ether, Strings.toString(zchf.reserve().totalSupply()));\r\n        bob.invest(9000 ether);\r\n        alice.obtainFrankencoins(swap, 15000 ether);\r\n        alice.invest(15000 ether);\r\n        require(zchf.equity() > 25000 ether, Strings.toString(zchf.equity()));\r\n    }\r\n\r\n    function initiateAndDenyPosition() public {\r\n        alice.obtainFrankencoins(swap, 1000 ether);\r\n        address pos = alice.initiatePosition(col, hub);\r\n        bob.deny(hub, pos);\r\n    }\r\n\r\n    function initiatePosition() public {\r\n        alice.obtainFrankencoins(swap, 1000 ether);\r\n        latestPosition = alice.initiatePosition(col, hub);\r\n        require(col.balanceOf(address(alice)) == 0);\r\n    }\r\n\r\n    function testWithdraw() public {\r\n        alice.testWithdraw(swap, Position(latestPosition));\r\n    }\r\n\r\n    function letAliceMint() public {\r\n        alice.mint(latestPosition, 1); // test small amount to provoke rounding error\r\n        alice.transferOwnership(latestPosition, address(bob));\r\n        uint256 bobbalance = zchf.balanceOf(address(bob));\r\n        bob.mint(latestPosition, 7);\r\n        require(zchf.balanceOf(address(bob)) > bobbalance);\r\n        bob.transferOwnership(latestPosition, address(alice));\r\n        alice.mint(latestPosition, 0);\r\n        alice.mint(latestPosition, 100000 * (10 ** 18) - 8);\r\n        alice.adjustPosition(latestPosition);\r\n        require(Position(latestPosition).minted() == 100000 ether);\r\n    }\r\n\r\n    function letBobMint() public {\r\n        bob.mint(latestPosition, 1);\r\n    }\r\n\r\n    uint256 first;\r\n    uint256 second;\r\n\r\n    function letBobChallengePart1() public {\r\n        col.mint(address(bob), 1300);\r\n\r\n        // three challenges in parallel :)\r\n        first = bob.challenge(hub, latestPosition, 300);\r\n        second = bob.challenge(hub, latestPosition, 400);\r\n        latestChallenge = bob.challenge(hub, latestPosition, 500);\r\n    }\r\n\r\n    function letBobChallengePart2() public returns (uint256) {\r\n        /* alice.avertChallenge(hub, swap, first);\r\n        bob.obtainFrankencoins(swap, 30_000 ether);\r\n        bob.bid(hub, second, 10_000 ether);\r\n        bob.bid(hub, latestChallenge, 20_000 ether);\r\n        (address challenger, , , , , uint256 bid) = hub.challenges(\r\n            latestChallenge\r\n        );\r\n        require(challenger != address(0x0), \"challenge not found\");\r\n        require(bid == 20_000 ether);\r\n        return latestChallenge; */\r\n    }\r\n\r\n    function endChallenges() public {\r\n        uint256 reservesBefore = zchf.balanceOf(address(zchf.reserve())) - zchf.equity();\r\n        // revertWith(\"reserves before \", reservesBefore);  // 21000.000000000000000000\r\n        endChallenge(latestChallenge); // can be absorbed with equity\r\n        uint256 reservesAfter = zchf.balanceOf(address(zchf.reserve())) - zchf.equity();\r\n        require(reservesBefore - reservesAfter == 10000 ether); // latest challenge was 50'000 with 20% reserve\r\n        // revertWith(\"reserves before \", reservesAfter);  // 11000.000000000000000000\r\n        // revertWith(\"reserves before \", zchf.equity());     //  8601.000000000000000003\r\n        // splitAndEnd(latestChallenge - 1);\r\n    }\r\n\r\n    function endChallenge(uint256 challengeNumber) public {\r\n        uint256 equityBefore = zchf.equity();\r\n        (address challenger, uint64 start, IPosition p, uint256 size) = hub.challenges(challengeNumber);\r\n        require(challenger != address(0x0), \"challenge not found\");\r\n        // hub.end(challengeNumber, true);\r\n        User user = challenger == address(bob) ? bob : alice;\r\n        user.reclaimCollateral(hub, p.collateral(), size);\r\n\r\n        /*         uint256 borrowedAmount = 50000 * (10 ** 18);\r\n        uint256 reserve = (borrowedAmount * p.reserveContribution()) / 1000000;\r\n        uint256 reward = (bid * 20000) / 1000000;\r\n        uint256 missing = borrowedAmount + reward - bid - reserve;\r\n        uint256 equityAfter = zchf.equity();\r\n        uint256 assigned = zchf.calculateAssignedReserve(\r\n            1000000,\r\n            uint32(200000)\r\n        );\r\n        if (equityBefore >= missing) {\r\n            string memory message = string(\r\n                abi.encodePacked(\r\n                    Strings.toString(equityBefore),\r\n                    \" \",\r\n                    Strings.toString(equityAfter),\r\n                    \" \",\r\n                    Strings.toString(missing)\r\n                )\r\n            );\r\n            require(equityAfter + missing == equityBefore, message);\r\n        } else {\r\n            // revertWith(\"reserve \", assigned); // 50601000000000000000003\r\n            require(equityAfter == 0, Strings.toString(equityAfter)); // wiped out equity\r\n            require(\r\n                assigned == 0 ||\r\n                    zchf.calculateAssignedReserve(1000000, 200000) < assigned\r\n            );\r\n            // theoretical minter reserve at this point: 3000.000000000000000000, actual: 0\r\n        } */\r\n    }\r\n\r\n    uint256 number;\r\n\r\n    function testExcessiveChallengePart1() public {\r\n        // revertWith(\"reserve \", zchf.balanceOf(address(zchf.reserve()))); // 50601000000000000000003\r\n        Position pos = Position(latestPosition);\r\n        //uint256 minted = pos.minted();\r\n        //        require(minted == 10000 ether, Strings.toString(minted)); // assumes the other tests have been run before\r\n        uint256 collateralLeft = pos.collateral().balanceOf(latestPosition);\r\n        require(collateralLeft == 100, Strings.toString(collateralLeft)); // test assumption\r\n        number = bob.challenge(hub, latestPosition, 101); // challenge more than is left\r\n        //   alice.repay(pos, 5000 ether);\r\n        // require(pos.minted() + 5000 ether == minted);\r\n        // minted is now 9999.999999999999995000\r\n    }\r\n\r\n    function testExcessiveChallengePart2() public {\r\n        bob.avertChallenge(hub, swap, number);\r\n    }\r\n\r\n    function restructure() public {\r\n        address[] memory empty = new address[](0);\r\n        zchf.reserve().checkQualified(address(alice), empty);\r\n        zchf.reserve().checkQualified(address(bob), empty);\r\n        address[] memory list = new address[](1);\r\n        list[0] = address(bob);\r\n        Equity equity = Equity(address(zchf.reserve()));\r\n        uint256 totalVotes = equity.totalVotes();\r\n        uint256 supplyBefore = equity.totalSupply();\r\n        uint256 bobBefore = equity.balanceOf(address(bob));\r\n        alice.restructure(empty, list);\r\n        zchf.reserve().checkQualified(address(alice), empty);\r\n        require(equity.totalVotes() < totalVotes);\r\n        require(equity.balanceOf(address(bob)) == 0);\r\n        uint256 supplyAfter = equity.totalSupply();\r\n        require(supplyAfter == supplyBefore - bobBefore);\r\n        // revertWith(\"Shortfall: \", zchf.minterReserve() - zchf.balanceOf(address(zchf.reserve()))); // 1000000000000000000000\r\n        alice.obtainFrankencoins(swap, 4000 ether);\r\n        alice.invest(4000 ether);\r\n        require(supplyAfter + 1000 ether == equity.totalSupply());\r\n    }\r\n\r\n    // poor man's replacement for console.out in solidity...\r\n    function revertWith(string memory message, uint256 errorNumber) public pure {\r\n        revert(string(abi.encodePacked(message, Strings.toString(errorNumber))));\r\n    }\r\n\r\n    function challengeExpiredPosition() public {\r\n        Position pos = Position(latestPosition);\r\n        require(pos.calculateCurrentFee() == 0);\r\n        require(pos.expiration() < block.timestamp);\r\n        uint256 size = pos.collateral().balanceOf(latestPosition);\r\n        latestChallenge = bob.challenge(hub, latestPosition, size);\r\n        // revertWith(\"col left \", size); // 100\r\n        bob.obtainFrankencoins(swap, 5000 ether);\r\n    }\r\n\r\n    function endLastChallenge() public {\r\n        Position pos = Position(latestPosition);\r\n        // hub.end(latestChallenge, false);\r\n        require(pos.collateral().balanceOf(latestPosition) == 0);\r\n    }\r\n}\r\n\r\ncontract User {\r\n    IFrankencoin zchf;\r\n\r\n    constructor(IFrankencoin zchf_) {\r\n        zchf = zchf_;\r\n    }\r\n\r\n    function obtainFrankencoins(StablecoinBridge bridge, uint256 amount) public {\r\n        TestToken xchf = TestToken(address(bridge.chf()));\r\n        xchf.mint(address(this), amount);\r\n        xchf.approve(address(bridge), amount);\r\n        require(xchf.allowance(address(this), address(bridge)) == amount);\r\n        bridge.mint(amount);\r\n    }\r\n\r\n    function invest(uint256 amount) public {\r\n        zchf.reserve().invest(amount, 0);\r\n    }\r\n\r\n    function transfer(IERC20 token, address target, uint256 amount) public {\r\n        token.transfer(target, amount);\r\n    }\r\n\r\n    function initiatePosition(TestToken col, MintingHub hub) public returns (address) {\r\n        col.mint(address(this), 1001);\r\n        col.approve(address(hub), 1001);\r\n        uint256 balanceBefore = zchf.balanceOf(address(this));\r\n        address pos = hub.openPositionOneWeek(\r\n            address(col),\r\n            100,\r\n            1001,\r\n            1000000 ether,\r\n            100 days,\r\n            1 days,\r\n            25000,\r\n            100 * (10 ** 36),\r\n            200000\r\n        );\r\n        require((balanceBefore - hub.OPENING_FEE()) == zchf.balanceOf(address(this)));\r\n        Position(pos).adjust(0, 1001, 200 * (10 ** 36));\r\n        Position(pos).adjustPrice(100 * (10 ** 36));\r\n        return pos;\r\n    }\r\n\r\n    function transferOwnership(address pos, address newOwner) public {\r\n        Position(pos).transferOwnership(newOwner);\r\n    }\r\n\r\n    function deny(MintingHub, address pos) public {\r\n        address[] memory empty = new address[](0);\r\n        Position(pos).deny(empty, \"not approved\");\r\n    }\r\n\r\n    function adjustPosition(address pos) public {\r\n        Position position = Position(pos);\r\n        uint256 minted = position.minted();\r\n        uint256 col = position.collateral().balanceOf(pos);\r\n        uint256 price = position.price();\r\n        position.adjust(minted - 100, col - 1, price);\r\n        position.collateral().approve(pos, 1);\r\n        position.adjust(minted, col, price);\r\n        require(position.minted() == minted);\r\n        require(position.collateral().balanceOf(pos) == col);\r\n        require(position.price() == price);\r\n    }\r\n\r\n    function repay(Position pos, uint256 amount) public {\r\n        uint256 balanceBefore = zchf.balanceOf(address(this));\r\n        require(balanceBefore >= amount);\r\n        pos.repay(amount);\r\n        require(zchf.balanceOf(address(this)) + amount == balanceBefore);\r\n    }\r\n\r\n    function testWithdraw(StablecoinBridge bridge, Position pos) public {\r\n        IERC20 col = pos.collateral();\r\n        obtainFrankencoins(bridge, 1);\r\n        bridge.zchf().transfer(address(pos), 1);\r\n        uint256 initialBalance = col.balanceOf(address(pos));\r\n        pos.withdraw(address(bridge.zchf()), address(this), 1);\r\n        Position(pos).withdraw(address(col), address(this), 1);\r\n        require(col.balanceOf(address(pos)) == initialBalance - 1);\r\n        require(col.balanceOf(address(this)) == 1);\r\n    }\r\n\r\n    function mint(address pos, uint256 amount) public {\r\n        uint256 balanceBefore = zchf.balanceOf(address(this));\r\n        IPosition(pos).mint(address(this), amount);\r\n        uint256 obtained = zchf.balanceOf(address(this)) - balanceBefore;\r\n        uint256 usable = IPosition(pos).getUsableMint(amount, true);\r\n        require(\r\n            obtained == usable,\r\n            string(abi.encodePacked(Strings.toString(usable), \" should be \", Strings.toString(obtained)))\r\n        );\r\n        uint256 usableBeforeFee = IPosition(pos).getUsableMint(amount, false);\r\n        require(\r\n            usable <= 100 || usableBeforeFee > usable,\r\n            string(\r\n                abi.encodePacked(Strings.toString(usableBeforeFee), \" should be larger than \", Strings.toString(usable))\r\n            )\r\n        );\r\n    }\r\n\r\n    function challenge(MintingHub hub, address pos, uint256 size) public returns (uint256) {\r\n        IERC20 col = IPosition(pos).collateral();\r\n        col.approve(address(hub), size);\r\n        return hub.challenge(pos, size, IPosition(pos).price());\r\n    }\r\n\r\n    function avertChallenge(MintingHub hub, StablecoinBridge swap, uint256 first) public {\r\n        /* {\r\n            (, IPosition p, uint256 size, , , ) = hub.challenges(first);\r\n            uint256 amount = (size * p.price()) / 10 ** 18;\r\n            obtainFrankencoins(swap, amount);\r\n            hub.bid(first, amount, size); // avert challenge\r\n        }\r\n        (address challenger, , , , , ) = hub.challenges(first);\r\n        require(challenger == address(0x0), \"challenge not averted\");\r\n        require(!hub.isChallengeOpen(first)); */\r\n    }\r\n\r\n    function bid(MintingHub hub, uint256 number, uint256 amount) public {\r\n        /*   (, , uint256 size, , , ) = hub.challenges(number);\r\n        hub.bid(number, amount, size);\r\n        require(hub.minBid(number) > amount); // min bid must increase */\r\n    }\r\n\r\n    function reclaimCollateral(MintingHub hub, IERC20 collateral, uint256 expectedAmount) public {\r\n        uint256 balanceBefore = collateral.balanceOf(address(this));\r\n        hub.returnPostponedCollateral(address(collateral), address(this));\r\n        uint256 balanceAfter = collateral.balanceOf(address(this));\r\n        require(balanceBefore + expectedAmount == balanceAfter);\r\n    }\r\n\r\n    function restructure(address[] calldata helpers, address[] calldata addressesToWipe) public {\r\n        Equity(address(zchf.reserve())).restructureCapTable(helpers, addressesToWipe);\r\n    }\r\n}\r\n"
    },
    "contracts/test/MockVOLToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../utils/ERC20.sol\";\r\n\r\ncontract MockVOLToken is ERC20 {\r\n    constructor() ERC20(18) {\r\n        _mint(msg.sender, 1_000_000 * 1e18);\r\n    }\r\n\r\n    function name() external pure override returns (string memory) {\r\n        return \"VOL volatile mock token\";\r\n    }\r\n\r\n    function symbol() external pure override returns (string memory) {\r\n        return \"VOL\";\r\n    }\r\n\r\n    function mint(address _account, uint256 _amount) external {\r\n        _mint(_account, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/test/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Standard signed math utilities missing in the Solidity language.\r\n */\r\nlibrary SignedMath {\r\n    /**\r\n     * @dev Returns the largest of two signed numbers.\r\n     */\r\n    function max(int256 a, int256 b) internal pure returns (int256) {\r\n        return a > b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the smallest of two signed numbers.\r\n     */\r\n    function min(int256 a, int256 b) internal pure returns (int256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the average of two signed numbers without overflow.\r\n     * The result is rounded towards zero.\r\n     */\r\n    function average(int256 a, int256 b) internal pure returns (int256) {\r\n        // Formula from the book \"Hacker's Delight\"\r\n        int256 x = (a & b) + ((a ^ b) >> 1);\r\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the absolute unsigned value of a signed value.\r\n     */\r\n    function abs(int256 n) internal pure returns (uint256) {\r\n        unchecked {\r\n            // must be unchecked in order to support `n = type(int256).min`\r\n            return uint256(n >= 0 ? n : -n);\r\n        }\r\n    }\r\n}"
    },
    "contracts/test/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./Math.sol\";\r\nimport \"./SignedMath.sol\";\r\n\r\n/**\r\n * @dev String operations.\r\n */\r\nlibrary Strings {\r\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\r\n    uint8 private constant _ADDRESS_LENGTH = 20;\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n     */\r\n    function toString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            uint256 length = Math.log10(value) + 1;\r\n            string memory buffer = new string(length);\r\n            uint256 ptr;\r\n            /// @solidity memory-safe-assembly\r\n            assembly {\r\n                ptr := add(buffer, add(32, length))\r\n            }\r\n            while (true) {\r\n                ptr--;\r\n                /// @solidity memory-safe-assembly\r\n                assembly {\r\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\r\n                }\r\n                value /= 10;\r\n                if (value == 0) break;\r\n            }\r\n            return buffer;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(uint256 value) internal pure returns (string memory) {\r\n        unchecked {\r\n            return toHexString(value, Math.log256(value) + 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\r\n     */\r\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(2 * length + 2);\r\n        buffer[0] = \"0\";\r\n        buffer[1] = \"x\";\r\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\r\n            buffer[i] = _SYMBOLS[value & 0xf];\r\n            value >>= 4;\r\n        }\r\n        require(value == 0, \"Strings: hex length insufficient\");\r\n        return string(buffer);\r\n    }\r\n\r\n    /**\r\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\r\n     */\r\n    function toHexString(address addr) internal pure returns (string memory) {\r\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true if the two strings are equal.\r\n     */\r\n    function equal(string memory a, string memory b) internal pure returns (bool) {\r\n        return keccak256(bytes(a)) == keccak256(bytes(b));\r\n    }\r\n}"
    },
    "contracts/test/TestMathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../utils/MathUtil.sol\";\r\n\r\ncontract TestMathUtil is MathUtil {\r\n\r\n    uint256 public result;\r\n\r\n    constructor(){\r\n        result = 1;\r\n    }\r\n\r\n    // make it a transaction so we can measure gas costs in our tests\r\n    function cubicRoot(uint256 a, bool recordResult) external {\r\n        uint256 r = _cubicRoot(a); \r\n        if (recordResult){\r\n            result = r;\r\n        }\r\n    }\r\n\r\n    function calculateShares(uint256 totalShares, uint256 capitalBefore, uint256 investment) external pure returns (uint256) {\r\n        uint256 newTotalShares = _mulD18(totalShares, _cubicRoot(_divD18(capitalBefore + investment, capitalBefore)));\r\n        return newTotalShares - totalShares;\r\n    }\r\n\r\n    function mulD18(uint256 _a, uint256 _b) external pure returns (uint256) {\r\n        return _mulD18(_a, _b);\r\n    }\r\n\r\n    function divD18(uint256 _a, uint256 _b) external pure returns (uint256) {\r\n        return _divD18(_a, _b);\r\n    }\r\n\r\n    function power3(uint256 _x) external pure returns (uint256) {\r\n        return _power3(_x);\r\n    }\r\n}\r\n"
    },
    "contracts/test/TestToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../utils/ERC20.sol\";\r\n\r\ncontract TestToken is ERC20 {\r\n    string public name;\r\n    string public symbol;\r\n\r\n    constructor(\r\n        string memory name_,\r\n        string memory symbol_,\r\n        uint8 dec\r\n    ) ERC20(dec) {\r\n        name = name_;\r\n        symbol = symbol_;\r\n\r\n        _mint(msg.sender, 1_000_000 * 1e18);\r\n    }\r\n\r\n    function mint(address _account, uint256 _amount) external {\r\n        _mint(_account, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/utils/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copied and adjusted from OpenZeppelin\r\n// Adjustments:\r\n// - modifications to support ERC-677\r\n// - removed require messages to save space\r\n// - removed unnecessary require statements\r\n// - removed GSN Context\r\n// - upgraded to 0.8 to drop SafeMath\r\n// - let name() and symbol() be implemented by subclass\r\n// - infinite allowance support, with 2^255 and above considered infinite\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"../interface/IERC20.sol\";\r\nimport \"../interface/IERC677Receiver.sol\";\r\n\r\n/**\r\n * @dev Implementation of the `IERC20` interface.\r\n *\r\n * This implementation is agnostic to the way tokens are created. This means\r\n * that a supply mechanism has to be added in a derived contract using `_mint`.\r\n * For a generic mechanism see `ERC20Mintable`.\r\n *\r\n * *For a detailed writeup see our guide [How to implement supply\r\n * mechanisms](https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226).*\r\n *\r\n * We have followed general OpenZeppelin guidelines: functions revert instead\r\n * of returning `false` on failure. This behavior is nonetheless conventional\r\n * and does not conflict with the expectations of ERC20 applications.\r\n *\r\n * Additionally, an `Approval` event is emitted on calls to `transferFrom`.\r\n * This allows applications to reconstruct the allowance for all accounts just\r\n * by listening to said events. Other implementations of the EIP may not emit\r\n * these events, as it isn't required by the specification.\r\n *\r\n */\r\n\r\nabstract contract ERC20 is IERC20 {\r\n    mapping(address account => uint256 balance) private _balances;\r\n\r\n    mapping(address account => mapping(address spender => uint256 allowance)) private _allowances;\r\n\r\n    uint256 internal constant INFINITY = (1 << 255);\r\n\r\n    uint256 private _totalSupply;\r\n\r\n    uint8 public immutable override decimals;\r\n\r\n    // Copied from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/4139/files#diff-fa792f7d08644eebc519dac2c29b00a54afc4c6a76b9ef3bba56c8401fe674f6\r\n    // Indicates an error related to the current balance of a sender. Used in transfers.\r\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\r\n    // Indicates a failure with the spenders allowance. Used in transfers.\r\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\r\n\r\n    constructor(uint8 _decimals) {\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.totalSupply`.\r\n     */\r\n    function totalSupply() public view override returns (uint256) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.balanceOf`.\r\n     */\r\n    function balanceOf(address account) public view override returns (uint256) {\r\n        return _balances[account];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transfer`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `recipient` cannot be the zero address.\r\n     * - the caller must have a balance of at least `amount`.\r\n     */\r\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\r\n        _transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.allowance`.\r\n     */\r\n    function allowance(address owner, address spender) external view override returns (uint256) {\r\n        return _allowance(owner, spender);\r\n    }\r\n\r\n    function _allowance(address owner, address spender) internal view virtual returns (uint256) {\r\n        return _allowances[owner][spender];\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.approve`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     */\r\n    function approve(address spender, uint256 value) external override returns (bool) {\r\n        _approve(msg.sender, spender, value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev See `IERC20.transferFrom`.\r\n     *\r\n     * Emits an `Approval` event indicating the updated allowance. This is not\r\n     * required by the EIP. See the note at the beginning of `ERC20`;\r\n     *\r\n     * Requirements:\r\n     * - `sender` and `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `value`.\r\n     * - the caller must have allowance for `sender`'s tokens of at least\r\n     * `amount`.\r\n     */\r\n    function transferFrom(address sender, address recipient, uint256 amount) external override returns (bool) {\r\n        _transfer(sender, recipient, amount);\r\n        _useAllowance(sender, msg.sender, amount);\r\n        return true;\r\n    }\r\n\r\n    function _useAllowance(address owner, address spender, uint256 amount) internal {\r\n        uint256 currentAllowance = _allowance(owner, spender);\r\n        if (currentAllowance < INFINITY) {\r\n            // Only decrease the allowance if it was not set to 'infinite'\r\n            // Documented in github.com/aktionariat/contracts/blob/master/doc/infiniteallowance.md\r\n            if (currentAllowance < amount) revert ERC20InsufficientAllowance(owner, currentAllowance, amount);\r\n            _approve(owner, spender, currentAllowance - amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\r\n     *\r\n     * This is internal function is equivalent to `transfer`, and can be used to\r\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\r\n     *\r\n     * Emits a `Transfer` event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `sender` cannot be the zero address.\r\n     * - `recipient` cannot be the zero address.\r\n     * - `sender` must have a balance of at least `amount`.\r\n     */\r\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\r\n        require(recipient != address(0));\r\n\r\n        _beforeTokenTransfer(sender, recipient, amount);\r\n        if (_balances[sender] < amount) revert ERC20InsufficientBalance(sender, _balances[sender], amount);\r\n        _balances[sender] -= amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(sender, recipient, amount);\r\n    }\r\n\r\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\r\n     * the total supply.\r\n     *\r\n     * Emits a `Transfer` event with `from` set to the zero address.\r\n     *\r\n     * Requirements\r\n     *\r\n     * - `to` cannot be the zero address.\r\n     */\r\n    function _mint(address recipient, uint256 amount) internal virtual {\r\n        require(recipient != address(0));\r\n\r\n        _beforeTokenTransfer(address(0), recipient, amount);\r\n\r\n        _totalSupply += amount;\r\n        _balances[recipient] += amount;\r\n        emit Transfer(address(0), recipient, amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Destroys `amount` tokens from `account`, reducing the\r\n     * total supply.\r\n     *\r\n     * Emits a `Transfer` event with `to` set to the zero address.\r\n     */\r\n    function _burn(address account, uint256 amount) internal virtual {\r\n        _beforeTokenTransfer(account, address(0), amount);\r\n\r\n        _totalSupply -= amount;\r\n        _balances[account] -= amount;\r\n        emit Transfer(account, address(0), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\r\n     *\r\n     * This is internal function is equivalent to `approve`, and can be used to\r\n     * e.g. set automatic allowances for certain subsystems, etc.\r\n     *\r\n     * Emits an `Approval` event.\r\n     */\r\n    function _approve(address owner, address spender, uint256 value) internal {\r\n        _allowances[owner][spender] = value;\r\n        emit Approval(owner, spender, value);\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any transfer of tokens. This includes\r\n     * minting and burning.\r\n     *\r\n     * Calling conditions:\r\n     *\r\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\r\n     * will be to transferred to `to`.\r\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\r\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\r\n     * - `from` and `to` are never both zero.\r\n     *\r\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\r\n     */\r\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\r\n}\r\n"
    },
    "contracts/utils/ERC20PermitLight.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// Copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol\r\n// and modified it.\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./ERC20.sol\";\r\n\r\nabstract contract ERC20PermitLight is ERC20 {\r\n    /*//////////////////////////////////////////////////////////////\r\n                            EIP-2612 STORAGE\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    mapping(address account => uint256 nonce) public nonces;\r\n\r\n    /*//////////////////////////////////////////////////////////////\r\n                             EIP-2612 LOGIC\r\n    //////////////////////////////////////////////////////////////*/\r\n\r\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\r\n        require(deadline >= block.timestamp, \"PERMIT_DEADLINE_EXPIRED\");\r\n\r\n        unchecked {\r\n            // unchecked to save a little gas with the nonce increment...\r\n            address recoveredAddress = ecrecover(\r\n                keccak256(\r\n                    abi.encodePacked(\r\n                        \"\\x19\\x01\",\r\n                        DOMAIN_SEPARATOR(),\r\n                        keccak256(\r\n                            abi.encode(\r\n                                // keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\"),\r\n                                bytes32(0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9),\r\n                                owner,\r\n                                spender,\r\n                                value,\r\n                                nonces[owner]++,\r\n                                deadline\r\n                            )\r\n                        )\r\n                    )\r\n                ),\r\n                v,\r\n                r,\r\n                s\r\n            );\r\n\r\n            require(recoveredAddress != address(0) && recoveredAddress == owner, \"INVALID_SIGNER\");\r\n            _approve(recoveredAddress, spender, value);\r\n        }\r\n    }\r\n\r\n    function DOMAIN_SEPARATOR() public view returns (bytes32) {\r\n        return\r\n            keccak256(\r\n                abi.encode(\r\n                    //keccak256(\"EIP712Domain(uint256 chainId,address verifyingContract)\");\r\n                    bytes32(0x47e79534a245952e8b16893a336b85a3d9ea9fa8c573f3d803afb92a79469218),\r\n                    block.chainid,\r\n                    address(this)\r\n                )\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/utils/MathUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @title Functions for share valuation\r\n */\r\ncontract MathUtil {\r\n    uint256 internal constant ONE_DEC18 = 10 ** 18;\r\n\r\n    // Let's go for 12 digits of precision (18-6)\r\n    uint256 internal constant THRESH_DEC18 = 10 ** 6;\r\n\r\n    /**\r\n     * @notice Cubic root with Halley approximation\r\n     *         Number 1e18 decimal\r\n     * @param _v     number for which we calculate x**(1/3)\r\n     * @return returns _v**(1/3)\r\n     */\r\n    function _cubicRoot(uint256 _v) internal pure returns (uint256) {\r\n        // Good first guess for _v slightly above 1.0, which is often the case in the Frankencoin system\r\n        uint256 x = _v > ONE_DEC18 && _v < 10 ** 19 ? (_v - ONE_DEC18) / 3 + ONE_DEC18 : ONE_DEC18;\r\n        uint256 diff;\r\n        do {\r\n            uint256 powX3 = _mulD18(_mulD18(x, x), x);\r\n            uint256 xnew = x * (powX3 + 2 * _v) / (2 * powX3 + _v);\r\n            diff = xnew > x ? xnew - x : x - xnew;\r\n            x = xnew;\r\n        } while (diff > THRESH_DEC18);\r\n        return x;\r\n    }\r\n\r\n    function _mulD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return (_a * _b) / ONE_DEC18;\r\n    }\r\n\r\n    function _divD18(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        return (_a * ONE_DEC18) / _b;\r\n    }\r\n\r\n    function _power3(uint256 _x) internal pure returns (uint256) {\r\n        return _mulD18(_mulD18(_x, _x), _x);\r\n    }\r\n\r\n    function _min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n"
    },
    "contracts/utils/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n//\r\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol\r\n//\r\n// Modifications:\r\n// - Replaced Context._msgSender() with msg.sender\r\n// - Made leaner\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Contract module which provides a basic access control mechanism, where\r\n * there is an account (an owner) that can be granted exclusive access to\r\n * specific functions.\r\n *\r\n * By default, the owner account will be the one that deploys the contract. This\r\n * can later be changed with {transferOwnership}.\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    error NotOwner();\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _setOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Internal function without access restriction.\r\n     */\r\n    function _setOwner(address newOwner) internal {\r\n        require(newOwner != address(0x0));\r\n        address oldOwner = owner;\r\n        owner = newOwner;\r\n        emit OwnershipTransferred(oldOwner, newOwner);\r\n    }\r\n\r\n    function _requireOwner(address sender) internal view {\r\n        if (owner != sender) revert NotOwner();\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        _requireOwner(msg.sender);\r\n        _;\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}