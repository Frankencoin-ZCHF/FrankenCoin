{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC-20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/interface/IDecentralizedEURO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IReserve} from \"./IReserve.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IDecentralizedEURO is IERC20 {\n    function suggestMinter(\n        address _minter,\n        uint256 _applicationPeriod,\n        uint256 _applicationFee,\n        string calldata _message\n    ) external;\n\n    function registerPosition(address position) external;\n\n    function denyMinter(address minter, address[] calldata helpers, string calldata message) external;\n\n    function reserve() external view returns (IReserve);\n\n    function minterReserve() external view returns (uint256);\n\n    function calculateAssignedReserve(uint256 mintedAmount, uint32 _reservePPM) external view returns (uint256);\n\n    function calculateFreedAmount(uint256 amountExcludingReserve, uint32 reservePPM) external view returns (uint256);\n\n    function equity() external view returns (uint256);\n\n    function isMinter(address minter) external view returns (bool);\n\n    function getPositionParent(address position) external view returns (address);\n\n    function mint(address target, uint256 amount) external;\n\n    function mintWithReserve(address target, uint256 amount, uint32 reservePPM, uint32 feePPM) external;\n\n    function burnFrom(address target, uint256 amount) external;\n\n    function burnWithoutReserve(uint256 amountIncludingReserve, uint32 reservePPM) external;\n\n    function burnFromWithReserve(\n        address payer,\n        uint256 targetTotalBurnAmount,\n        uint32 _reservePPM\n    ) external returns (uint256);\n\n    function burnWithReserve(uint256 amountExcludingReserve, uint32 reservePPM) external returns (uint256);\n\n    function coverLoss(address source, uint256 amount) external;\n\n    function collectProfits(address source, uint256 _amount) external;\n}\n"
    },
    "contracts/interface/IReserve.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IReserve is IERC20 {\n    function invest(uint256 amount, uint256 expected) external returns (uint256);\n    function checkQualified(address sender, address[] calldata helpers) external view;\n}\n"
    },
    "contracts/StablecoinBridge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport {IDecentralizedEURO} from \"./interface/IDecentralizedEURO.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\n\n/**\n * @title Stable Coin Bridge\n * @notice A minting contract for another Euro stablecoin ('source stablecoin') that we trust.\n * @author dEURO\n */\ncontract StablecoinBridge {\n    IERC20 public immutable eur; // the source stablecoin\n    IDecentralizedEURO public immutable dEURO; // the dEURO\n    uint8 private immutable eurDecimals;\n    uint8 private immutable dEURODecimals;\n\n    /**\n     * @notice The time horizon after which this bridge expires and needs to be replaced by a new contract.\n     */\n    uint256 public immutable horizon;\n\n    /**\n     * The maximum amount of outstanding converted source stablecoins.\n     */\n    uint256 public immutable limit;\n    uint256 public minted;\n\n    error Limit(uint256 amount, uint256 limit);\n    error Expired(uint256 time, uint256 expiration);\n    error UnsupportedToken(address token);\n\n    constructor(address other, address dEUROAddress, uint256 limit_, uint256 weeks_) {\n        eur = IERC20(other);\n        dEURO = IDecentralizedEURO(dEUROAddress);\n        eurDecimals = IERC20Metadata(other).decimals();\n        dEURODecimals = IERC20Metadata(dEUROAddress).decimals();\n        horizon = block.timestamp + weeks_ * 1 weeks;\n        limit = limit_;\n        minted = 0;\n    }\n\n    /**\n     * @notice Convenience method for mint(msg.sender, amount)\n     */\n    function mint(uint256 amount) external {\n        mintTo(msg.sender, amount);\n    }\n\n    /**\n     * @notice Mint the target amount of dEUROs, taking the equal amount of source coins from the sender.\n     * @dev This only works if an allowance for the source coins has been set and the caller has enough of them.\n     * @param amount The amount of the source stablecoin to bridge (convert).\n     */\n    function mintTo(address target, uint256 amount) public {\n        eur.transferFrom(msg.sender, address(this), amount);\n        \n        uint256 targetAmount = _convertAmount(amount, eurDecimals, dEURODecimals);\n        _mint(target, targetAmount);\n    }\n\n    function _mint(address target, uint256 amount) internal {\n        if (block.timestamp > horizon) revert Expired(block.timestamp, horizon);\n        dEURO.mint(target, amount);\n        minted += amount;\n        if (minted > limit) revert Limit(amount, limit);\n    }\n\n    /**\n     * @notice Convenience method for burnAndSend(msg.sender, amount)\n     * @param amount The amount of dEURO to burn.\n     */\n    function burn(uint256 amount) external {\n        _burn(msg.sender, msg.sender, amount);\n    }\n\n    /**\n     * @notice Burn the indicated amount of dEURO and send the same number of source coin to the caller.\n     */\n    function burnAndSend(address target, uint256 amount) external {\n        _burn(msg.sender, target, amount);\n    }\n\n    function _burn(address dEUROHolder, address target, uint256 amount) internal {\n        uint256 sourceAmount = _convertAmount(amount, dEURODecimals, eurDecimals);\n        dEURO.burnFrom(dEUROHolder, amount);\n        eur.transfer(target, sourceAmount);\n        minted -= amount;\n    }\n\n    /**\n     * @notice Converts an amount between two tokens with different decimal places.\n     * @param amount The amount to convert.\n     * @param fromDecimals The decimal places of the source token.\n     * @param toDecimals The decimal places of the target token.\n     */\n    function _convertAmount(uint256 amount, uint8 fromDecimals, uint8 toDecimals) internal pure returns (uint256) {\n        if (fromDecimals < toDecimals) {\n            return amount * 10**(toDecimals - fromDecimals);\n        } else if (fromDecimals > toDecimals) {\n            return amount / 10**(fromDecimals - toDecimals);\n        } else {\n            return amount;\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "paris",
    "metadata": {
      "useLiteralContent": true
    }
  }
}